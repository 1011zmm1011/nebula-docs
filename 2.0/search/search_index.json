{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Nebula Graph 2.0 Documentation \u00b6 Nebula Graph is a distributed, scalable, and lightning-fast graph database. It is the optimal solution in the world capable of hosting graphs with dozens of billions of vertices (nodes) and trillions of edges with millisecond latency. Tutorial Video \u00b6 YouTube bilibili Preface \u00b6 Manual Change Log Introduction \u00b6 What is Nebula Graph Quick start (for beginners) \u00b6 Quick start workflow Deploy Nebula Graph with Docker Compose Connect to Nebula Graph Nebula Graph CRUD nGQL guide (for all users) \u00b6 Operators Comparison Pipe Property reference Set String Precedence Functions and expressions Math String Date and time Schema Case expressions General query statements Match Space statements Create space Use space Show spaces Describe space Drop space Vertex statements Insert vertex Update vertex Upsert vertex Delete vertex Subgraph and path Get subgraph Query tuning statements Explain and profile Deployment and installation (for Developers and DBA) \u00b6 Resource preparations Compile and install Nebula Graph Install Nebula Graph by compiling the source code","title":"Welcome to Nebula Graph 2.0 Documentation"},{"location":"#welcome_to_nebula_graph_20_documentation","text":"Nebula Graph is a distributed, scalable, and lightning-fast graph database. It is the optimal solution in the world capable of hosting graphs with dozens of billions of vertices (nodes) and trillions of edges with millisecond latency.","title":"Welcome to Nebula Graph 2.0 Documentation"},{"location":"#tutorial_video","text":"YouTube bilibili","title":"Tutorial Video"},{"location":"#preface","text":"Manual Change Log","title":"Preface"},{"location":"#introduction","text":"What is Nebula Graph","title":"Introduction"},{"location":"#quick_start_for_beginners","text":"Quick start workflow Deploy Nebula Graph with Docker Compose Connect to Nebula Graph Nebula Graph CRUD","title":"Quick start (for beginners)"},{"location":"#ngql_guide_for_all_users","text":"Operators Comparison Pipe Property reference Set String Precedence Functions and expressions Math String Date and time Schema Case expressions General query statements Match Space statements Create space Use space Show spaces Describe space Drop space Vertex statements Insert vertex Update vertex Upsert vertex Delete vertex Subgraph and path Get subgraph Query tuning statements Explain and profile","title":"nGQL guide (for all users)"},{"location":"#deployment_and_installation_for_developers_and_dba","text":"Resource preparations Compile and install Nebula Graph Install Nebula Graph by compiling the source code","title":"Deployment and installation (for Developers and DBA)"},{"location":"CHANGELOG/","text":"Manual Changes \u00b6 0.1.1 - Initial release Nebula Graph alpha","title":"Manual Changes"},{"location":"CHANGELOG/#manual_changes","text":"0.1.1 - Initial release Nebula Graph alpha","title":"Manual Changes"},{"location":"1.introduction/1.what-is-nebula-graph/","text":"What is Nebula Graph \u00b6 Nebula Graph is an open-source, distributed, easily scalable, and native graph database. It is capable of hosting graphs with billions of vertices and trillions of edges, and serving queries with millisecond-latency. What is a graph database \u00b6 A graph database, such as Nebula Graph, is a database that specializes in storing vast graph networks and retrieving information from them. It efficiently stores data as vertices (nodes) and edges (relationships) in labeled property graphs. Properties can be attached to both vertices and edges. Each vertex can have one or multiple tags (labels). Graph databases are well suited for storing most kinds of data models abstracted from reality. Things are connected in almost all fields in the world. Modeling systems like relational databases extract the relationships between entities and squeeze them into table columns alone, with their types and properties stored in other columns or even other tables. This makes the data management time-consuming and cost-ineffective. Nebula Graph, as a typical native graph database, allows you to store the rich relationships as edges with edge types and properties directly attached to them. Benefits of Nebula Graph \u00b6 Open-source \u00b6 Nebula Graph is open under the Apache 2.0 and the Commons Clause 1.0 licenses. More and more people such as database developers, data scientists, security experts, and algorithm engineers are participating in the designing and development of Nebula Graph. To join the opening of source code and ideas, surf the Nebula Graph GitHub page . Outstanding performance \u00b6 Written in C++ and born for graph, Nebula Graph handles graph queries in milliseconds. Among most databases, Nebula Graph shows superior performance in providing graph data services. The larger the data size, the greater the superiority of Nebula Graph. For more information, see Nebula Graph benchmarking . Developer friendly \u00b6 Nebula Graph supports clients in popular programming languages like Java, Python, C++, and Go, and more are being developed. For more information, see Nebula Graph clients [TODO]. Diversified ecosystem \u00b6 More and more native tools of Nebula Graph have been released, such as Nebula Graph Studio , nebula-console , and Nebula Graph Exchange . Besides, Nebula Graph has the ability to be integrated with many cutting-edge technologies, such as Spark, Flink, and HBase, for the purpose of mutual strengthening in a world of increasing challenges and chances. For more information, see Ecosystem development [TODO]. OpenCypher-compatible query language \u00b6 The native Nebula Graph Query Language, also known as nGQL, is a declarative, openCypher-compatible textual query language. It is easy to understand and easy to use. For more information, see nGQL guide . Easy data modeling and high flexibility \u00b6 You can easily model the connected data into Nebula Graph for your business without forcing them into a structure such as a relational table, and properties can be added, updated, and deleted freely. For more information, see Data modeling [TODO]. Reliable access control \u00b6 Nebula Graph supports strict role-based access control and external authentication servers such as LDAP (Lightweight Directory Access Protocol) servers to enhance data security. For more information, see Authentication and authorization [TODO]. High scalability \u00b6 Nebula Graph is designed in a shared-nothing architecture and supports scaling in and out without interrupting the database service. High popularity \u00b6 Nebula Graph is being used by tech leaders such as Tencent, Vivo, Meituan, and JD Digits. For more information, visit the Nebula Graph official website . Use cases \u00b6 Nebula Graph can be used to support various graph-based scenarios. To spare the time spent on pushing the kinds of data mentioned in this section into relational databases and on bothering with join queries, use Nebula Graph. Fraud detection \u00b6 Financial institutions have to traverse countless transactions to piece together potential crimes and understand how combinations of transactions and devices might be related to a single fraud scheme. This kind of scenario can be modeled in graphs, and with the help of Nebula Graph, fraud rings and other sophisticated scams can be easily detected. Real-time recommendation \u00b6 Nebula Graph offers the ability to instantly process the real-time information produced by a visitor and make accurate recommendations on articles, videos, products, and services. Intelligent question-answer system \u00b6 Natural languages can be transformed into knowledge graphs and stored in Nebula Graph. A question organized in a natural language can be resolved by a semantic parser in an intelligent question-answer system and re-organized. Then, possible answers to the question can be retrieved from the knowledge graph and provided to the one who asked the question. Social networking \u00b6 Information on people and their relationships are typical graph data. Nebula Graph can easily handle the social networking information of billions of people and trillions of relationships, and provide lightning-fast queries for friend recommendations and job promotions in the case of massive concurrency.","title":"What is Nebula Graph"},{"location":"1.introduction/1.what-is-nebula-graph/#what_is_nebula_graph","text":"Nebula Graph is an open-source, distributed, easily scalable, and native graph database. It is capable of hosting graphs with billions of vertices and trillions of edges, and serving queries with millisecond-latency.","title":"What is Nebula Graph"},{"location":"1.introduction/1.what-is-nebula-graph/#what_is_a_graph_database","text":"A graph database, such as Nebula Graph, is a database that specializes in storing vast graph networks and retrieving information from them. It efficiently stores data as vertices (nodes) and edges (relationships) in labeled property graphs. Properties can be attached to both vertices and edges. Each vertex can have one or multiple tags (labels). Graph databases are well suited for storing most kinds of data models abstracted from reality. Things are connected in almost all fields in the world. Modeling systems like relational databases extract the relationships between entities and squeeze them into table columns alone, with their types and properties stored in other columns or even other tables. This makes the data management time-consuming and cost-ineffective. Nebula Graph, as a typical native graph database, allows you to store the rich relationships as edges with edge types and properties directly attached to them.","title":"What is a graph database"},{"location":"1.introduction/1.what-is-nebula-graph/#benefits_of_nebula_graph","text":"","title":"Benefits of Nebula Graph"},{"location":"1.introduction/1.what-is-nebula-graph/#open-source","text":"Nebula Graph is open under the Apache 2.0 and the Commons Clause 1.0 licenses. More and more people such as database developers, data scientists, security experts, and algorithm engineers are participating in the designing and development of Nebula Graph. To join the opening of source code and ideas, surf the Nebula Graph GitHub page .","title":"Open-source"},{"location":"1.introduction/1.what-is-nebula-graph/#outstanding_performance","text":"Written in C++ and born for graph, Nebula Graph handles graph queries in milliseconds. Among most databases, Nebula Graph shows superior performance in providing graph data services. The larger the data size, the greater the superiority of Nebula Graph. For more information, see Nebula Graph benchmarking .","title":"Outstanding performance"},{"location":"1.introduction/1.what-is-nebula-graph/#developer_friendly","text":"Nebula Graph supports clients in popular programming languages like Java, Python, C++, and Go, and more are being developed. For more information, see Nebula Graph clients [TODO].","title":"Developer friendly"},{"location":"1.introduction/1.what-is-nebula-graph/#diversified_ecosystem","text":"More and more native tools of Nebula Graph have been released, such as Nebula Graph Studio , nebula-console , and Nebula Graph Exchange . Besides, Nebula Graph has the ability to be integrated with many cutting-edge technologies, such as Spark, Flink, and HBase, for the purpose of mutual strengthening in a world of increasing challenges and chances. For more information, see Ecosystem development [TODO].","title":"Diversified ecosystem"},{"location":"1.introduction/1.what-is-nebula-graph/#opencypher-compatible_query_language","text":"The native Nebula Graph Query Language, also known as nGQL, is a declarative, openCypher-compatible textual query language. It is easy to understand and easy to use. For more information, see nGQL guide .","title":"OpenCypher-compatible query language"},{"location":"1.introduction/1.what-is-nebula-graph/#easy_data_modeling_and_high_flexibility","text":"You can easily model the connected data into Nebula Graph for your business without forcing them into a structure such as a relational table, and properties can be added, updated, and deleted freely. For more information, see Data modeling [TODO].","title":"Easy data modeling and high flexibility"},{"location":"1.introduction/1.what-is-nebula-graph/#reliable_access_control","text":"Nebula Graph supports strict role-based access control and external authentication servers such as LDAP (Lightweight Directory Access Protocol) servers to enhance data security. For more information, see Authentication and authorization [TODO].","title":"Reliable access control"},{"location":"1.introduction/1.what-is-nebula-graph/#high_scalability","text":"Nebula Graph is designed in a shared-nothing architecture and supports scaling in and out without interrupting the database service.","title":"High scalability"},{"location":"1.introduction/1.what-is-nebula-graph/#high_popularity","text":"Nebula Graph is being used by tech leaders such as Tencent, Vivo, Meituan, and JD Digits. For more information, visit the Nebula Graph official website .","title":"High popularity"},{"location":"1.introduction/1.what-is-nebula-graph/#use_cases","text":"Nebula Graph can be used to support various graph-based scenarios. To spare the time spent on pushing the kinds of data mentioned in this section into relational databases and on bothering with join queries, use Nebula Graph.","title":"Use cases"},{"location":"1.introduction/1.what-is-nebula-graph/#fraud_detection","text":"Financial institutions have to traverse countless transactions to piece together potential crimes and understand how combinations of transactions and devices might be related to a single fraud scheme. This kind of scenario can be modeled in graphs, and with the help of Nebula Graph, fraud rings and other sophisticated scams can be easily detected.","title":"Fraud detection"},{"location":"1.introduction/1.what-is-nebula-graph/#real-time_recommendation","text":"Nebula Graph offers the ability to instantly process the real-time information produced by a visitor and make accurate recommendations on articles, videos, products, and services.","title":"Real-time recommendation"},{"location":"1.introduction/1.what-is-nebula-graph/#intelligent_question-answer_system","text":"Natural languages can be transformed into knowledge graphs and stored in Nebula Graph. A question organized in a natural language can be resolved by a semantic parser in an intelligent question-answer system and re-organized. Then, possible answers to the question can be retrieved from the knowledge graph and provided to the one who asked the question.","title":"Intelligent question-answer system"},{"location":"1.introduction/1.what-is-nebula-graph/#social_networking","text":"Information on people and their relationships are typical graph data. Nebula Graph can easily handle the social networking information of billions of people and trillions of relationships, and provide lightning-fast queries for friend recommendations and job promotions in the case of massive concurrency.","title":"Social networking"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/","text":"Architecture overview \u00b6 Nebula Graph consists of three services: the Graph Service, the Storage Service, and the Meta Service. Each service has its executable binaries and processes launched from the binaries. You can deploy a Nebula Graph cluster on a single machine or multiple machines using these binaries. The following figure shows the architecture of a typical Nebula Graph cluster. The Meta Service \u00b6 The Meta Service in the Nebula Graph architecture is run by the nebula-metad processes. It is responsible for metadata management, such as schema operations, cluster administration, and user privilege management. For details on the Meta Service, see Meta Service . The Graph Service and the Storage Service \u00b6 Nebula Graph applies a disaggregated storage and compute architecture. The Graph Service is responsible for querying. The Storage Service is responsible for storage. And they run on different processes, i.e., nebula-graphd and nebula-storaged. The benefits of disaggregated storage and compute are as follows: Great scalability. A disaggregated structure makes both the Graph Service and the Storage Service flexible and easy to scale in or out. High availability. If part of the Graph Service fails, the data stored by the Storage Service suffers no loss. And if the rest part of the Graph Service is still able to serve the clients, service recovery can be performed quickly, or even unfelt by the users. Cost-effective. The separation of computing and storage provides a higher resource utilization rate, and it enables you to manage the cost flexibly according to business demands. The cost savings can be more significant if you use the Nebula Graph Cloud service. Open to more possibilities. With the ability to run separately, the Graph Service may work with multiple types of storage engines, and the Storage Service may serve more types of computing engines. For details on the Graph Service and the Storage Service, see Graph Service (TODO) and Storage Service (TODO).","title":"Architecture overview"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/#architecture_overview","text":"Nebula Graph consists of three services: the Graph Service, the Storage Service, and the Meta Service. Each service has its executable binaries and processes launched from the binaries. You can deploy a Nebula Graph cluster on a single machine or multiple machines using these binaries. The following figure shows the architecture of a typical Nebula Graph cluster.","title":"Architecture overview"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/#the_meta_service","text":"The Meta Service in the Nebula Graph architecture is run by the nebula-metad processes. It is responsible for metadata management, such as schema operations, cluster administration, and user privilege management. For details on the Meta Service, see Meta Service .","title":"The Meta Service"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/#the_graph_service_and_the_storage_service","text":"Nebula Graph applies a disaggregated storage and compute architecture. The Graph Service is responsible for querying. The Storage Service is responsible for storage. And they run on different processes, i.e., nebula-graphd and nebula-storaged. The benefits of disaggregated storage and compute are as follows: Great scalability. A disaggregated structure makes both the Graph Service and the Storage Service flexible and easy to scale in or out. High availability. If part of the Graph Service fails, the data stored by the Storage Service suffers no loss. And if the rest part of the Graph Service is still able to serve the clients, service recovery can be performed quickly, or even unfelt by the users. Cost-effective. The separation of computing and storage provides a higher resource utilization rate, and it enables you to manage the cost flexibly according to business demands. The cost savings can be more significant if you use the Nebula Graph Cloud service. Open to more possibilities. With the ability to run separately, the Graph Service may work with multiple types of storage engines, and the Storage Service may serve more types of computing engines. For details on the Graph Service and the Storage Service, see Graph Service (TODO) and Storage Service (TODO).","title":"The Graph Service and the Storage Service"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/","text":"Meta Service \u00b6 This topic describes the architecture and functions of the Meta Service. The architecture of the Meta Service \u00b6 The architecture of the Meta Service is as follows. The Meta Service is run by the nebula-metad processes. You can deploy nebula-metad processes according to the scenario: In a test environment, you can deploy one or three nebula-metad processes on different machines or a single machine. In a production environment, we recommend that you deploy three processes on different machines for high availability. All the nebula-metad processes form a Raft-based cluster, with one process as the leader and the others as the followers. The leader is elected by quorum, and only the leader can provide service to the clients and other components of Nebula Graph. The followers run in a standby way and each has a data replication of the leader. Once the leader fails, one of the followers will be elected as the new leader. Functions of the Meta Service \u00b6 Manages user accounts \u00b6 The Meta Service stores the information of user accounts and the privileges granted to the accounts. When the clients send queries to the Graph Service through an account, the Graph Service checks the account information and whether the account has the right privileges to execute the queries or not. For more information on Nebula Graph access control, see Authentication and authorization (TODO). Manages partitions \u00b6 The Meta Service stores and manages the locations of the storage partitions and helps balance the partitions. Manages graph spaces \u00b6 Nebula Graph supports multiple graph spaces. Data stored in different graph spaces are securely isolated. The Meta Service stores the metadata of all graph spaces and tracks the changes of them, such as adding or dropping a graph space. Manages schema information \u00b6 Nebula Graph is a strong-typed graph database. Its schema contains tags (i.e., the vertex types), edge types, tag properties, and edge type properties. The Meta Service stores the schema information. Besides, it performs the addition, modification, and deletion of the schema, and logs the versions of them. For more information on Nebula Graph schema, see Nebula Graph schema and data modeling (TODO). Manages TTL-based data eviction \u00b6 The Meta Service provides automatic data eviction and space reclamation based on TTL (time to live) options for Nebula Graph. For more information on TTL, see TTL options (TODO). Manages jobs \u00b6 The Job Manager module in the Meta Service is responsible for the creation, queuing, querying and deletion of jobs.","title":"Meta Service"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#meta_service","text":"This topic describes the architecture and functions of the Meta Service.","title":"Meta Service"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#the_architecture_of_the_meta_service","text":"The architecture of the Meta Service is as follows. The Meta Service is run by the nebula-metad processes. You can deploy nebula-metad processes according to the scenario: In a test environment, you can deploy one or three nebula-metad processes on different machines or a single machine. In a production environment, we recommend that you deploy three processes on different machines for high availability. All the nebula-metad processes form a Raft-based cluster, with one process as the leader and the others as the followers. The leader is elected by quorum, and only the leader can provide service to the clients and other components of Nebula Graph. The followers run in a standby way and each has a data replication of the leader. Once the leader fails, one of the followers will be elected as the new leader.","title":"The architecture of the Meta Service"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#functions_of_the_meta_service","text":"","title":"Functions of the Meta Service"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_user_accounts","text":"The Meta Service stores the information of user accounts and the privileges granted to the accounts. When the clients send queries to the Graph Service through an account, the Graph Service checks the account information and whether the account has the right privileges to execute the queries or not. For more information on Nebula Graph access control, see Authentication and authorization (TODO).","title":"Manages user accounts"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_partitions","text":"The Meta Service stores and manages the locations of the storage partitions and helps balance the partitions.","title":"Manages partitions"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_graph_spaces","text":"Nebula Graph supports multiple graph spaces. Data stored in different graph spaces are securely isolated. The Meta Service stores the metadata of all graph spaces and tracks the changes of them, such as adding or dropping a graph space.","title":"Manages graph spaces"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_schema_information","text":"Nebula Graph is a strong-typed graph database. Its schema contains tags (i.e., the vertex types), edge types, tag properties, and edge type properties. The Meta Service stores the schema information. Besides, it performs the addition, modification, and deletion of the schema, and logs the versions of them. For more information on Nebula Graph schema, see Nebula Graph schema and data modeling (TODO).","title":"Manages schema information"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_ttl-based_data_eviction","text":"The Meta Service provides automatic data eviction and space reclamation based on TTL (time to live) options for Nebula Graph. For more information on TTL, see TTL options (TODO).","title":"Manages TTL-based data eviction"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_jobs","text":"The Job Manager module in the Meta Service is responsible for the creation, queuing, querying and deletion of jobs.","title":"Manages jobs"},{"location":"2.quick-start/1.quick-start-workflow/","text":"Quick start workflow \u00b6 The quick start introduces the simplest workflow to using Nebula Graph, including deploying Nebula Graph, connecting to Nebula Graph, and doing basic CRUD. Deploy Nebula Graph with Docker Compose Connect to Nebula Graph CRUD in Nebula Graph Other frequently read topics are recommended as follows. They are not in the quick start, but you may need them as soon as you pass the quick start phase. Deploy a Nebula Graph cluster (TODO) Compaction and job management","title":"Quick start workflow"},{"location":"2.quick-start/1.quick-start-workflow/#quick_start_workflow","text":"The quick start introduces the simplest workflow to using Nebula Graph, including deploying Nebula Graph, connecting to Nebula Graph, and doing basic CRUD. Deploy Nebula Graph with Docker Compose Connect to Nebula Graph CRUD in Nebula Graph Other frequently read topics are recommended as follows. They are not in the quick start, but you may need them as soon as you pass the quick start phase. Deploy a Nebula Graph cluster (TODO) Compaction and job management","title":"Quick start workflow"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/","text":"Deploy Nebula Graph with Docker Compose \u00b6 There are multiple ways to deploy Nebula Graph, but using Docker Compose is usually considered to be a fast starter. Reading guide \u00b6 If you are reading this topic with the questions listed below, click them to jump to their answers. What do I need to do before deploying Nebula Graph? How to fast deploy Nebula Graph with Docker Compose? How to check the status and ports of the Nebula Graph services? How to check the data and logs of the Nebula Graph services? How to stop the Nebula Graph services? What are the other ways to install Nebula Graph? Prerequisites \u00b6 You have installed the following applications on your host. Application Recommended version Official installation reference Docker Latest Install Docker Engine Docker Compose Latest Install Docker Compose Git Latest Download Git If you are deploying Nebula Graph as a non-root user, grant the user with Docker-related privileges. For a detailed instruction, see Docker docs: Manage Docker as a non-root user . You have started the Docker service on your host. If you have already deployed another version of Nebula Graph with Docker Compose on your host, to avoid compatibility issues\uff0cback up the service data if you need, and delete the nebula-docker-compose/data directory. How to deploy \u00b6 Clone the v2-preview branch of the nebula-docker-compose repository to your host with Git. [TODO: Update the branch name on the release on 2.0.0-alpha.] DON'T : The v2-preview branch stores the Docker Compose solution for the latest Nebula Graph development release, the 2.0.0-alpha. DON'T use this release for production. $ git clone --branch v2-preview https://github.com/vesoft-inc/nebula-docker-compose.git Go to the nebula-docker-compose directory. $ cd nebula-docker-compose/ Run the following command to start all the Nebula Graph services. $ docker-compose up -d The following information indicates the services have started: Creating network \"nebula-docker-compose_nebula-net\" with the default driver Creating nebula-docker-compose_metad1_1 ... done Creating nebula-docker-compose_metad2_1 ... done Creating nebula-docker-compose_metad0_1 ... done Creating nebula-docker-compose_storaged2_1 ... done Creating nebula-docker-compose_graphd2_1 ... done Creating nebula-docker-compose_storaged1_1 ... done Creating nebula-docker-compose_graphd_1 ... done Creating nebula-docker-compose_graphd1_1 ... done Creating nebula-docker-compose_storaged0_1 ... done NOTE : For more information of the preceding services, see Design and Architecture of Nebula Graph . Use nebula-console to connect to Nebula Graph. Nebula-console is the native CLI client of Nebula Graph. In this step, Docker pulls the nebula-console images automatically from Docker Hub according to the path you set in the following commands and uses it to connect to the Graph Service of Nebula Graph. $ docker run --rm -ti --network nebula-docker-compose_nebula-net vesoft/nebula-console:v2-preview-nightly --address = graphd --port = 3699 -u <username> -p <password> [TODO: Update the docker image tag on the release of 2.0 alpha.] NOTE : By default, the authentication is disabled. You can use any username or password to connect to Nebula Graph. When the authentication is enabled, use the default username root and its password nebula . The following information indicates that you have connected to the Nebula Graph services: Welcome to Nebula Graph v2.0.0-alpha! ( user@nebula ) [( none )] > Check the Nebula Graph service status and port \u00b6 Run docker-compose ps to list all the services of Nebula Graph and their status and ports. $ docker-compose ps Name Command State Ports --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- nebula-docker-compose_graphd1_1 ./bin/nebula-graphd --flag ... Up ( healthy ) 0 .0.0.0:32776->13000/tcp, 0 .0.0.0:32772->13002/tcp, 0 .0.0.0:32780->3699/tcp nebula-docker-compose_graphd2_1 ./bin/nebula-graphd --flag ... Up ( healthy ) 0 .0.0.0:32769->13000/tcp, 0 .0.0.0:32768->13002/tcp, 0 .0.0.0:32773->3699/tcp nebula-docker-compose_graphd_1 ./bin/nebula-graphd --flag ... Up ( healthy ) 0 .0.0.0:32791->13000/tcp, 0 .0.0.0:32788->13002/tcp, 0 .0.0.0:32794->3699/tcp nebula-docker-compose_metad0_1 ./bin/nebula-metad --flagf ... Up ( healthy ) 0 .0.0.0:32793->11000/tcp, 0 .0.0.0:32790->11002/tcp, 0 .0.0.0:32787->45500/tcp, 45501 /tcp nebula-docker-compose_metad1_1 ./bin/nebula-metad --flagf ... Up ( healthy ) 0 .0.0.0:32792->11000/tcp, 0 .0.0.0:32789->11002/tcp, 0 .0.0.0:32786->45500/tcp, 45501 /tcp nebula-docker-compose_metad2_1 ./bin/nebula-metad --flagf ... Up ( healthy ) 0 .0.0.0:32785->11000/tcp, 0 .0.0.0:32784->11002/tcp, 0 .0.0.0:32782->45500/tcp, 45501 /tcp nebula-docker-compose_storaged0_1 ./bin/nebula-storaged --fl ... Up ( healthy ) 0 .0.0.0:32777->12000/tcp, 0 .0.0.0:32774->12002/tcp, 0 .0.0.0:32770->44500/tcp, 44501 /tcp nebula-docker-compose_storaged1_1 ./bin/nebula-storaged --fl ... Up ( healthy ) 0 .0.0.0:32778->12000/tcp, 0 .0.0.0:32775->12002/tcp, 0 .0.0.0:32771->44500/tcp, 44501 /tcp nebula-docker-compose_storaged2_1 ./bin/nebula-storaged --fl ... Up ( healthy ) 0 .0.0.0:32783->12000/tcp, 0 .0.0.0:32781->12002/tcp, 0 .0.0.0:32779->44500/tcp, 44501 /tcp NOTE : Nebula Graph provides services to the clients through port 3699 by default. You can adjust the port number by modifying the network configurations . To check the machine status and partition distribution, run the SHOW HOSTS statement. Check the service data and logs \u00b6 All the data and logs of Nebula Graph are stored persistently in the nebula-docker-compose/data and nebula-docker-compose/logs directories. The structure of the directories is as follows: nebula-docker-compose/ |-- docker-compose.yaml \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 meta0 \u2502 \u251c\u2500\u2500 meta1 \u2502 \u251c\u2500\u2500 meta2 \u2502 \u251c\u2500\u2500 storage0 \u2502 \u251c\u2500\u2500 storage1 \u2502 \u2514\u2500\u2500 storage2 \u2514\u2500\u2500 logs \u251c\u2500\u2500 graph \u251c\u2500\u2500 graph1 \u251c\u2500\u2500 graph2 \u251c\u2500\u2500 meta0 \u251c\u2500\u2500 meta1 \u251c\u2500\u2500 meta2 \u251c\u2500\u2500 storage0 \u251c\u2500\u2500 storage1 \u2514\u2500\u2500 storage2 Stop the Nebula Graph services \u00b6 You can run the following command to stop the Nebula Graph services: $ docker-compose down The following information indicates you have successfully stopped the Nebula Graph services: Stopping nebula-docker-compose_storaged0_1 ... done Stopping nebula-docker-compose_graphd1_1 ... done Stopping nebula-docker-compose_graphd_1 ... done Stopping nebula-docker-compose_storaged1_1 ... done Stopping nebula-docker-compose_graphd2_1 ... done Stopping nebula-docker-compose_storaged2_1 ... done Stopping nebula-docker-compose_metad0_1 ... done Stopping nebula-docker-compose_metad2_1 ... done Stopping nebula-docker-compose_metad1_1 ... done Removing nebula-docker-compose_storaged0_1 ... done Removing nebula-docker-compose_graphd1_1 ... done Removing nebula-docker-compose_graphd_1 ... done Removing nebula-docker-compose_storaged1_1 ... done Removing nebula-docker-compose_graphd2_1 ... done Removing nebula-docker-compose_storaged2_1 ... done Removing nebula-docker-compose_metad0_1 ... done Removing nebula-docker-compose_metad2_1 ... done Removing nebula-docker-compose_metad1_1 ... done Removing network nebula-docker-compose_nebula-net Other ways to install Nebula Graph \u00b6 Use Source Code Use Docker (TODO) Use .rpm or .deb Files (TODO) FAQ \u00b6 Q1: How to update the nebula-console client \u00b6 To update the nebula-console client, use the docker pull command in the nebula-docker-compose directory on your host. docker pull vesoft/nebula-console:v2-preview-nightly Q2: How to update the docker images of Nebula Graph services \u00b6 To update the images of the Graph Service, Storage Service, and Meta Service, run docker-compose pull in the nebula-docker-compose directory.","title":"Deploy Nebula\u00a0Graph with Docker Compose"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#deploy_nebula_graph_with_docker_compose","text":"There are multiple ways to deploy Nebula Graph, but using Docker Compose is usually considered to be a fast starter.","title":"Deploy Nebula Graph with Docker Compose"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#reading_guide","text":"If you are reading this topic with the questions listed below, click them to jump to their answers. What do I need to do before deploying Nebula Graph? How to fast deploy Nebula Graph with Docker Compose? How to check the status and ports of the Nebula Graph services? How to check the data and logs of the Nebula Graph services? How to stop the Nebula Graph services? What are the other ways to install Nebula Graph?","title":"Reading guide"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#prerequisites","text":"You have installed the following applications on your host. Application Recommended version Official installation reference Docker Latest Install Docker Engine Docker Compose Latest Install Docker Compose Git Latest Download Git If you are deploying Nebula Graph as a non-root user, grant the user with Docker-related privileges. For a detailed instruction, see Docker docs: Manage Docker as a non-root user . You have started the Docker service on your host. If you have already deployed another version of Nebula Graph with Docker Compose on your host, to avoid compatibility issues\uff0cback up the service data if you need, and delete the nebula-docker-compose/data directory.","title":"Prerequisites"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#how_to_deploy","text":"Clone the v2-preview branch of the nebula-docker-compose repository to your host with Git. [TODO: Update the branch name on the release on 2.0.0-alpha.] DON'T : The v2-preview branch stores the Docker Compose solution for the latest Nebula Graph development release, the 2.0.0-alpha. DON'T use this release for production. $ git clone --branch v2-preview https://github.com/vesoft-inc/nebula-docker-compose.git Go to the nebula-docker-compose directory. $ cd nebula-docker-compose/ Run the following command to start all the Nebula Graph services. $ docker-compose up -d The following information indicates the services have started: Creating network \"nebula-docker-compose_nebula-net\" with the default driver Creating nebula-docker-compose_metad1_1 ... done Creating nebula-docker-compose_metad2_1 ... done Creating nebula-docker-compose_metad0_1 ... done Creating nebula-docker-compose_storaged2_1 ... done Creating nebula-docker-compose_graphd2_1 ... done Creating nebula-docker-compose_storaged1_1 ... done Creating nebula-docker-compose_graphd_1 ... done Creating nebula-docker-compose_graphd1_1 ... done Creating nebula-docker-compose_storaged0_1 ... done NOTE : For more information of the preceding services, see Design and Architecture of Nebula Graph . Use nebula-console to connect to Nebula Graph. Nebula-console is the native CLI client of Nebula Graph. In this step, Docker pulls the nebula-console images automatically from Docker Hub according to the path you set in the following commands and uses it to connect to the Graph Service of Nebula Graph. $ docker run --rm -ti --network nebula-docker-compose_nebula-net vesoft/nebula-console:v2-preview-nightly --address = graphd --port = 3699 -u <username> -p <password> [TODO: Update the docker image tag on the release of 2.0 alpha.] NOTE : By default, the authentication is disabled. You can use any username or password to connect to Nebula Graph. When the authentication is enabled, use the default username root and its password nebula . The following information indicates that you have connected to the Nebula Graph services: Welcome to Nebula Graph v2.0.0-alpha! ( user@nebula ) [( none )] >","title":"How to deploy"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#check_the_nebula_graph_service_status_and_port","text":"Run docker-compose ps to list all the services of Nebula Graph and their status and ports. $ docker-compose ps Name Command State Ports --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- nebula-docker-compose_graphd1_1 ./bin/nebula-graphd --flag ... Up ( healthy ) 0 .0.0.0:32776->13000/tcp, 0 .0.0.0:32772->13002/tcp, 0 .0.0.0:32780->3699/tcp nebula-docker-compose_graphd2_1 ./bin/nebula-graphd --flag ... Up ( healthy ) 0 .0.0.0:32769->13000/tcp, 0 .0.0.0:32768->13002/tcp, 0 .0.0.0:32773->3699/tcp nebula-docker-compose_graphd_1 ./bin/nebula-graphd --flag ... Up ( healthy ) 0 .0.0.0:32791->13000/tcp, 0 .0.0.0:32788->13002/tcp, 0 .0.0.0:32794->3699/tcp nebula-docker-compose_metad0_1 ./bin/nebula-metad --flagf ... Up ( healthy ) 0 .0.0.0:32793->11000/tcp, 0 .0.0.0:32790->11002/tcp, 0 .0.0.0:32787->45500/tcp, 45501 /tcp nebula-docker-compose_metad1_1 ./bin/nebula-metad --flagf ... Up ( healthy ) 0 .0.0.0:32792->11000/tcp, 0 .0.0.0:32789->11002/tcp, 0 .0.0.0:32786->45500/tcp, 45501 /tcp nebula-docker-compose_metad2_1 ./bin/nebula-metad --flagf ... Up ( healthy ) 0 .0.0.0:32785->11000/tcp, 0 .0.0.0:32784->11002/tcp, 0 .0.0.0:32782->45500/tcp, 45501 /tcp nebula-docker-compose_storaged0_1 ./bin/nebula-storaged --fl ... Up ( healthy ) 0 .0.0.0:32777->12000/tcp, 0 .0.0.0:32774->12002/tcp, 0 .0.0.0:32770->44500/tcp, 44501 /tcp nebula-docker-compose_storaged1_1 ./bin/nebula-storaged --fl ... Up ( healthy ) 0 .0.0.0:32778->12000/tcp, 0 .0.0.0:32775->12002/tcp, 0 .0.0.0:32771->44500/tcp, 44501 /tcp nebula-docker-compose_storaged2_1 ./bin/nebula-storaged --fl ... Up ( healthy ) 0 .0.0.0:32783->12000/tcp, 0 .0.0.0:32781->12002/tcp, 0 .0.0.0:32779->44500/tcp, 44501 /tcp NOTE : Nebula Graph provides services to the clients through port 3699 by default. You can adjust the port number by modifying the network configurations . To check the machine status and partition distribution, run the SHOW HOSTS statement.","title":"Check the Nebula Graph service status and port"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#check_the_service_data_and_logs","text":"All the data and logs of Nebula Graph are stored persistently in the nebula-docker-compose/data and nebula-docker-compose/logs directories. The structure of the directories is as follows: nebula-docker-compose/ |-- docker-compose.yaml \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 meta0 \u2502 \u251c\u2500\u2500 meta1 \u2502 \u251c\u2500\u2500 meta2 \u2502 \u251c\u2500\u2500 storage0 \u2502 \u251c\u2500\u2500 storage1 \u2502 \u2514\u2500\u2500 storage2 \u2514\u2500\u2500 logs \u251c\u2500\u2500 graph \u251c\u2500\u2500 graph1 \u251c\u2500\u2500 graph2 \u251c\u2500\u2500 meta0 \u251c\u2500\u2500 meta1 \u251c\u2500\u2500 meta2 \u251c\u2500\u2500 storage0 \u251c\u2500\u2500 storage1 \u2514\u2500\u2500 storage2","title":"Check the service data and logs"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#stop_the_nebula_graph_services","text":"You can run the following command to stop the Nebula Graph services: $ docker-compose down The following information indicates you have successfully stopped the Nebula Graph services: Stopping nebula-docker-compose_storaged0_1 ... done Stopping nebula-docker-compose_graphd1_1 ... done Stopping nebula-docker-compose_graphd_1 ... done Stopping nebula-docker-compose_storaged1_1 ... done Stopping nebula-docker-compose_graphd2_1 ... done Stopping nebula-docker-compose_storaged2_1 ... done Stopping nebula-docker-compose_metad0_1 ... done Stopping nebula-docker-compose_metad2_1 ... done Stopping nebula-docker-compose_metad1_1 ... done Removing nebula-docker-compose_storaged0_1 ... done Removing nebula-docker-compose_graphd1_1 ... done Removing nebula-docker-compose_graphd_1 ... done Removing nebula-docker-compose_storaged1_1 ... done Removing nebula-docker-compose_graphd2_1 ... done Removing nebula-docker-compose_storaged2_1 ... done Removing nebula-docker-compose_metad0_1 ... done Removing nebula-docker-compose_metad2_1 ... done Removing nebula-docker-compose_metad1_1 ... done Removing network nebula-docker-compose_nebula-net","title":"Stop the Nebula Graph services"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#other_ways_to_install_nebula_graph","text":"Use Source Code Use Docker (TODO) Use .rpm or .deb Files (TODO)","title":"Other ways to install Nebula Graph"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#faq","text":"","title":"FAQ"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#q1_how_to_update_the_nebula-console_client","text":"To update the nebula-console client, use the docker pull command in the nebula-docker-compose directory on your host. docker pull vesoft/nebula-console:v2-preview-nightly","title":"Q1: How to update the nebula-console client"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#q2_how_to_update_the_docker_images_of_nebula_graph_services","text":"To update the images of the Graph Service, Storage Service, and Meta Service, run docker-compose pull in the nebula-docker-compose directory.","title":"Q2: How to update the docker images of Nebula Graph services"},{"location":"2.quick-start/3.connect-to-nebula-graph/","text":"Connect to Nebula Graph \u00b6 Nebula Graph supports multiple types of clients, including a CLI client, a GUI client, and clients developed in popular programming languages. This topic provides an overview of Nebula Graph clients and basic instructions on how to use the native CLI client, nebula-console. Nebula Graph clients \u00b6 Client Introduction Connection guide nebula-console The native command-line interface of Nebula Graph Connect to Nebula Graph with nebula-console Nebula Graph Studio The official graphical user interface for Nebula Graph Connect to Nebula Graph with Nebula Graph Studio nebula-go The official Golang client of Nebula Graph nebula-go code example nebula-python The official Python client of Nebula Graph How to use nebula-python in your code nebula-java The official Python client of Nebula Graph Graph Client Example If you don't have a Nebula Graph database yet, we recommend that you try the cloud service. Nebula Graph Cloud Service supports on-demand deployment and fast building, and uses Nebula Graph Studio as its default client. Use nebula-console to connect to Nebula Graph \u00b6 Prerequisites \u00b6 You have started the Nebula Graph services. For how to start the services, see Start and Stop Nebula Graph services (TODO). The machine you plan to run nebula-console on has network access to the Nebula Graph services. Steps \u00b6 On the nebula-console Releases page, select a nebula-console version and click Assets . NOTE: We recommend that you select the latest release. In the Assets area, find the correct binary file for the machine where you want to run nebula-console and download the file to the machine. (Optional) Rename the binary file to nebula-console for convenience. NOTE: For Windows, rename the file to nebula-console.exe . On the machine to run nebula-console, grant the execute permission of the nebula-console binary file to the user. NOTE: For Windows, skip this step. $ chmod 111 nebula-console In the command line interface, change the working directory to the one where the nebula-console binary file is stored. Run the following command to connect to Nebula Graph. * For Linux or macOS: $ ./nebula-console -addr <ip> -port <port> -u <username> -p <password> [ -t 120 ] [ -e \"nGQL_statement\" | -f filename.nGQL ] * For Windows: ```powershell > nebula-console.exe -addr <ip> -port <port> -u <username> -p <password> [-t 120] [-e \"nGQL_statement\" | -f filename.nGQL] ``` The description of the parameters is as follows. Option Description -h Shows the help menu. -addr Sets the IP address of the graphd service. The default address is 127.0.0.1. -port Sets the port number of the graphd service. The default port number is 3699. -u/-user Sets the username of your Nebula Graph account. Before enabling authentication, you can use any characters as the username. -p/-password Sets the password of your Nebula Graph account. Before enabling authentication, you can use any characters as the password. -t/-timeout Sets an integer-type timeout threshold of the connection. The unit is second. The default value is 120. -e/-eval Sets a string-type nGQL statement. The nGQL statement is executed once the connection succeeds. The connection stops after the result is returned. -f/-file Sets the path of an nGQL file. The nGQL statements in the file are executed once the connection succeeds. You'll get the return messages and the connection stops then. Nebula-console export mode \u00b6 When the export mode is enabled, nebula-console exports all the query results into a CSV file. When the export mode is disabled, the export stops. The syntax is as follows. NOTE : The following commands are case insensitive. Enable nebula-console export mode: nebula> :SET CSV <your_file.csv>; Disable nebula-console export mode: nebula> :UNSET CSV; Disconnect nebula-console from Nebula Graph \u00b6 You can use :EXIT or :QUIT to disconnect from Nebula Graph. For convenience, nebula-console supports using these commands in lower case without the colon (\":\"), such as quit . nebula> :QUIT Bye root! FAQ \u00b6 How can I install nebula-console from the source code \u00b6 To download and compile the latest source code of nebula-console, follow the instructions on the nebula console GitHub page .","title":"Connect to Nebula\u00a0Graph"},{"location":"2.quick-start/3.connect-to-nebula-graph/#connect_to_nebula_graph","text":"Nebula Graph supports multiple types of clients, including a CLI client, a GUI client, and clients developed in popular programming languages. This topic provides an overview of Nebula Graph clients and basic instructions on how to use the native CLI client, nebula-console.","title":"Connect to Nebula Graph"},{"location":"2.quick-start/3.connect-to-nebula-graph/#nebula_graph_clients","text":"Client Introduction Connection guide nebula-console The native command-line interface of Nebula Graph Connect to Nebula Graph with nebula-console Nebula Graph Studio The official graphical user interface for Nebula Graph Connect to Nebula Graph with Nebula Graph Studio nebula-go The official Golang client of Nebula Graph nebula-go code example nebula-python The official Python client of Nebula Graph How to use nebula-python in your code nebula-java The official Python client of Nebula Graph Graph Client Example If you don't have a Nebula Graph database yet, we recommend that you try the cloud service. Nebula Graph Cloud Service supports on-demand deployment and fast building, and uses Nebula Graph Studio as its default client.","title":"Nebula Graph clients"},{"location":"2.quick-start/3.connect-to-nebula-graph/#use_nebula-console_to_connect_to_nebula_graph","text":"","title":"Use nebula-console to connect to Nebula Graph"},{"location":"2.quick-start/3.connect-to-nebula-graph/#prerequisites","text":"You have started the Nebula Graph services. For how to start the services, see Start and Stop Nebula Graph services (TODO). The machine you plan to run nebula-console on has network access to the Nebula Graph services.","title":"Prerequisites"},{"location":"2.quick-start/3.connect-to-nebula-graph/#steps","text":"On the nebula-console Releases page, select a nebula-console version and click Assets . NOTE: We recommend that you select the latest release. In the Assets area, find the correct binary file for the machine where you want to run nebula-console and download the file to the machine. (Optional) Rename the binary file to nebula-console for convenience. NOTE: For Windows, rename the file to nebula-console.exe . On the machine to run nebula-console, grant the execute permission of the nebula-console binary file to the user. NOTE: For Windows, skip this step. $ chmod 111 nebula-console In the command line interface, change the working directory to the one where the nebula-console binary file is stored. Run the following command to connect to Nebula Graph. * For Linux or macOS: $ ./nebula-console -addr <ip> -port <port> -u <username> -p <password> [ -t 120 ] [ -e \"nGQL_statement\" | -f filename.nGQL ] * For Windows: ```powershell > nebula-console.exe -addr <ip> -port <port> -u <username> -p <password> [-t 120] [-e \"nGQL_statement\" | -f filename.nGQL] ``` The description of the parameters is as follows. Option Description -h Shows the help menu. -addr Sets the IP address of the graphd service. The default address is 127.0.0.1. -port Sets the port number of the graphd service. The default port number is 3699. -u/-user Sets the username of your Nebula Graph account. Before enabling authentication, you can use any characters as the username. -p/-password Sets the password of your Nebula Graph account. Before enabling authentication, you can use any characters as the password. -t/-timeout Sets an integer-type timeout threshold of the connection. The unit is second. The default value is 120. -e/-eval Sets a string-type nGQL statement. The nGQL statement is executed once the connection succeeds. The connection stops after the result is returned. -f/-file Sets the path of an nGQL file. The nGQL statements in the file are executed once the connection succeeds. You'll get the return messages and the connection stops then.","title":"Steps"},{"location":"2.quick-start/3.connect-to-nebula-graph/#nebula-console_export_mode","text":"When the export mode is enabled, nebula-console exports all the query results into a CSV file. When the export mode is disabled, the export stops. The syntax is as follows. NOTE : The following commands are case insensitive. Enable nebula-console export mode: nebula> :SET CSV <your_file.csv>; Disable nebula-console export mode: nebula> :UNSET CSV;","title":"Nebula-console export mode"},{"location":"2.quick-start/3.connect-to-nebula-graph/#disconnect_nebula-console_from_nebula_graph","text":"You can use :EXIT or :QUIT to disconnect from Nebula Graph. For convenience, nebula-console supports using these commands in lower case without the colon (\":\"), such as quit . nebula> :QUIT Bye root!","title":"Disconnect nebula-console from Nebula Graph"},{"location":"2.quick-start/3.connect-to-nebula-graph/#faq","text":"","title":"FAQ"},{"location":"2.quick-start/3.connect-to-nebula-graph/#how_can_i_install_nebula-console_from_the_source_code","text":"To download and compile the latest source code of nebula-console, follow the instructions on the nebula console GitHub page .","title":"How can I install nebula-console from the source code"},{"location":"2.quick-start/4.nebula-graph-crud/","text":"Nebula Graph CRUD \u00b6 This topic describes the basic CRUD operations in Nebula Graph. Graph space and Nebula Graph schema \u00b6 A Nebula Graph instance consists of one or more graph spaces. Graph spaces are physically isolated from each other. You can use different graph spaces in the same instance to store different datasets. To insert data into a graph space, define a schema for the graph database. Nebula Graph schema is based on the following components. Schema component Description Vertex Represents an entity in the real world. A vertex can have one or more tags. Tag The type of a vertex. It defines a group of properties that describes a type of vertices. Edge Represents a directed relationship between two vertices. Edge type The type of an edge. It defines a group of properties that describes a type of edges. For more information, see Nebula Graph schema (doc TODO). In this topic, we use the following dataset to demonstrate basic CRUD operations. Check the machine status in the Nebula Graph cluster \u00b6 First, we recommend that you check the machine status to make sure that all the Storage services are connected to the Meta Services. Run SHOW HOSTS as follows. (root@nebula) [(none)]> SHOW HOSTS; +-----------+-------+--------+--------------+---------------------+------------------------+ | Host | Port | Status | Leader count | Leader distribution | Partition distribution | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged0 | 44500 | ONLINE | 0 | No valid partition | No valid partition | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged1 | 44500 | ONLINE | 0 | No valid partition | No valid partition | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged2 | 44500 | ONLINE | 0 | No valid partition | No valid partition | +-----------+-------+--------+--------------+---------------------+------------------------+ Got 3 rows (time spent 1775/2334 us) From the Status column of the table in the return message, you can see that all the Storage services are online. Create and use a graph space \u00b6 nGQL syntax \u00b6 Create a graph space: CREATE SPACE <graph_space_name> [(partition_num=<partition number>, replica_factor=<replica number>), vid_type=fixed_string(<string_number>))] Property Description partition_num Specifies the number of partitions in each replica. The suggested number is the number of hard disks in the cluster times 5. For example, if you have 3 hard disks in the cluster, we recommend that you set 15 partitions. replica_factor Specifies the number of replicas in the Nebula Graph cluster. The suggested number is 3 in a production environment and 1 in a test environment. The replica number must always be an odd number for the need of quorum-based voting. vid_type To insert a vertex with a string-typed VID, set the fixed_string length for the maximum VID length. The default fixed_string is 8. Note: fix_string(N) is similar to varchar(N) in SQL. List graph spaces: nebula> SHOW SPACES; Use a graph space: USE <graph_space_name> Examples \u00b6 Use the following statement to create a graph space named nba . nebula> CREATE SPACE nba(partition_num=15, replica_factor=1, vid_type=fixed_string(30)); Execution succeeded (time spent 2817/3280 us) Check the partition distribution with SHOW HOSTS to make sure that the partitions are distributed in a balanced way. nebula> SHOW HOSTS; +-----------+-------+--------+--------------+---------------------+------------------------+ | Host | Port | Status | Leader count | Leader distribution | Partition distribution | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged0 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged1 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged2 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ Got 3 rows (time spent 744/1123 us) If the Leader distribution is uneven, use BALANCE LEADER to redistribute the partitions. For more information, see BALANCE (doc TODO). Use the nba graph space. nebula> USE nba; Execution succeeded (time spent 1322/2206 us) You can use SHOW SPACES to check the graph space you created. nebula> SHOW SPACES; +------+ | Name | +------+ | nba | +------+ Got 1 rows (time spent 1235/1934 us) Create tags and edge types \u00b6 nGQL syntax \u00b6 CREATE {TAG | EDGE} {<tag_name> | <edge_type>}(<property_name> <data_type> [, <property_name> <data_type> ...]); Examples \u00b6 Create tags player and team , edge types follow and serve . Component name Type Property player Tag name (string), age (int) team Tag name (string) follow Edge type degree (int) serve Edge type start_year (int), end_year (int) nebula> CREATE TAG player(name string, age int); Execution succeeded (time spent 2694/3116 us) Thu, 15 Oct 2020 06:22:29 UTC nebula> CREATE TAG team(name string); Execution succeeded (time spent 2630/3002 us) Thu, 15 Oct 2020 06:22:37 UTC nebula> CREATE EDGE follow(degree int); Execution succeeded (time spent 3087/3467 us) Thu, 15 Oct 2020 06:22:43 UTC nebula> CREATE EDGE serve(start_year int, end_year int); Execution succeeded (time spent 2645/3123 us) Thu, 15 Oct 2020 06:22:50 UTC Insert vertices and edges \u00b6 You can use the INSERT statement to insert vertices or edges based on existing tags or edge types. nGQL syntax \u00b6 Insert vertices: INSERT VERTEX <tag_name> (<property_name>[, <property_name>...]) [, <tag_name> (<property_name>[, <property_name>...]), ...] {VALUES | VALUE} <vid>: (<property_value>[, <property_value>...]) [, <vid>: (<property_value>[, <property_value>...]; VID is short for vertex ID. A VID must be a unique string value in a graph space. Insert edges: INSERT EDGE <edge_type> (<property_name>[, <property_name>...]) {VALUES | VALUE} <src_vid> -> <dst_vid>[@<rank>] : (<property_value>[, <property_value>...]) [, <src_vid> -> <dst_vid>[@<rank> : (<property_name>[, <property_name>...]), ...] Examples \u00b6 Insert vertices representing NBA players and teams: nebula> INSERT VERTEX player(name, age) VALUES \"player100\":(\"Tim Duncan\", 42); Execution succeeded (time spent 2919/3485 us) Fri, 16 Oct 2020 03:41:00 UTC nebula> INSERT VERTEX player(name, age) VALUES \"player101\":(\"Tony Parker\", 36); Execution succeeded (time spent 3007/3539 us) Fri, 16 Oct 2020 03:41:58 UTC nebula> INSERT VERTEX player(name, age) VALUES \"player102\":(\"LaMarcus Aldridge\", 33); Execution succeeded (time spent 2449/2934 us) Fri, 16 Oct 2020 03:42:16 UTC nebula> INSERT VERTEX team(name) VALUES \"team200\":(\"Warriors\"), \"team201\":(\"Nuggets\"); Execution succeeded (time spent 3514/4331 us) Fri, 16 Oct 2020 03:42:45 UTC Insert edges representing the relations between NBA players and teams: nebula> INSERT EDGE follow(degree) VALUES \"player100\" -> \"player101\":(95); Execution succeeded (time spent 1488/1918 us) Wed, 21 Oct 2020 06:57:32 UTC nebula> INSERT EDGE follow(degree) VALUES \"player100\" -> \"player102\":(90); Execution succeeded (time spent 2483/2890 us) Wed, 21 Oct 2020 07:05:48 UTC nebula> INSERT EDGE follow(degree) VALUES \"player102\" -> \"player101\":(75); Execution succeeded (time spent 1208/1689 us) Wed, 21 Oct 2020 07:07:12 UTC nebula> INSERT EDGE serve(start_year, end_year) VALUES \"player100\" -> \"team200\":(1997, 2016), \"player101\" -> \"team201\":(1999, 2018); Execution succeeded (time spent 2170/2651 us) Wed, 21 Oct 2020 07:08:59 UTC Read data \u00b6 You can use the statements GO (doc TODO), FETCH (doc TODO), and LOOKUP to retrieve vertex and edge data. GO is the most commonly used read statement. It traverses the database based on specific conditions. A GO traversal starts from one or more vertices, along one or more edges, and return information in a form specified in the YIELD clause. FETCH is used to get properties from vertices or edges. The LOOKUP statement is based on indexes . It is used together with the WHERE clause to search for the data that meet the specific conditions. nGQL syntax \u00b6 GO GO [[<M> TO] <N> STEPS ] FROM <vertex_list> OVER <edge_type_list> [REVERSELY] [BIDIRECT] [WHERE <expression> [AND | OR expression ...])] YIELD [DISTINCT] <return_list> FETCH Fetch properties on tags: FETCH PROP ON {<tag_name> | <tag_name_list> | *} <vid_list> [YIELD [DISTINCT] <return_list>] Fetch properties on edges: FETCH PROP ON <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <src_vid> -> <dst_vid> ...] [YIELD [DISTINCT] <return_list>] LOOKUP LOOKUP ON {<tag_name> | <edge_type>} WHERE <expression> [AND expression ...])] [YIELD <return_list>] Examples \u00b6 Use GO : Find the vertices that VID \"player100\" follows. nebula> GO FROM \"player100\" OVER follow; +-------------+ | follow._dst | +-------------+ | player101 | +-------------+ | player102 | +-------------+ Got 2 rows (time spent 1935/2420 us) Use GO : Search for the players that the player with VID \"player100\" follows. Filter the the players that the player with VID \"player100\" follows whose age is equal to or greater than 35. Rename the columns in the result with Teammate and Age . nebula> GO FROM \"player100\" OVER follow WHERE $$.player.age >= 35 \\ YIELD $$.player.name AS Teammate, $$.player.age AS Age; +-------------+-----+ | Teammate | Age | +-------------+-----+ | Tony Parker | 36 | +-------------+-----+ Got 1 rows (time spent 3871/4349 us) Clause/Sign Description YIELD Specifies what values or results you want to return from the query. $$ Represents the target vertices. \\ A line-breaker. Use GO : Search for the players that the player with VID \"player100\" follows. Then Retrieve the teams of the players that the player with VID \"player100\" follows. To combine the two queries, use a pipe or a temporary variable. With a pipe: nebula> GO FROM \"player100\" OVER follow YIELD follow._dst AS id | \\ GO FROM $-.id OVER serve YIELD $$.team.name AS Team, \\ $^.player.name AS Player; +---------+-------------+ | Team | Player | +---------+-------------+ | Nuggets | Tony Parker | +---------+-------------+ Got 1 rows (time spent 2902/3496 us) Clause/Sign Description $^ Represents the source vertex of the edge. \\ $- Represents the output of the query before the pipe symbol. With a temporary variable: NOTE : Once a compound statement is submitted to the server as a whole, the life cycle of the temporary variables in the statement ends. nebula> $var = GO FROM \"player100\" OVER follow YIELD follow._dst AS id; \\ GO FROM $var.id OVER serve YIELD $$.team.name AS Team, \\ $^.player.name AS Player; +---------+-------------+ | Team | Player | +---------+-------------+ | Nuggets | Tony Parker | +---------+-------------+ Got 1 rows (time spent 3103/3711 us) Use FETCH : Fetch the properties of the player with VID player100. nebula> FETCH PROP ON player \"player100\"; +----------+-------------+------------+ | VertexID | player.name | player.age | +----------+-------------+------------+ | player100 | Tim Duncan | 42 | +----------+-------------+------------+ Got 1 rows (time spent 2006/2406 us) Use LOOKUP : Find the information of the vertex with the tag player and its value of the name property is \"Tony Parker\" . nebula> LOOKUP ON player WHERE player.name == \"Tony Parker\" \\ YIELD player.name, player.age; Update vertices and edges \u00b6 You can use the UPDATE statement or the UPSERT statement to update existing data. UPSERT is the combination of UPDATE and INSERT . If you update a vertex or an edge with UPSERT , it inserts a new vertex or edge if it does not exist. nGQL syntax \u00b6 UPDATE vertices: UPDATE VERTEX <vid> SET <properties to be updated> [WHEN <condition>] [YIELD <columns>] UPDATE edges: UPDATE EDGE <source vid> -> <destination vid> [@rank] OF <edge_type> SET <properties to be updated> [WHEN <condition>] [YIELD <columns to be output>] UPSERT vertices or edges: UPSERT {VERTEX <vid> | EDGE <edge_type>} SET <update_columns> [WHEN <condition>] [YIELD <columns>] Examples \u00b6 UPDATE the name property of the vertex with VID \"player100\" and check the result with the FETCH statement: nebula> UPDATE VERTEX \"player100\" SET player.name = \"Tim\"; Execution succeeded (time spent 3483/3914 us) Wed, 21 Oct 2020 10:53:14 UTC nebula> FETCH PROP ON player \"player100\"; +----------+-------------+------------+ | VertexID | player.name | player.age | +----------+-------------+------------+ | player100 | Tim | 42 | +----------+-------------+------------+ Got 1 rows (time spent 2463/3042 us) UPDATE the degree value of an edge and check the result with the FETCH statement: nebula> UPDATE EDGE \"player100\" -> \"player101\" OF follow SET degree = 96; Execution succeeded (time spent 3932/4432 us) nebula> FETCH PROP ON follow \"player100\" -> \"player101\"; +-------------+-------------+--------------+---------------+ | follow._src | follow._dst | follow._rank | follow.degree | +-------------+-------------+--------------+---------------+ | player100 | player101 | 0 | 96 | +-------------+-------------+--------------+---------------+ Got 1 rows (time spent 2205/2800 us) Insert a vertex with VID \"player111\" and UPSERT it. nebula> INSERT VERTEX player(name, age) VALUES \"player111\":(\"Ben Simmons\", 22); Execution succeeded (time spent 2115/2900 us) Wed, 21 Oct 2020 11:11:50 UTC nebula> UPSERT VERTEX \"player111\" SET player.name = \"Dwight Howard\", player.age = $^.player.age + 11 \\ WHEN $^.player.name == \"Ben Simmons\" AND $^.player.age > 20 \\ YIELD $^.player.name AS Name, $^.player.age AS Age; +---------------+-----+ | Name | Age | +---------------+-----+ | Dwight Howard | 33 | +---------------+-----+ Got 1 rows (time spent 1815/2329 us) Delete vertices and edges \u00b6 nGQL syntax \u00b6 Delete vertices: DELETE VERTEX <vid1>[, <vid2>...] Delete edges: DELETE EDGE <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <src_vid> -> <dst_vid>...] Examples \u00b6 Delete vertices: nebula> DELETE VERTEX \"team1\", \"team2\"; Execution succeeded (time spent 4337/4782 us) Delete edges: nebula> DELETE EDGE follow \"team1\" -> \"team2\"; Execution succeeded (time spent 3700/4101 us) About indexes \u00b6 You can add indexes to tags or edge types with the CREATE INDEX statement. Must-read for using index \u00b6 Applicable use of indexes can speed up queries, but indexes also decrease the write performance. DO NOT use indexes in production environments unless you are fully aware of their influences on your service. Rebuild indexes for pre-existing data. Otherwise, the pre-existing data can't be indexed. For more information, see Rebuild indexes . nGQL syntax \u00b6 Create an index: CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] <index_name> ON {<tag_name> | <edge_name>} (prop_name_list); Rebuild an index: REBUILD {TAG | EDGE} INDEX <index_name> Examples \u00b6 Create an index for the name property on all vertices with the tag player . nebula> CREATE TAG INDEX player_index_0 on player(name); nebula> REBUILD TAG INDEX player_index_0; FAQ \u00b6 How is the time spent value at the end of each return message calculated? \u00b6 Take the return message of SHOW SPACES as an example: nebula> SHOW SPACES; +------+ | Name | +------+ | nba | +------+ Got 1 rows (time spent 1235/1934 us) The first number 1235 shows the time spent by the database itself, that is, the time it takes for the query engine to receive a query from the client, fetch the data from the storage server and perform a series of calculation. The second number 1934 shows the time spent from the client's perspective, that is, the time it takes for the client from sending a request, receiving a response, and displaying the result on the screen.","title":"Nebula\u00a0Graph CRUD"},{"location":"2.quick-start/4.nebula-graph-crud/#nebula_graph_crud","text":"This topic describes the basic CRUD operations in Nebula Graph.","title":"Nebula Graph CRUD"},{"location":"2.quick-start/4.nebula-graph-crud/#graph_space_and_nebula_graph_schema","text":"A Nebula Graph instance consists of one or more graph spaces. Graph spaces are physically isolated from each other. You can use different graph spaces in the same instance to store different datasets. To insert data into a graph space, define a schema for the graph database. Nebula Graph schema is based on the following components. Schema component Description Vertex Represents an entity in the real world. A vertex can have one or more tags. Tag The type of a vertex. It defines a group of properties that describes a type of vertices. Edge Represents a directed relationship between two vertices. Edge type The type of an edge. It defines a group of properties that describes a type of edges. For more information, see Nebula Graph schema (doc TODO). In this topic, we use the following dataset to demonstrate basic CRUD operations.","title":"Graph space and Nebula Graph schema"},{"location":"2.quick-start/4.nebula-graph-crud/#check_the_machine_status_in_the_nebula_graph_cluster","text":"First, we recommend that you check the machine status to make sure that all the Storage services are connected to the Meta Services. Run SHOW HOSTS as follows. (root@nebula) [(none)]> SHOW HOSTS; +-----------+-------+--------+--------------+---------------------+------------------------+ | Host | Port | Status | Leader count | Leader distribution | Partition distribution | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged0 | 44500 | ONLINE | 0 | No valid partition | No valid partition | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged1 | 44500 | ONLINE | 0 | No valid partition | No valid partition | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged2 | 44500 | ONLINE | 0 | No valid partition | No valid partition | +-----------+-------+--------+--------------+---------------------+------------------------+ Got 3 rows (time spent 1775/2334 us) From the Status column of the table in the return message, you can see that all the Storage services are online.","title":"Check the machine status in the Nebula Graph cluster"},{"location":"2.quick-start/4.nebula-graph-crud/#create_and_use_a_graph_space","text":"","title":"Create and use a graph space"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax","text":"Create a graph space: CREATE SPACE <graph_space_name> [(partition_num=<partition number>, replica_factor=<replica number>), vid_type=fixed_string(<string_number>))] Property Description partition_num Specifies the number of partitions in each replica. The suggested number is the number of hard disks in the cluster times 5. For example, if you have 3 hard disks in the cluster, we recommend that you set 15 partitions. replica_factor Specifies the number of replicas in the Nebula Graph cluster. The suggested number is 3 in a production environment and 1 in a test environment. The replica number must always be an odd number for the need of quorum-based voting. vid_type To insert a vertex with a string-typed VID, set the fixed_string length for the maximum VID length. The default fixed_string is 8. Note: fix_string(N) is similar to varchar(N) in SQL. List graph spaces: nebula> SHOW SPACES; Use a graph space: USE <graph_space_name>","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples","text":"Use the following statement to create a graph space named nba . nebula> CREATE SPACE nba(partition_num=15, replica_factor=1, vid_type=fixed_string(30)); Execution succeeded (time spent 2817/3280 us) Check the partition distribution with SHOW HOSTS to make sure that the partitions are distributed in a balanced way. nebula> SHOW HOSTS; +-----------+-------+--------+--------------+---------------------+------------------------+ | Host | Port | Status | Leader count | Leader distribution | Partition distribution | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged0 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged1 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged2 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ Got 3 rows (time spent 744/1123 us) If the Leader distribution is uneven, use BALANCE LEADER to redistribute the partitions. For more information, see BALANCE (doc TODO). Use the nba graph space. nebula> USE nba; Execution succeeded (time spent 1322/2206 us) You can use SHOW SPACES to check the graph space you created. nebula> SHOW SPACES; +------+ | Name | +------+ | nba | +------+ Got 1 rows (time spent 1235/1934 us)","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#create_tags_and_edge_types","text":"","title":"Create tags and edge types"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_1","text":"CREATE {TAG | EDGE} {<tag_name> | <edge_type>}(<property_name> <data_type> [, <property_name> <data_type> ...]);","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_1","text":"Create tags player and team , edge types follow and serve . Component name Type Property player Tag name (string), age (int) team Tag name (string) follow Edge type degree (int) serve Edge type start_year (int), end_year (int) nebula> CREATE TAG player(name string, age int); Execution succeeded (time spent 2694/3116 us) Thu, 15 Oct 2020 06:22:29 UTC nebula> CREATE TAG team(name string); Execution succeeded (time spent 2630/3002 us) Thu, 15 Oct 2020 06:22:37 UTC nebula> CREATE EDGE follow(degree int); Execution succeeded (time spent 3087/3467 us) Thu, 15 Oct 2020 06:22:43 UTC nebula> CREATE EDGE serve(start_year int, end_year int); Execution succeeded (time spent 2645/3123 us) Thu, 15 Oct 2020 06:22:50 UTC","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#insert_vertices_and_edges","text":"You can use the INSERT statement to insert vertices or edges based on existing tags or edge types.","title":"Insert vertices and edges"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_2","text":"Insert vertices: INSERT VERTEX <tag_name> (<property_name>[, <property_name>...]) [, <tag_name> (<property_name>[, <property_name>...]), ...] {VALUES | VALUE} <vid>: (<property_value>[, <property_value>...]) [, <vid>: (<property_value>[, <property_value>...]; VID is short for vertex ID. A VID must be a unique string value in a graph space. Insert edges: INSERT EDGE <edge_type> (<property_name>[, <property_name>...]) {VALUES | VALUE} <src_vid> -> <dst_vid>[@<rank>] : (<property_value>[, <property_value>...]) [, <src_vid> -> <dst_vid>[@<rank> : (<property_name>[, <property_name>...]), ...]","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_2","text":"Insert vertices representing NBA players and teams: nebula> INSERT VERTEX player(name, age) VALUES \"player100\":(\"Tim Duncan\", 42); Execution succeeded (time spent 2919/3485 us) Fri, 16 Oct 2020 03:41:00 UTC nebula> INSERT VERTEX player(name, age) VALUES \"player101\":(\"Tony Parker\", 36); Execution succeeded (time spent 3007/3539 us) Fri, 16 Oct 2020 03:41:58 UTC nebula> INSERT VERTEX player(name, age) VALUES \"player102\":(\"LaMarcus Aldridge\", 33); Execution succeeded (time spent 2449/2934 us) Fri, 16 Oct 2020 03:42:16 UTC nebula> INSERT VERTEX team(name) VALUES \"team200\":(\"Warriors\"), \"team201\":(\"Nuggets\"); Execution succeeded (time spent 3514/4331 us) Fri, 16 Oct 2020 03:42:45 UTC Insert edges representing the relations between NBA players and teams: nebula> INSERT EDGE follow(degree) VALUES \"player100\" -> \"player101\":(95); Execution succeeded (time spent 1488/1918 us) Wed, 21 Oct 2020 06:57:32 UTC nebula> INSERT EDGE follow(degree) VALUES \"player100\" -> \"player102\":(90); Execution succeeded (time spent 2483/2890 us) Wed, 21 Oct 2020 07:05:48 UTC nebula> INSERT EDGE follow(degree) VALUES \"player102\" -> \"player101\":(75); Execution succeeded (time spent 1208/1689 us) Wed, 21 Oct 2020 07:07:12 UTC nebula> INSERT EDGE serve(start_year, end_year) VALUES \"player100\" -> \"team200\":(1997, 2016), \"player101\" -> \"team201\":(1999, 2018); Execution succeeded (time spent 2170/2651 us) Wed, 21 Oct 2020 07:08:59 UTC","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#read_data","text":"You can use the statements GO (doc TODO), FETCH (doc TODO), and LOOKUP to retrieve vertex and edge data. GO is the most commonly used read statement. It traverses the database based on specific conditions. A GO traversal starts from one or more vertices, along one or more edges, and return information in a form specified in the YIELD clause. FETCH is used to get properties from vertices or edges. The LOOKUP statement is based on indexes . It is used together with the WHERE clause to search for the data that meet the specific conditions.","title":"Read data"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_3","text":"GO GO [[<M> TO] <N> STEPS ] FROM <vertex_list> OVER <edge_type_list> [REVERSELY] [BIDIRECT] [WHERE <expression> [AND | OR expression ...])] YIELD [DISTINCT] <return_list> FETCH Fetch properties on tags: FETCH PROP ON {<tag_name> | <tag_name_list> | *} <vid_list> [YIELD [DISTINCT] <return_list>] Fetch properties on edges: FETCH PROP ON <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <src_vid> -> <dst_vid> ...] [YIELD [DISTINCT] <return_list>] LOOKUP LOOKUP ON {<tag_name> | <edge_type>} WHERE <expression> [AND expression ...])] [YIELD <return_list>]","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_3","text":"Use GO : Find the vertices that VID \"player100\" follows. nebula> GO FROM \"player100\" OVER follow; +-------------+ | follow._dst | +-------------+ | player101 | +-------------+ | player102 | +-------------+ Got 2 rows (time spent 1935/2420 us) Use GO : Search for the players that the player with VID \"player100\" follows. Filter the the players that the player with VID \"player100\" follows whose age is equal to or greater than 35. Rename the columns in the result with Teammate and Age . nebula> GO FROM \"player100\" OVER follow WHERE $$.player.age >= 35 \\ YIELD $$.player.name AS Teammate, $$.player.age AS Age; +-------------+-----+ | Teammate | Age | +-------------+-----+ | Tony Parker | 36 | +-------------+-----+ Got 1 rows (time spent 3871/4349 us) Clause/Sign Description YIELD Specifies what values or results you want to return from the query. $$ Represents the target vertices. \\ A line-breaker. Use GO : Search for the players that the player with VID \"player100\" follows. Then Retrieve the teams of the players that the player with VID \"player100\" follows. To combine the two queries, use a pipe or a temporary variable. With a pipe: nebula> GO FROM \"player100\" OVER follow YIELD follow._dst AS id | \\ GO FROM $-.id OVER serve YIELD $$.team.name AS Team, \\ $^.player.name AS Player; +---------+-------------+ | Team | Player | +---------+-------------+ | Nuggets | Tony Parker | +---------+-------------+ Got 1 rows (time spent 2902/3496 us) Clause/Sign Description $^ Represents the source vertex of the edge. \\ $- Represents the output of the query before the pipe symbol. With a temporary variable: NOTE : Once a compound statement is submitted to the server as a whole, the life cycle of the temporary variables in the statement ends. nebula> $var = GO FROM \"player100\" OVER follow YIELD follow._dst AS id; \\ GO FROM $var.id OVER serve YIELD $$.team.name AS Team, \\ $^.player.name AS Player; +---------+-------------+ | Team | Player | +---------+-------------+ | Nuggets | Tony Parker | +---------+-------------+ Got 1 rows (time spent 3103/3711 us) Use FETCH : Fetch the properties of the player with VID player100. nebula> FETCH PROP ON player \"player100\"; +----------+-------------+------------+ | VertexID | player.name | player.age | +----------+-------------+------------+ | player100 | Tim Duncan | 42 | +----------+-------------+------------+ Got 1 rows (time spent 2006/2406 us) Use LOOKUP : Find the information of the vertex with the tag player and its value of the name property is \"Tony Parker\" . nebula> LOOKUP ON player WHERE player.name == \"Tony Parker\" \\ YIELD player.name, player.age;","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#update_vertices_and_edges","text":"You can use the UPDATE statement or the UPSERT statement to update existing data. UPSERT is the combination of UPDATE and INSERT . If you update a vertex or an edge with UPSERT , it inserts a new vertex or edge if it does not exist.","title":"Update vertices and edges"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_4","text":"UPDATE vertices: UPDATE VERTEX <vid> SET <properties to be updated> [WHEN <condition>] [YIELD <columns>] UPDATE edges: UPDATE EDGE <source vid> -> <destination vid> [@rank] OF <edge_type> SET <properties to be updated> [WHEN <condition>] [YIELD <columns to be output>] UPSERT vertices or edges: UPSERT {VERTEX <vid> | EDGE <edge_type>} SET <update_columns> [WHEN <condition>] [YIELD <columns>]","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_4","text":"UPDATE the name property of the vertex with VID \"player100\" and check the result with the FETCH statement: nebula> UPDATE VERTEX \"player100\" SET player.name = \"Tim\"; Execution succeeded (time spent 3483/3914 us) Wed, 21 Oct 2020 10:53:14 UTC nebula> FETCH PROP ON player \"player100\"; +----------+-------------+------------+ | VertexID | player.name | player.age | +----------+-------------+------------+ | player100 | Tim | 42 | +----------+-------------+------------+ Got 1 rows (time spent 2463/3042 us) UPDATE the degree value of an edge and check the result with the FETCH statement: nebula> UPDATE EDGE \"player100\" -> \"player101\" OF follow SET degree = 96; Execution succeeded (time spent 3932/4432 us) nebula> FETCH PROP ON follow \"player100\" -> \"player101\"; +-------------+-------------+--------------+---------------+ | follow._src | follow._dst | follow._rank | follow.degree | +-------------+-------------+--------------+---------------+ | player100 | player101 | 0 | 96 | +-------------+-------------+--------------+---------------+ Got 1 rows (time spent 2205/2800 us) Insert a vertex with VID \"player111\" and UPSERT it. nebula> INSERT VERTEX player(name, age) VALUES \"player111\":(\"Ben Simmons\", 22); Execution succeeded (time spent 2115/2900 us) Wed, 21 Oct 2020 11:11:50 UTC nebula> UPSERT VERTEX \"player111\" SET player.name = \"Dwight Howard\", player.age = $^.player.age + 11 \\ WHEN $^.player.name == \"Ben Simmons\" AND $^.player.age > 20 \\ YIELD $^.player.name AS Name, $^.player.age AS Age; +---------------+-----+ | Name | Age | +---------------+-----+ | Dwight Howard | 33 | +---------------+-----+ Got 1 rows (time spent 1815/2329 us)","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#delete_vertices_and_edges","text":"","title":"Delete vertices and edges"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_5","text":"Delete vertices: DELETE VERTEX <vid1>[, <vid2>...] Delete edges: DELETE EDGE <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <src_vid> -> <dst_vid>...]","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_5","text":"Delete vertices: nebula> DELETE VERTEX \"team1\", \"team2\"; Execution succeeded (time spent 4337/4782 us) Delete edges: nebula> DELETE EDGE follow \"team1\" -> \"team2\"; Execution succeeded (time spent 3700/4101 us)","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#about_indexes","text":"You can add indexes to tags or edge types with the CREATE INDEX statement.","title":"About indexes"},{"location":"2.quick-start/4.nebula-graph-crud/#must-read_for_using_index","text":"Applicable use of indexes can speed up queries, but indexes also decrease the write performance. DO NOT use indexes in production environments unless you are fully aware of their influences on your service. Rebuild indexes for pre-existing data. Otherwise, the pre-existing data can't be indexed. For more information, see Rebuild indexes .","title":"Must-read for using index"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_6","text":"Create an index: CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] <index_name> ON {<tag_name> | <edge_name>} (prop_name_list); Rebuild an index: REBUILD {TAG | EDGE} INDEX <index_name>","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_6","text":"Create an index for the name property on all vertices with the tag player . nebula> CREATE TAG INDEX player_index_0 on player(name); nebula> REBUILD TAG INDEX player_index_0;","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#faq","text":"","title":"FAQ"},{"location":"2.quick-start/4.nebula-graph-crud/#how_is_the_time_spent_value_at_the_end_of_each_return_message_calculated","text":"Take the return message of SHOW SPACES as an example: nebula> SHOW SPACES; +------+ | Name | +------+ | nba | +------+ Got 1 rows (time spent 1235/1934 us) The first number 1235 shows the time spent by the database itself, that is, the time it takes for the query engine to receive a query from the client, fetch the data from the storage server and perform a series of calculation. The second number 1934 shows the time spent from the client's perspective, that is, the time it takes for the client from sending a request, receiving a response, and displaying the result on the screen.","title":"How is the time spent value at the end of each return message calculated?"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/","text":"INSERT VERTEX \u00b6 INSERT VERTEX <tag_name> (<prop_name_list>) [, <tag_name> (<prop_name_list>), ...] {VALUES | VALUE} VID: (<prop_value_list>[, <prop_value_list>]) prop_name_list: [prop_name [, prop_name] ...] prop_value_list: [prop_value [, prop_value] ...] The INSERT VERTEX statement inserts one or more vertices into a graph space in a Nebula Graph instance. tag_name denotes the tag (vertex type), which must be created before INSERT VERTEX . prop_name_list contains the names of the properties on the tag. VID is the vertex ID. In Nebula Graph 2.0.0-alpha, only string type VID is supported. The maximum VID length is set when a graph space is created. For detail information on the maximum VID length, see CREATE SPACE . prop_value_list must provide the property values according to the prop_name_list . If the property values do not match the data type in the tag, an error is returned. When the NOT NULL constraint is set for a given property, an error is returned if no property is given. When the default value for a property is NULL , you can omit to specify the property value. (TODO: create tag doc) Examples \u00b6 nebula> CREATE TAG t1(); -- Create tag t1 with no property nebula> INSERT VERTEX t1() VALUE \"10\":(); -- Insert vertex \"10\" with no property nebula> CREATE TAG t2 (name string, age int); -- Create tag t2 with two properties nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n1\", 12); -- Insert vertex \"11\" with two properties nebula> INSERT VERTEX t2 (name, age) VALUES \"12\":(\"n1\", \"a13\"); -- Failed. \"a13\" is not int nebula> INSERT VERTEX t2 (name, age) VALUES \"13\":(\"n3\", 12), \"14\":(\"n4\", 8); -- Insert two vertices nebula> CREATE TAG t3(p1 int); nebula> CREATE TAG t4(p2 string); nebula> INSERT VERTEX t3 (p1), t4(p2) VALUES \"21\": (321, \"hello\"); -- Insert vertex \"21\" with two tags. A vertex can be inserted/written multiple times. Only the last written values can be read. -- insert vertex \"11\" with the new values. nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n2\", 13); nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n3\", 14); nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n4\", 15); nebula> FETCH PROP ON t2 \"11\"; +----------+---------+--------+ | VertexID | t2.name | t2.age | +----------+---------+--------+ | \"11\" | \"n4\" | 15 | -- Only the last version can be read +----------+---------+--------+ nebula> CREATE TAG t5(p1 fixed_string(5) NOT NULL, p2 int, p3 int DEFAULT NULL); nebula> INSERT VERTEX t5(p1, p2, p3) VALUES \"001\":(\"Abe\", 2, 3); nebula> INSERT VERTEX t5(p1, p2, p3) VALUES \"002\":(NULL, 4, 5); [ERROR (-8)]: Storage Error: The not null field cannot be null. nebula> INSERT VERTEX t5(p1, p2) VALUES \"003\":(\"cd\", 5); nebula> FETCH PROP ON t5 \"003\"; +----------+-------+-------+-------+ | VertexID | t5.p1 | t5.p2 | t5.p3 | +----------+-------+-------+-------+ | \"003\" | \"cd\" | 5 | NULL | -- The value for p3 is the default NULL. +----------+-------+-------+-------+ nebula> INSERT VERTEX t5(p1, p2) VALUES \"004\":(\"shalalalala\", 4); nebula> FETCH PROP on t5 \"004\"; +----------+---------+-------+-------+ | VertexID | t5.p1 | t5.p2 | t5.p3 | +----------+---------+-------+-------+ | \"004\" | \"shala\" | 4 | NULL | -- The allowed maximum length for property p1 is 5. +----------+---------+-------+-------+","title":"INSERT VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/#insert_vertex","text":"INSERT VERTEX <tag_name> (<prop_name_list>) [, <tag_name> (<prop_name_list>), ...] {VALUES | VALUE} VID: (<prop_value_list>[, <prop_value_list>]) prop_name_list: [prop_name [, prop_name] ...] prop_value_list: [prop_value [, prop_value] ...] The INSERT VERTEX statement inserts one or more vertices into a graph space in a Nebula Graph instance. tag_name denotes the tag (vertex type), which must be created before INSERT VERTEX . prop_name_list contains the names of the properties on the tag. VID is the vertex ID. In Nebula Graph 2.0.0-alpha, only string type VID is supported. The maximum VID length is set when a graph space is created. For detail information on the maximum VID length, see CREATE SPACE . prop_value_list must provide the property values according to the prop_name_list . If the property values do not match the data type in the tag, an error is returned. When the NOT NULL constraint is set for a given property, an error is returned if no property is given. When the default value for a property is NULL , you can omit to specify the property value. (TODO: create tag doc)","title":"INSERT VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/#examples","text":"nebula> CREATE TAG t1(); -- Create tag t1 with no property nebula> INSERT VERTEX t1() VALUE \"10\":(); -- Insert vertex \"10\" with no property nebula> CREATE TAG t2 (name string, age int); -- Create tag t2 with two properties nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n1\", 12); -- Insert vertex \"11\" with two properties nebula> INSERT VERTEX t2 (name, age) VALUES \"12\":(\"n1\", \"a13\"); -- Failed. \"a13\" is not int nebula> INSERT VERTEX t2 (name, age) VALUES \"13\":(\"n3\", 12), \"14\":(\"n4\", 8); -- Insert two vertices nebula> CREATE TAG t3(p1 int); nebula> CREATE TAG t4(p2 string); nebula> INSERT VERTEX t3 (p1), t4(p2) VALUES \"21\": (321, \"hello\"); -- Insert vertex \"21\" with two tags. A vertex can be inserted/written multiple times. Only the last written values can be read. -- insert vertex \"11\" with the new values. nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n2\", 13); nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n3\", 14); nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n4\", 15); nebula> FETCH PROP ON t2 \"11\"; +----------+---------+--------+ | VertexID | t2.name | t2.age | +----------+---------+--------+ | \"11\" | \"n4\" | 15 | -- Only the last version can be read +----------+---------+--------+ nebula> CREATE TAG t5(p1 fixed_string(5) NOT NULL, p2 int, p3 int DEFAULT NULL); nebula> INSERT VERTEX t5(p1, p2, p3) VALUES \"001\":(\"Abe\", 2, 3); nebula> INSERT VERTEX t5(p1, p2, p3) VALUES \"002\":(NULL, 4, 5); [ERROR (-8)]: Storage Error: The not null field cannot be null. nebula> INSERT VERTEX t5(p1, p2) VALUES \"003\":(\"cd\", 5); nebula> FETCH PROP ON t5 \"003\"; +----------+-------+-------+-------+ | VertexID | t5.p1 | t5.p2 | t5.p3 | +----------+-------+-------+-------+ | \"003\" | \"cd\" | 5 | NULL | -- The value for p3 is the default NULL. +----------+-------+-------+-------+ nebula> INSERT VERTEX t5(p1, p2) VALUES \"004\":(\"shalalalala\", 4); nebula> FETCH PROP on t5 \"004\"; +----------+---------+-------+-------+ | VertexID | t5.p1 | t5.p2 | t5.p3 | +----------+---------+-------+-------+ | \"004\" | \"shala\" | 4 | NULL | -- The allowed maximum length for property p1 is 5. +----------+---------+-------+-------+","title":"Examples"},{"location":"3.ngql-guide/12.vertex-statements/2.update-vertex/","text":"UPDATE VERTEX \u00b6 UPDATE VERTEX <vid> SET <update_columns> [WHEN <condition>] [YIELD <columns>] Use UPDATE VERTEX to update properties on a vertex. The UPDATE VERTEX statement only updates one tag of a vertex at a time. Nebula Graph supports compare-and-set (CAS) operation. NOTE: WHEN and YIELD are optional. vid is the ID of the vertex to be updated. update_columns is the properties of the vertex to be updated. For example, tag1.col1 = $^.tag2.col2 + 1 means to update tag1.col1 to tag2.col2+1 . NOTE: $^ indicates the vertex to be updated. condition is some constraints. Only when the constraints are met, UPDATE is executed successfully. condition supports expression operations. columns is the columns to be returned. YIELD returns the latest updated values. Consider the following example: nebula> UPDATE VERTEX \"player100\" SET player.age = $^.player.age + 1 \\ WHEN $^.player.name == \"Tony Parker\" \\ YIELD $^.player.name AS name, $^.player.age AS age; +-------+-----+ | name | age | +-------+-----+ | \"Tim\" | 42 | +-------+-----+ There is one tag in vertex \"player100\", namely player. nebula> UPDATE VERTEX \"team200\" SET player.name = 'Cory Joseph' WHEN $^.team.name == 'Rocket'; [ERROR (-8)]: Storage Error: Invalid Update col or yield col. UPDATE VERTEX does not support multiple tags, so an error occurs here.","title":"UPDATE VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/2.update-vertex/#update_vertex","text":"UPDATE VERTEX <vid> SET <update_columns> [WHEN <condition>] [YIELD <columns>] Use UPDATE VERTEX to update properties on a vertex. The UPDATE VERTEX statement only updates one tag of a vertex at a time. Nebula Graph supports compare-and-set (CAS) operation. NOTE: WHEN and YIELD are optional. vid is the ID of the vertex to be updated. update_columns is the properties of the vertex to be updated. For example, tag1.col1 = $^.tag2.col2 + 1 means to update tag1.col1 to tag2.col2+1 . NOTE: $^ indicates the vertex to be updated. condition is some constraints. Only when the constraints are met, UPDATE is executed successfully. condition supports expression operations. columns is the columns to be returned. YIELD returns the latest updated values. Consider the following example: nebula> UPDATE VERTEX \"player100\" SET player.age = $^.player.age + 1 \\ WHEN $^.player.name == \"Tony Parker\" \\ YIELD $^.player.name AS name, $^.player.age AS age; +-------+-----+ | name | age | +-------+-----+ | \"Tim\" | 42 | +-------+-----+ There is one tag in vertex \"player100\", namely player. nebula> UPDATE VERTEX \"team200\" SET player.name = 'Cory Joseph' WHEN $^.team.name == 'Rocket'; [ERROR (-8)]: Storage Error: Invalid Update col or yield col. UPDATE VERTEX does not support multiple tags, so an error occurs here.","title":"UPDATE VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/3.upsert-vertex/","text":"UPSERT VERTEX \u00b6 UPSERT VERTEX <vid> SET <update_columns> [WHEN <condition>] [YIELD <columns>] vid is the ID of the vertex to be updated. update_columns is the properties of the vertex to be updated. For example, tag1.col1 = $^.tag2.col2 + 1 means to update tag1.col1 to tag2.col2+1 . NOTE: $^ indicates the vertex to be updated. condition is some constraints. Only when the conditions are met, UPSERT is executed successfully. condition supports expression operations. columns is the columns to be returned, YIELD returns the latest updated values. UPSERT is a combination of UPDATE and INSERT . Use UPSERT VERTEX to update properties on a vertex if it exists or insert a new vertex if it does not exist. The UPDATE VERTEX statement only updates one tag of a vertex at a time. The performance of UPSERT is much lower than that of INSERT , because UPSERT is a read-modify-write serialization operation at the partition level. DON'T: DO NOT use UPSERT for scenarios with highly concurrent writes. If the vertex does not exist, a new vertex is created no matter whether the condition in the WHEN clause is met or not. The property columns not specified by the SET statement use the default values of the columns. If there are no default values, an error is returned. If the vertex exists and the WHEN condition is met, the vertex is updated. If the vertex exists and the WHEN condition is not met, Nebula Graph does nothing. Consider the following example: nebula> INSERT VERTEX player(name, age) VALUES \"player111\":(\"Ben Simmons\", 22); -- Insert a new vertex. nebula> UPSERT VERTEX \"player111\" SET player.name = \"Dwight Howard\", player.age = $^.player.age + 11 WHEN $^.player.name == \"Ben Simmons\" AND $^.player.age > 20 YIELD $^.player.name AS Name, $^.player.age AS Age; -- Do an upsert operation on the vertex. +-----------------+-----+ | Name | Age | +-----------------+-----+ | \"Dwight Howard\" | 33 | +-----------------+-----+ nebula> FETCH PROP ON * \"player123\"; -- An empty set is returned, indicating vertex \"player123\" does not exist. Empty set (Time spent: 3.069/4.382 ms) nebula> UPSERT VERTEX \"player123\" SET player.age = $^.player.age + 1; If the vertex \"player123\" does not exist and the default value of age is NULL , the player.age of vertex \"player123\" is NULL . If player.age has a default value, the player.age of vertex \"player123\" is the default value plus one. nebula> CREATE TAG person(followers int, age int DEFAULT 0); -- Create example tag person nebula> UPSERT VERTEX \"300\" SET person.followers = $^.person.age + 1, person.age = 8; -- the number of followers is 1, age is 8 nebula> UPSERT VERTEX \"300\" SET person.age = 8, person.followers = $^.person.age + 1; -- the number of followers is 9, age is 8","title":"UPSERT VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/3.upsert-vertex/#upsert_vertex","text":"UPSERT VERTEX <vid> SET <update_columns> [WHEN <condition>] [YIELD <columns>] vid is the ID of the vertex to be updated. update_columns is the properties of the vertex to be updated. For example, tag1.col1 = $^.tag2.col2 + 1 means to update tag1.col1 to tag2.col2+1 . NOTE: $^ indicates the vertex to be updated. condition is some constraints. Only when the conditions are met, UPSERT is executed successfully. condition supports expression operations. columns is the columns to be returned, YIELD returns the latest updated values. UPSERT is a combination of UPDATE and INSERT . Use UPSERT VERTEX to update properties on a vertex if it exists or insert a new vertex if it does not exist. The UPDATE VERTEX statement only updates one tag of a vertex at a time. The performance of UPSERT is much lower than that of INSERT , because UPSERT is a read-modify-write serialization operation at the partition level. DON'T: DO NOT use UPSERT for scenarios with highly concurrent writes. If the vertex does not exist, a new vertex is created no matter whether the condition in the WHEN clause is met or not. The property columns not specified by the SET statement use the default values of the columns. If there are no default values, an error is returned. If the vertex exists and the WHEN condition is met, the vertex is updated. If the vertex exists and the WHEN condition is not met, Nebula Graph does nothing. Consider the following example: nebula> INSERT VERTEX player(name, age) VALUES \"player111\":(\"Ben Simmons\", 22); -- Insert a new vertex. nebula> UPSERT VERTEX \"player111\" SET player.name = \"Dwight Howard\", player.age = $^.player.age + 11 WHEN $^.player.name == \"Ben Simmons\" AND $^.player.age > 20 YIELD $^.player.name AS Name, $^.player.age AS Age; -- Do an upsert operation on the vertex. +-----------------+-----+ | Name | Age | +-----------------+-----+ | \"Dwight Howard\" | 33 | +-----------------+-----+ nebula> FETCH PROP ON * \"player123\"; -- An empty set is returned, indicating vertex \"player123\" does not exist. Empty set (Time spent: 3.069/4.382 ms) nebula> UPSERT VERTEX \"player123\" SET player.age = $^.player.age + 1; If the vertex \"player123\" does not exist and the default value of age is NULL , the player.age of vertex \"player123\" is NULL . If player.age has a default value, the player.age of vertex \"player123\" is the default value plus one. nebula> CREATE TAG person(followers int, age int DEFAULT 0); -- Create example tag person nebula> UPSERT VERTEX \"300\" SET person.followers = $^.person.age + 1, person.age = 8; -- the number of followers is 1, age is 8 nebula> UPSERT VERTEX \"300\" SET person.age = 8, person.followers = $^.person.age + 1; -- the number of followers is 9, age is 8","title":"UPSERT VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/","text":"DELETE VERTEX \u00b6 DELETE VERTEX <vid> [, <vid> ...] Use DELETE VERTEX to delete vertices and the related incoming and outgoing edges of the vertices. The DELETE VERTEX statement deletes one vertex or multiple vertices at a time. You can use DELETE VERTEX together with pipe. For more information about pipe, see Pipe operator . Examples \u00b6 nebula> DELETE VERTEX \"team1\"; This query deletes the vertex whose ID is \"team1\". nebula> GO FROM \"player100\" OVER serve YIELD serve._dst AS id | DELETE VERTEX $-.id; This query shows that you can use DELETE VERTEX together with pipe. Nebula Graph traverses the incoming and outgoing edges related to the vertices and deletes them all. Then Nebula Graph deletes information related to the vertices. NOTE: Atomic operation is not guaranteed during the entire process for now, so please retry when a failure occurs.","title":"DELETE VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/#delete_vertex","text":"DELETE VERTEX <vid> [, <vid> ...] Use DELETE VERTEX to delete vertices and the related incoming and outgoing edges of the vertices. The DELETE VERTEX statement deletes one vertex or multiple vertices at a time. You can use DELETE VERTEX together with pipe. For more information about pipe, see Pipe operator .","title":"DELETE VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/#examples","text":"nebula> DELETE VERTEX \"team1\"; This query deletes the vertex whose ID is \"team1\". nebula> GO FROM \"player100\" OVER serve YIELD serve._dst AS id | DELETE VERTEX $-.id; This query shows that you can use DELETE VERTEX together with pipe. Nebula Graph traverses the incoming and outgoing edges related to the vertices and deletes them all. Then Nebula Graph deletes information related to the vertices. NOTE: Atomic operation is not guaranteed during the entire process for now, so please retry when a failure occurs.","title":"Examples"},{"location":"3.ngql-guide/13.edge-statements/1.insert-edge/","text":"INSERT EDGE \u00b6 INSERT EDGE <edge_type> ( <prop_name_list> ) {VALUES | VALUE} <src_vid> -> <dst_vid>[@<rank>] : ( <prop_value_list> ) [, <src_vid> -> <dst_vid>[@<rank>] : ( <prop_value_list> ), ...] <prop_name_list> ::= [ <prop_name> [, <prop_name> ] ...] <prop_value_list> ::= [ <prop_value> [, <prop_value> ] ...] The INSERT EDGE statement inserts an edge from a source vertex (given by src_vid) to a destination vertex (given by dst_vid). <edge_type> denotes the edge type, which must be created before INSERT EDGE . Only one edge type can be specified in this statement. <prop_name_list> is the property name list in the given <edge_type> . <prop_value_list> must provide the value list according to <prop_name_list> . If the property values do not match the data type in the edge type, an error is returned. When the NOT NULL constraint is set for a given property, an error is returned if no property is given. When the default value for a property is NULL , you can omit to specify the property value. (TODO: create edge doc) rank is optional. It specifies the edge rank of the same edge type. If not specified, the default value is 0. You can insert many edges with the same edge type for two vertices by using different rank values. Examples \u00b6 nebula> CREATE EDGE e1(); -- create edge type t1 with empty property nebula> INSERT EDGE e1 () VALUES \"10\"->\"11\":(); -- insert an edge from vertex \"10\" to vertex \"11\" with empty property nebula> INSERT EDGE e1 () VALUES \"10\"->\"11\"@1:(); -- insert an edge from vertex \"10\" to vertex \"11\" with empty property, the edge rank is 1 nebula> CREATE EDGE e2 (name string, age int); -- create edge type e2 with two properties nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 1); -- insert edge from \"11\" to \"13\" with two properties nebula> INSERT EDGE e2 (name, age) VALUES \\ \"12\"->\"13\":(\"n1\", 1), \"13\"->\"14\":(\"n2\", 2); -- insert two edges nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", \"a13\"); -- ERROR. \"a13\" is not int An edge can be inserted/written multiple times. Only the last written values can be read. -- insert edge with the new values. nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 12); nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 13); nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 14); nebula> FETCH PROP ON e2 \"11\"->\"13\"; +---------+---------+----------+---------+--------+ | e2._src | e2._dst | e2._rank | e2.name | e2.age | +---------+---------+----------+---------+--------+ | \"11\" | \"13\" | 0 | \"n1\" | 14 | +---------+---------+----------+---------+--------+ -- Only the last write can be read","title":"INSERT EDGE"},{"location":"3.ngql-guide/13.edge-statements/1.insert-edge/#insert_edge","text":"INSERT EDGE <edge_type> ( <prop_name_list> ) {VALUES | VALUE} <src_vid> -> <dst_vid>[@<rank>] : ( <prop_value_list> ) [, <src_vid> -> <dst_vid>[@<rank>] : ( <prop_value_list> ), ...] <prop_name_list> ::= [ <prop_name> [, <prop_name> ] ...] <prop_value_list> ::= [ <prop_value> [, <prop_value> ] ...] The INSERT EDGE statement inserts an edge from a source vertex (given by src_vid) to a destination vertex (given by dst_vid). <edge_type> denotes the edge type, which must be created before INSERT EDGE . Only one edge type can be specified in this statement. <prop_name_list> is the property name list in the given <edge_type> . <prop_value_list> must provide the value list according to <prop_name_list> . If the property values do not match the data type in the edge type, an error is returned. When the NOT NULL constraint is set for a given property, an error is returned if no property is given. When the default value for a property is NULL , you can omit to specify the property value. (TODO: create edge doc) rank is optional. It specifies the edge rank of the same edge type. If not specified, the default value is 0. You can insert many edges with the same edge type for two vertices by using different rank values.","title":"INSERT EDGE"},{"location":"3.ngql-guide/13.edge-statements/1.insert-edge/#examples","text":"nebula> CREATE EDGE e1(); -- create edge type t1 with empty property nebula> INSERT EDGE e1 () VALUES \"10\"->\"11\":(); -- insert an edge from vertex \"10\" to vertex \"11\" with empty property nebula> INSERT EDGE e1 () VALUES \"10\"->\"11\"@1:(); -- insert an edge from vertex \"10\" to vertex \"11\" with empty property, the edge rank is 1 nebula> CREATE EDGE e2 (name string, age int); -- create edge type e2 with two properties nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 1); -- insert edge from \"11\" to \"13\" with two properties nebula> INSERT EDGE e2 (name, age) VALUES \\ \"12\"->\"13\":(\"n1\", 1), \"13\"->\"14\":(\"n2\", 2); -- insert two edges nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", \"a13\"); -- ERROR. \"a13\" is not int An edge can be inserted/written multiple times. Only the last written values can be read. -- insert edge with the new values. nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 12); nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 13); nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 14); nebula> FETCH PROP ON e2 \"11\"->\"13\"; +---------+---------+----------+---------+--------+ | e2._src | e2._dst | e2._rank | e2.name | e2.age | +---------+---------+----------+---------+--------+ | \"11\" | \"13\" | 0 | \"n1\" | 14 | +---------+---------+----------+---------+--------+ -- Only the last write can be read","title":"Examples"},{"location":"3.ngql-guide/13.edge-statements/2.update-edge/","text":"UPDATE EDGE \u00b6 UPDATE EDGE <src_vid> -> <dest_vid> [@rank] OF <edge_type> SET <update_properties> [WHEN <condition>] [YIELD <properties>] Use UPDATE EDGE to update properties on an edge. The UPDATE EDGE statement only updates one edge at a time. Nebula Graph supports compare-and-set (CAS). NOTE: WHEN and YIELD are optional. update_properties is the properties of the edge to be updated. For example, e1.col1 = $^.e1.col2 + 1 means to update e1.col1 to e1.col2+1 . NOTE: $^ indicates the edge to be updated. condition is some constraints. Only when the condition is met, UPDATE is executed successfully. condition supports expression operations. properties is the properties to be returned, YIELD returns the latest updated values. Consider the following example: nebula> UPDATE EDGE \"100\" -> \"200\"@0 OF serve SET start_year = serve.start_year + 1;","title":"UPDATE EDGE"},{"location":"3.ngql-guide/13.edge-statements/2.update-edge/#update_edge","text":"UPDATE EDGE <src_vid> -> <dest_vid> [@rank] OF <edge_type> SET <update_properties> [WHEN <condition>] [YIELD <properties>] Use UPDATE EDGE to update properties on an edge. The UPDATE EDGE statement only updates one edge at a time. Nebula Graph supports compare-and-set (CAS). NOTE: WHEN and YIELD are optional. update_properties is the properties of the edge to be updated. For example, e1.col1 = $^.e1.col2 + 1 means to update e1.col1 to e1.col2+1 . NOTE: $^ indicates the edge to be updated. condition is some constraints. Only when the condition is met, UPDATE is executed successfully. condition supports expression operations. properties is the properties to be returned, YIELD returns the latest updated values. Consider the following example: nebula> UPDATE EDGE \"100\" -> \"200\"@0 OF serve SET start_year = serve.start_year + 1;","title":"UPDATE EDGE"},{"location":"3.ngql-guide/13.edge-statements/3.upsert-edge/","text":"UPSERT EDGE \u00b6 UPSERT EDGE <src_vid> -> <dst_vid> [@rank] OF <edge_type> SET <update_properties> [WHEN <condition>] [YIELD <properties>] update_properties is the properties of the edge to be updated. For example, e1.col1 = $^.e1.col2 + 1 means to update e1.col1 to e1.col2+1 . NOTE: $^ indicates the edge to be updated. condition is some constraints. Only when the condition is met, UPSERT is executed successfully. condition supports expression operations. properties specifies the properties to be returned, YIELD returns the latest updated values. UPSERT is a combination of UPDATE and INSERT . Use UPSERT EDGE to update properties on an edge if it exists or insert a new edge if it does not exist. The UPDATE EDGE statement updates only one edge at a time. The performance of UPSERT is much lower than that of INSERT , because UPSERT is a read-modify-write serialization operation at the partition level. DON'T: DO NOT use UPSERT for scenarios with highly concurrent writes. If the edge does not exist, a new edge is created no matter whether the condition in the WHEN clause is met or not. The properties not specified by the SET statement use the default property values. If there are no default values, an error is returned. If the edge exists and the WHEN condition is met, the edge is updated. If the edge exists and the WHEN condition is not met, Nebula Graph does nothing. Consider the following example: nebula> INSERT EDGE serve(start_year, end_year) VALUES \"player100\" -> \"team200\":(1997, 2016); -- Insert a new edge. nebula> UPSERT EDGE \"player100\" -> \"team200\" OF serve SET start_year = serve.start_year + 2 WHEN serve.end_year == 2016 YIELD serve.start_year AS Start, serve.end_year AS End; +-------+------+ | Start | End | +-------+------+ | 1999 | 2016 | +-------+------+ nebula> FETCH PROP ON serve \"player100\" -> \"team200\"; +-------------+------------+-------------+------------------+----------------+ | serve._src | serve._dst | serve._rank | serve.start_year | serve.end_year | +-------------+------------+-------------+------------------+----------------+ | \"player100\" | \"team200\" | 0 | 1999 | 2016 | +-------------+------------+-------------+------------------+----------------+","title":"UPSERT EDGE"},{"location":"3.ngql-guide/13.edge-statements/3.upsert-edge/#upsert_edge","text":"UPSERT EDGE <src_vid> -> <dst_vid> [@rank] OF <edge_type> SET <update_properties> [WHEN <condition>] [YIELD <properties>] update_properties is the properties of the edge to be updated. For example, e1.col1 = $^.e1.col2 + 1 means to update e1.col1 to e1.col2+1 . NOTE: $^ indicates the edge to be updated. condition is some constraints. Only when the condition is met, UPSERT is executed successfully. condition supports expression operations. properties specifies the properties to be returned, YIELD returns the latest updated values. UPSERT is a combination of UPDATE and INSERT . Use UPSERT EDGE to update properties on an edge if it exists or insert a new edge if it does not exist. The UPDATE EDGE statement updates only one edge at a time. The performance of UPSERT is much lower than that of INSERT , because UPSERT is a read-modify-write serialization operation at the partition level. DON'T: DO NOT use UPSERT for scenarios with highly concurrent writes. If the edge does not exist, a new edge is created no matter whether the condition in the WHEN clause is met or not. The properties not specified by the SET statement use the default property values. If there are no default values, an error is returned. If the edge exists and the WHEN condition is met, the edge is updated. If the edge exists and the WHEN condition is not met, Nebula Graph does nothing. Consider the following example: nebula> INSERT EDGE serve(start_year, end_year) VALUES \"player100\" -> \"team200\":(1997, 2016); -- Insert a new edge. nebula> UPSERT EDGE \"player100\" -> \"team200\" OF serve SET start_year = serve.start_year + 2 WHEN serve.end_year == 2016 YIELD serve.start_year AS Start, serve.end_year AS End; +-------+------+ | Start | End | +-------+------+ | 1999 | 2016 | +-------+------+ nebula> FETCH PROP ON serve \"player100\" -> \"team200\"; +-------------+------------+-------------+------------------+----------------+ | serve._src | serve._dst | serve._rank | serve.start_year | serve.end_year | +-------------+------------+-------------+------------------+----------------+ | \"player100\" | \"team200\" | 0 | 1999 | 2016 | +-------------+------------+-------------+------------------+----------------+","title":"UPSERT EDGE"},{"location":"3.ngql-guide/13.edge-statements/4.delete-edge/","text":"DELETE EDGE \u00b6 DELETE EDGE <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <edge_type> <src_vid> -> <dst_vid>[@<rank>] ...] Use DELETE EDGE to delete edges. The DELETE EDGE statement deletes one edge or multiple edges at a time. You can use DELETE EDGE together with pipe. For more information about pipe, see Pipe operator . Examples \u00b6 nebula> DELETE EDGE serve \"player100\" -> \"team200\"@0; This query deletes the serve edge from \"player100\" to \"team200\" , of which the rank value is 0. nebula> GO FROM \"player100\" OVER follow WHERE follow._dst == \"team200\" YIELD follow._src AS src, follow._dst AS dst, follow._rank AS rank | \\ DELETE EDGE follow $-.src->$-.dst @ $-.rank; This query shows that you can use DELETE EDGE together with pipe. This query first traverses all the follow edges with different rank values from \"player100\" to \"team200\" then deletes them. To delete all the outgoing edges for a vertex, delete the vertex. For more information, see DELETE VERTEX . NOTE: Atomic operation is not guaranteed during the entire process for now, so please retry when a failure occurs.","title":"DELETE EDGE"},{"location":"3.ngql-guide/13.edge-statements/4.delete-edge/#delete_edge","text":"DELETE EDGE <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <edge_type> <src_vid> -> <dst_vid>[@<rank>] ...] Use DELETE EDGE to delete edges. The DELETE EDGE statement deletes one edge or multiple edges at a time. You can use DELETE EDGE together with pipe. For more information about pipe, see Pipe operator .","title":"DELETE EDGE"},{"location":"3.ngql-guide/13.edge-statements/4.delete-edge/#examples","text":"nebula> DELETE EDGE serve \"player100\" -> \"team200\"@0; This query deletes the serve edge from \"player100\" to \"team200\" , of which the rank value is 0. nebula> GO FROM \"player100\" OVER follow WHERE follow._dst == \"team200\" YIELD follow._src AS src, follow._dst AS dst, follow._rank AS rank | \\ DELETE EDGE follow $-.src->$-.dst @ $-.rank; This query shows that you can use DELETE EDGE together with pipe. This query first traverses all the follow edges with different rank values from \"player100\" to \"team200\" then deletes them. To delete all the outgoing edges for a vertex, delete the vertex. For more information, see DELETE VERTEX . NOTE: Atomic operation is not guaranteed during the entire process for now, so please retry when a failure occurs.","title":"Examples"},{"location":"3.ngql-guide/14.index-statements/","text":"Index overview \u00b6 Indexes are built to fast process graph queries. Nebula Graph supports two kinds of indexes: native indexes and full-text indexes. This topic introduces the index types and helps choose the right index. Native indexes \u00b6 Native indexes allow querying data based on a given property. There are two kinds of native indexes: tag index and edge type index. Native indexes must be updated manually. You can use the REBUILD INDEX statement to update native indexes. Native indexes support indexing multiple properties on a tag or an edge type (composite indexes), but do not support indexing across multiple tags or edge types. You can do partial match search by using composite indexes. Use composite indexes only for partial match searches when the declared fields in the composite index are used from left to right. For more information, see LOOKUP FAQ . String operators like CONTAINS and STARTS WITH are not allowed in native index searching. Use full-text indexes to do fuzzy search. Operations on native indexes \u00b6 You can do the following operations against native indexes: Create index Show index Describe index Rebuild index Show index status Drop index Query index Full-text indexes \u00b6 Full-text indexes are used to do prefix, wildcard, regexp, and fuzzy search on a string property. Full-text indexes allow indexing just one property. Only strings within a specified length (no longer than 256 bytes) are indexed. Full-text indexes do not support logical operations such as AND , OR and NOT . To do complete text match, use native indexes. Operations on full-text indexes \u00b6 Before doing any operations on full-text indexes, please mak sure that you deploy full-text indexes. Details on full-text indexes deployment, see Deploy full-text index . At this time, full-text indexes are created automatically on the Elasticsearch cluster. And rebuilding or altering full-text indexes are not supported. To drop full-text indexes, you need to drop them on the Elasticsearch cluster manually. To query full-text indexes, see Search with full-text indexes . Null values \u00b6 Indexes do not support indexing null values at this time. Range queries \u00b6 In addition to querying single results from native indexes, you can also do range queries. Not all the native indexes support range queries. You can only do range search for numeric, date, and time type properties.","title":"Index overview"},{"location":"3.ngql-guide/14.index-statements/#index_overview","text":"Indexes are built to fast process graph queries. Nebula Graph supports two kinds of indexes: native indexes and full-text indexes. This topic introduces the index types and helps choose the right index.","title":"Index overview"},{"location":"3.ngql-guide/14.index-statements/#native_indexes","text":"Native indexes allow querying data based on a given property. There are two kinds of native indexes: tag index and edge type index. Native indexes must be updated manually. You can use the REBUILD INDEX statement to update native indexes. Native indexes support indexing multiple properties on a tag or an edge type (composite indexes), but do not support indexing across multiple tags or edge types. You can do partial match search by using composite indexes. Use composite indexes only for partial match searches when the declared fields in the composite index are used from left to right. For more information, see LOOKUP FAQ . String operators like CONTAINS and STARTS WITH are not allowed in native index searching. Use full-text indexes to do fuzzy search.","title":"Native indexes"},{"location":"3.ngql-guide/14.index-statements/#operations_on_native_indexes","text":"You can do the following operations against native indexes: Create index Show index Describe index Rebuild index Show index status Drop index Query index","title":"Operations on native indexes"},{"location":"3.ngql-guide/14.index-statements/#full-text_indexes","text":"Full-text indexes are used to do prefix, wildcard, regexp, and fuzzy search on a string property. Full-text indexes allow indexing just one property. Only strings within a specified length (no longer than 256 bytes) are indexed. Full-text indexes do not support logical operations such as AND , OR and NOT . To do complete text match, use native indexes.","title":"Full-text indexes"},{"location":"3.ngql-guide/14.index-statements/#operations_on_full-text_indexes","text":"Before doing any operations on full-text indexes, please mak sure that you deploy full-text indexes. Details on full-text indexes deployment, see Deploy full-text index . At this time, full-text indexes are created automatically on the Elasticsearch cluster. And rebuilding or altering full-text indexes are not supported. To drop full-text indexes, you need to drop them on the Elasticsearch cluster manually. To query full-text indexes, see Search with full-text indexes .","title":"Operations on full-text indexes"},{"location":"3.ngql-guide/14.index-statements/#null_values","text":"Indexes do not support indexing null values at this time.","title":"Null values"},{"location":"3.ngql-guide/14.index-statements/#range_queries","text":"In addition to querying single results from native indexes, you can also do range queries. Not all the native indexes support range queries. You can only do range search for numeric, date, and time type properties.","title":"Range queries"},{"location":"3.ngql-guide/14.index-statements/1.create-native-index/","text":"CREATE INDEX \u00b6 Use CREATE INDEX to add native indexes for existing tags, edge types or properties. NOTE: For how to create text-based indexes, see CREATE FULLTEXT INDEX (doc TODO). Most graph queries start the traversal from a list of vertices or edges that are identified by their properties. Indexes make these global retrieval operations efficient on large graphs. Prerequisites \u00b6 Before you create an index, make sure that the relative tag or edge type is created. For how to create tags or edge types, see CREATE EDGE (doc TODO) and CREATE EDGE (doc TODO). Must-read for using index \u00b6 Correct use of indexes can speed up queries, but indexes also decrease the write performance. DO NOT use indexes in production environments unless you are fully aware of their influences on your service. If you must use indexes, we suggest that you: Import data into Nebula Graph. Create indexes. Rebuild the indexes. The preceding workflow minimizes the negative influences of using indexes. Syntax \u00b6 CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] <index_name> ON {<tag_name> | <edge_name>} ([prop_name_list]) IF NOT EXISTS : - Creating an existent index results in an error. You can use the IF NOT EXISTS option to conditionally create the index and avoid the error. prop_name_list : To index a variable string property, you must use the prop_name(length) syntax to specify an index prefix length. To index a fixed-length string property, you must use the prop_name syntax, and the string length is read from the property. To index a tag or an edge type, omit the prop_name_list in the parentheses. Create tag/edge type indexes \u00b6 The following statement creates an index on the player tag. nebula> CREATE TAG INDEX player_index on player(); The following statement creates indexes on the edge type like . nebula> CREATE EDGE INDEX like_index on like(); After indexing a tag or an edge type, you can use the LOOKUP statement to retrieve the VID of all vertices with the tag, or the source vertex ID, destination vertex ID, and ranks of all edges with the edge type. For more information, see List vertices or edges with a tag or an edge type . Create single-property indexes \u00b6 nebula> CREATE TAG INDEX player_index_0 on player(name(10)); The preceding statement creates an index for the name property on all vertices carrying the player tag. This statement creates an index using the first 10 characters of the name property. nebula> CREATE TAG var_string(p1 string); nebula> CREATE TAG INDEX var ON var_string(p1(10)); nebula> CREATE TAG fix_string(p1 FIXED_STRING(10)); nebula> CREATE TAG INDEX fix ON fix_string(p1); nebula> CREATE EDGE INDEX follow_index_0 on follow(degree); The preceding statement creates an index for the degree property on all edges carrying the follow edge type. Create composite property indexes \u00b6 An index on multiple properties is called a composite index. NOTE : Creating index across multiple tags is not supported. Consider the following example: nebula> CREATE TAG INDEX player_index_1 on player(name(10), age); This statement creates a composite index for the name and age property on all vertices carrying the player tag. Using index \u00b6 After the index is created and data is inserted, you can use the LOOKUP statement to query the data. You do not need to specify which indexes to use in a query, Nebula Graph figures that out by itself.","title":"CREATE INDEX"},{"location":"3.ngql-guide/14.index-statements/1.create-native-index/#create_index","text":"Use CREATE INDEX to add native indexes for existing tags, edge types or properties. NOTE: For how to create text-based indexes, see CREATE FULLTEXT INDEX (doc TODO). Most graph queries start the traversal from a list of vertices or edges that are identified by their properties. Indexes make these global retrieval operations efficient on large graphs.","title":"CREATE INDEX"},{"location":"3.ngql-guide/14.index-statements/1.create-native-index/#prerequisites","text":"Before you create an index, make sure that the relative tag or edge type is created. For how to create tags or edge types, see CREATE EDGE (doc TODO) and CREATE EDGE (doc TODO).","title":"Prerequisites"},{"location":"3.ngql-guide/14.index-statements/1.create-native-index/#must-read_for_using_index","text":"Correct use of indexes can speed up queries, but indexes also decrease the write performance. DO NOT use indexes in production environments unless you are fully aware of their influences on your service. If you must use indexes, we suggest that you: Import data into Nebula Graph. Create indexes. Rebuild the indexes. The preceding workflow minimizes the negative influences of using indexes.","title":"Must-read for using index"},{"location":"3.ngql-guide/14.index-statements/1.create-native-index/#syntax","text":"CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] <index_name> ON {<tag_name> | <edge_name>} ([prop_name_list]) IF NOT EXISTS : - Creating an existent index results in an error. You can use the IF NOT EXISTS option to conditionally create the index and avoid the error. prop_name_list : To index a variable string property, you must use the prop_name(length) syntax to specify an index prefix length. To index a fixed-length string property, you must use the prop_name syntax, and the string length is read from the property. To index a tag or an edge type, omit the prop_name_list in the parentheses.","title":"Syntax"},{"location":"3.ngql-guide/14.index-statements/1.create-native-index/#create_tagedge_type_indexes","text":"The following statement creates an index on the player tag. nebula> CREATE TAG INDEX player_index on player(); The following statement creates indexes on the edge type like . nebula> CREATE EDGE INDEX like_index on like(); After indexing a tag or an edge type, you can use the LOOKUP statement to retrieve the VID of all vertices with the tag, or the source vertex ID, destination vertex ID, and ranks of all edges with the edge type. For more information, see List vertices or edges with a tag or an edge type .","title":"Create tag/edge type indexes"},{"location":"3.ngql-guide/14.index-statements/1.create-native-index/#create_single-property_indexes","text":"nebula> CREATE TAG INDEX player_index_0 on player(name(10)); The preceding statement creates an index for the name property on all vertices carrying the player tag. This statement creates an index using the first 10 characters of the name property. nebula> CREATE TAG var_string(p1 string); nebula> CREATE TAG INDEX var ON var_string(p1(10)); nebula> CREATE TAG fix_string(p1 FIXED_STRING(10)); nebula> CREATE TAG INDEX fix ON fix_string(p1); nebula> CREATE EDGE INDEX follow_index_0 on follow(degree); The preceding statement creates an index for the degree property on all edges carrying the follow edge type.","title":"Create single-property indexes"},{"location":"3.ngql-guide/14.index-statements/1.create-native-index/#create_composite_property_indexes","text":"An index on multiple properties is called a composite index. NOTE : Creating index across multiple tags is not supported. Consider the following example: nebula> CREATE TAG INDEX player_index_1 on player(name(10), age); This statement creates a composite index for the name and age property on all vertices carrying the player tag.","title":"Create composite property indexes"},{"location":"3.ngql-guide/14.index-statements/1.create-native-index/#using_index","text":"After the index is created and data is inserted, you can use the LOOKUP statement to query the data. You do not need to specify which indexes to use in a query, Nebula Graph figures that out by itself.","title":"Using index"},{"location":"3.ngql-guide/14.index-statements/2.show-native-indexes/","text":"Show INDEXES \u00b6 SHOW {TAG | EDGE} INDEXES Use SHOW INDEXES to list the defined tag or edg-type indexes names. Example \u00b6 nebula> SHOW TAG INDEXES; +------------------+ | Names | +------------------+ | \"fix\" | +------------------+ | \"player_index_0\" | +------------------+ | \"player_index_1\" | +------------------+ | \"var\" | +------------------+ nebula> SHOW EDGE INDEXES; +------------------+ | Names | +------------------+ | \"follow_index_0\" | +------------------+","title":"SHOW INDEX"},{"location":"3.ngql-guide/14.index-statements/2.show-native-indexes/#show_indexes","text":"SHOW {TAG | EDGE} INDEXES Use SHOW INDEXES to list the defined tag or edg-type indexes names.","title":"Show INDEXES"},{"location":"3.ngql-guide/14.index-statements/2.show-native-indexes/#example","text":"nebula> SHOW TAG INDEXES; +------------------+ | Names | +------------------+ | \"fix\" | +------------------+ | \"player_index_0\" | +------------------+ | \"player_index_1\" | +------------------+ | \"var\" | +------------------+ nebula> SHOW EDGE INDEXES; +------------------+ | Names | +------------------+ | \"follow_index_0\" | +------------------+","title":"Example"},{"location":"3.ngql-guide/14.index-statements/3.describe-native-index/","text":"DESCRIBE INDEX \u00b6 DESCRIBE {TAG | EDGE} INDEX <index_name> Use DESCRIBE INDEX to get information about the index. DESCRIBE INDEX returns the following columns: Field The property name. - Type The property type. Example \u00b6 nebula> DESCRIBE TAG INDEX player_index_0; +--------+--------------------+ | Field | Type | +--------+--------------------+ | \"name\" | \"fixed_string(30)\" | +--------+--------------------+ nebula> DESCRIBE TAG INDEX player_index_1; +--------+--------------------+ | Field | Type | +--------+--------------------+ | \"name\" | \"fixed_string(10)\" | +--------+--------------------+ | \"age\" | \"int64\" | +--------+--------------------+","title":"DESCRIBE INDEX"},{"location":"3.ngql-guide/14.index-statements/3.describe-native-index/#describe_index","text":"DESCRIBE {TAG | EDGE} INDEX <index_name> Use DESCRIBE INDEX to get information about the index. DESCRIBE INDEX returns the following columns: Field The property name. - Type The property type.","title":"DESCRIBE INDEX"},{"location":"3.ngql-guide/14.index-statements/3.describe-native-index/#example","text":"nebula> DESCRIBE TAG INDEX player_index_0; +--------+--------------------+ | Field | Type | +--------+--------------------+ | \"name\" | \"fixed_string(30)\" | +--------+--------------------+ nebula> DESCRIBE TAG INDEX player_index_1; +--------+--------------------+ | Field | Type | +--------+--------------------+ | \"name\" | \"fixed_string(10)\" | +--------+--------------------+ | \"age\" | \"int64\" | +--------+--------------------+","title":"Example"},{"location":"3.ngql-guide/14.index-statements/4.rebuild-native-index/","text":"REBUILD INDEX \u00b6 REBUILD {TAG | EDGE} INDEX <index_name> Use REBUILD INDEX to rebuild the created tag or edg-type index. For details on how to create index, see CREATE INDEX . If the index is created before data insertion, there is no need to rebuild the index. If data is updated or newly inserted before the index creation, you need to rebuild the indexes in order to make sure that the indexes contain the previously added data. NOTE: During the rebuilding, all queries skip the index and perform sequential scans. This means that the return results can be different because the not all the data is indexed during rebuilding. After rebuilding is complete, you can use the SHOW {TAG | EDGE} INDEX STATUS command to check if the index is successfully rebuilt. For details on index status, see SHOW INDEX STATUS . Example \u00b6 nebula> CREATE TAG person(name string, age int, gender string, email string); Execution succeeded (Time spent: 10.051/11.397 ms) nebula> CREATE TAG INDEX single_person_index ON person(name(10)); Execution succeeded (Time spent: 2.168/3.379 ms) nebula> REBUILD TAG INDEX single_person_index; +------------+ | New Job Id | +------------+ | 66 | +------------+ nebula> SHOW TAG INDEX STATUS; Nebula Graph creates a job to rebuild the index. The job ID is displayed in the preceding return message. To check if the rebuilding process is complete, use the SHOW JOB <job_id> statement. For more information, see SHOW JOB . TODO: update SHOW TAG INDEX STATUS . Code not ready.","title":"REBUILD INDEX"},{"location":"3.ngql-guide/14.index-statements/4.rebuild-native-index/#rebuild_index","text":"REBUILD {TAG | EDGE} INDEX <index_name> Use REBUILD INDEX to rebuild the created tag or edg-type index. For details on how to create index, see CREATE INDEX . If the index is created before data insertion, there is no need to rebuild the index. If data is updated or newly inserted before the index creation, you need to rebuild the indexes in order to make sure that the indexes contain the previously added data. NOTE: During the rebuilding, all queries skip the index and perform sequential scans. This means that the return results can be different because the not all the data is indexed during rebuilding. After rebuilding is complete, you can use the SHOW {TAG | EDGE} INDEX STATUS command to check if the index is successfully rebuilt. For details on index status, see SHOW INDEX STATUS .","title":"REBUILD INDEX"},{"location":"3.ngql-guide/14.index-statements/4.rebuild-native-index/#example","text":"nebula> CREATE TAG person(name string, age int, gender string, email string); Execution succeeded (Time spent: 10.051/11.397 ms) nebula> CREATE TAG INDEX single_person_index ON person(name(10)); Execution succeeded (Time spent: 2.168/3.379 ms) nebula> REBUILD TAG INDEX single_person_index; +------------+ | New Job Id | +------------+ | 66 | +------------+ nebula> SHOW TAG INDEX STATUS; Nebula Graph creates a job to rebuild the index. The job ID is displayed in the preceding return message. To check if the rebuilding process is complete, use the SHOW JOB <job_id> statement. For more information, see SHOW JOB . TODO: update SHOW TAG INDEX STATUS . Code not ready.","title":"Example"},{"location":"3.ngql-guide/14.index-statements/5.show-native-index-status/","text":"SHOW INDEX STATUS \u00b6 SHOW {TAG | EDGE} INDEX STATUS SHOW INDEX STATUS returns the created tag/edg-type index status. For details on how to create index, see CREATE INDEX . SHOW INDEX STATUS returns the following fields: Name The index name. Index Status Index Status includes QUEUE , RUNNING , FINISHED , FAILED , STOPPED , INVALID . Example \u00b6 nebula> SHOW TAG INDEX STATUS; +----------------------+--------------+ | Name | Index Status | +----------------------+--------------+ | \"player_index_0\" | \"FINISHED\" | +----------------------+--------------+ | \"player_index_1\" | \"FINISHED\" | +----------------------+--------------+","title":"SHOW INDEX STATUS"},{"location":"3.ngql-guide/14.index-statements/5.show-native-index-status/#show_index_status","text":"SHOW {TAG | EDGE} INDEX STATUS SHOW INDEX STATUS returns the created tag/edg-type index status. For details on how to create index, see CREATE INDEX . SHOW INDEX STATUS returns the following fields: Name The index name. Index Status Index Status includes QUEUE , RUNNING , FINISHED , FAILED , STOPPED , INVALID .","title":"SHOW INDEX STATUS"},{"location":"3.ngql-guide/14.index-statements/5.show-native-index-status/#example","text":"nebula> SHOW TAG INDEX STATUS; +----------------------+--------------+ | Name | Index Status | +----------------------+--------------+ | \"player_index_0\" | \"FINISHED\" | +----------------------+--------------+ | \"player_index_1\" | \"FINISHED\" | +----------------------+--------------+","title":"Example"},{"location":"3.ngql-guide/14.index-statements/6.drop-native-index/","text":"DROP INDEX \u00b6 DROP {TAG | EDGE} INDEX [IF EXISTS] <index_name> The DROP INDEX statement removes an existing index from the current graph space. Removing a nonexistent index results in an error. You can use the IF EXISTS option to conditionally drop the index and avoid the error. To run this statement you need some privilege. For information about the built-in roles in Nebula Graph, see Built-in roles (TODO). Example \u00b6 nebula> DROP TAG INDEX player_index_0; This query drops a tag index names player_index_0 .","title":"DROP INDEX"},{"location":"3.ngql-guide/14.index-statements/6.drop-native-index/#drop_index","text":"DROP {TAG | EDGE} INDEX [IF EXISTS] <index_name> The DROP INDEX statement removes an existing index from the current graph space. Removing a nonexistent index results in an error. You can use the IF EXISTS option to conditionally drop the index and avoid the error. To run this statement you need some privilege. For information about the built-in roles in Nebula Graph, see Built-in roles (TODO).","title":"DROP INDEX"},{"location":"3.ngql-guide/14.index-statements/6.drop-native-index/#example","text":"nebula> DROP TAG INDEX player_index_0; This query drops a tag index names player_index_0 .","title":"Example"},{"location":"3.ngql-guide/14.index-statements/7.search-with-text-based-index/","text":"Full-text search \u00b6 LOOKUP ON {<tag> | <edge_type>} WHERE <expression> [YIELD <return_list>] <expression> ::= PREFIX | WILDCARD | REGEXP | FUZZY <return_list> <prop_name> [AS <prop_alias>] [, <prop_name> [AS <prop_alias>] ...] PREFIX(schema_name.prop_name, prefix_string, row_limit, timeout) WILDCARD(schema_name.prop_name, wildcard_string, row_limit, timeout) REGEXP(schema_name.prop_name, regexp_string, row_limit, timeout) FUZZY(schema_name.prop_name, fuzzy_string, fuzziness, operator, row_limit, timeout) fuzziness (optional): Maximum edit distance allowed for matching. The default value is AUTO . For other valid values and more information, see Elasticsearch document . operator (optional): Boolean logic used to interpret text. Valid values are OR (default) and AND . row_limit (optional): Specifies the number of rows to return. The default value is 100. timeout (optional): Specifies the timeout time. The default value is 200ms. Use the LOOKUP ON statement to do full-text search. The search string is specified in the WHERE clause. Before doing a full-text search, make sure that you deployed a Elasticsearch cluster and a Listener cluster. For more information, see Deploy full-text index . Natural language full-text search \u00b6 A natural language search interprets the search string as a phrase in natural human language. The search is case-insensitive. Examples \u00b6 nebula> CREATE SPACE nba (partition_num=3,replica_factor=1, vid_type=fixed_string(30)); nebula> SIGN IN TEXT SERVICE (127.0.0.1:9200); nebula> USE nba; nebula> ADD LISTENER ELASTICSEARCH 192.168.8.5:46780; nebula> CREATE TAG player(name string, age int); nebula> CREATE TAG INDEX name ON player(name(20)); nebula> INSERT VERTEX player(name, age) VALUES \\ \"Russell Westbrook\": (\"Russell Westbrook\", 30), \\ \"Chris Paul\": (\"Chris Paul\", 33),\\ \"Boris Diaw\": (\"Boris Diaw\", 36),\\ \"David West\": (\"David West\", 38),\\ \"Danny Green\": (\"Danny Green\", 31),\\ \"Tim Duncan\": (\"Tim Duncan\", 42),\\ \"James Harden\": (\"James Harden\", 29),\\ \"Tony Parker\": (\"Tony Parker\", 36),\\ \"Aron Baynes\": (\"Aron Baynes\", 32),\\ \"Ben Simmons\": (\"Ben Simmons\", 22),\\ \"Blake Griffin\": (\"Blake Griffin\", 30); nebula> LOOKUP ON player WHERE PREFIX(player.name, \"B\"); +-----------------+ | _vid | +-----------------+ | \"Boris Diaw\" | +-----------------+ | \"Ben Simmons\" | +-----------------+ | \"Blake Griffin\" | +-----------------+ nebula> LOOKUP ON player WHERE WILDCARD(player.name, \"*ri*\") YIELD player.name, player.age; +-----------------+-----------------+-----+ | _vid | name | age | +-----------------+-----------------+-----+ | \"Chris Paul\" | \"Chris Paul\" | 33 | +-----------------+-----------------+-----+ | \"Boris Diaw\" | \"Boris Diaw\" | 36 | +-----------------+-----------------+-----+ | \"Blake Griffin\" | \"Blake Griffin\" | 30 | +-----------------+-----------------+-----+ nebula> LOOKUP ON player WHERE WILDCARD(player.name, \"*ri*\") | YIELD count(*); +----------+ | COUNT(*) | +----------+ | 3 | +----------+ nebula> LOOKUP ON player WHERE REGEXP(player.name, \"R.*\") YIELD player.name, player.age; +---------------------+---------------------+-----+ | _vid | name | age | +---------------------+---------------------+-----+ | \"Russell Westbrook\" | \"Russell Westbrook\" | 30 | +---------------------+---------------------+-----+ nebula> LOOKUP ON player WHERE REGEXP(player.name, \".*\"); +---------------------+ | _vid | +---------------------+ | \"Danny Green\" | +---------------------+ | \"David West\" | +---------------------+ | \"Russell Westbrook\" | +---------------------+ ... nebula> LOOKUP ON player WHERE FUZZY(player.name, \"Tim Dunncan\", AUTO, OR) YIELD player.name; +--------------+--------------+ | _vid | name | +--------------+--------------+ | \"Tim Duncan\" | \"Tim Duncan\" | +--------------+--------------+","title":"Search with full-text index"},{"location":"3.ngql-guide/14.index-statements/7.search-with-text-based-index/#full-text_search","text":"LOOKUP ON {<tag> | <edge_type>} WHERE <expression> [YIELD <return_list>] <expression> ::= PREFIX | WILDCARD | REGEXP | FUZZY <return_list> <prop_name> [AS <prop_alias>] [, <prop_name> [AS <prop_alias>] ...] PREFIX(schema_name.prop_name, prefix_string, row_limit, timeout) WILDCARD(schema_name.prop_name, wildcard_string, row_limit, timeout) REGEXP(schema_name.prop_name, regexp_string, row_limit, timeout) FUZZY(schema_name.prop_name, fuzzy_string, fuzziness, operator, row_limit, timeout) fuzziness (optional): Maximum edit distance allowed for matching. The default value is AUTO . For other valid values and more information, see Elasticsearch document . operator (optional): Boolean logic used to interpret text. Valid values are OR (default) and AND . row_limit (optional): Specifies the number of rows to return. The default value is 100. timeout (optional): Specifies the timeout time. The default value is 200ms. Use the LOOKUP ON statement to do full-text search. The search string is specified in the WHERE clause. Before doing a full-text search, make sure that you deployed a Elasticsearch cluster and a Listener cluster. For more information, see Deploy full-text index .","title":"Full-text search"},{"location":"3.ngql-guide/14.index-statements/7.search-with-text-based-index/#natural_language_full-text_search","text":"A natural language search interprets the search string as a phrase in natural human language. The search is case-insensitive.","title":"Natural language full-text search"},{"location":"3.ngql-guide/14.index-statements/7.search-with-text-based-index/#examples","text":"nebula> CREATE SPACE nba (partition_num=3,replica_factor=1, vid_type=fixed_string(30)); nebula> SIGN IN TEXT SERVICE (127.0.0.1:9200); nebula> USE nba; nebula> ADD LISTENER ELASTICSEARCH 192.168.8.5:46780; nebula> CREATE TAG player(name string, age int); nebula> CREATE TAG INDEX name ON player(name(20)); nebula> INSERT VERTEX player(name, age) VALUES \\ \"Russell Westbrook\": (\"Russell Westbrook\", 30), \\ \"Chris Paul\": (\"Chris Paul\", 33),\\ \"Boris Diaw\": (\"Boris Diaw\", 36),\\ \"David West\": (\"David West\", 38),\\ \"Danny Green\": (\"Danny Green\", 31),\\ \"Tim Duncan\": (\"Tim Duncan\", 42),\\ \"James Harden\": (\"James Harden\", 29),\\ \"Tony Parker\": (\"Tony Parker\", 36),\\ \"Aron Baynes\": (\"Aron Baynes\", 32),\\ \"Ben Simmons\": (\"Ben Simmons\", 22),\\ \"Blake Griffin\": (\"Blake Griffin\", 30); nebula> LOOKUP ON player WHERE PREFIX(player.name, \"B\"); +-----------------+ | _vid | +-----------------+ | \"Boris Diaw\" | +-----------------+ | \"Ben Simmons\" | +-----------------+ | \"Blake Griffin\" | +-----------------+ nebula> LOOKUP ON player WHERE WILDCARD(player.name, \"*ri*\") YIELD player.name, player.age; +-----------------+-----------------+-----+ | _vid | name | age | +-----------------+-----------------+-----+ | \"Chris Paul\" | \"Chris Paul\" | 33 | +-----------------+-----------------+-----+ | \"Boris Diaw\" | \"Boris Diaw\" | 36 | +-----------------+-----------------+-----+ | \"Blake Griffin\" | \"Blake Griffin\" | 30 | +-----------------+-----------------+-----+ nebula> LOOKUP ON player WHERE WILDCARD(player.name, \"*ri*\") | YIELD count(*); +----------+ | COUNT(*) | +----------+ | 3 | +----------+ nebula> LOOKUP ON player WHERE REGEXP(player.name, \"R.*\") YIELD player.name, player.age; +---------------------+---------------------+-----+ | _vid | name | age | +---------------------+---------------------+-----+ | \"Russell Westbrook\" | \"Russell Westbrook\" | 30 | +---------------------+---------------------+-----+ nebula> LOOKUP ON player WHERE REGEXP(player.name, \".*\"); +---------------------+ | _vid | +---------------------+ | \"Danny Green\" | +---------------------+ | \"David West\" | +---------------------+ | \"Russell Westbrook\" | +---------------------+ ... nebula> LOOKUP ON player WHERE FUZZY(player.name, \"Tim Dunncan\", AUTO, OR) YIELD player.name; +--------------+--------------+ | _vid | name | +--------------+--------------+ | \"Tim Duncan\" | \"Tim Duncan\" | +--------------+--------------+","title":"Examples"},{"location":"3.ngql-guide/16.subgraph-and-path/1.get-subgraph/","text":"GET SUBGRAPH \u00b6 The GET SUBGRAPH statement retrieves information of vertices and edges reachable from the start vertices over the specified types of edges. Syntax \u00b6 GET SUBGRAPH [<step_count> STEPS] FROM {<vid>, <vid>...} [IN <edge_type>, <edge_type>...] [OUT <edge_type>, <edge_type>...] [BOTH <edge_type>, <edge_type>...] Clause Description STEPS Specifies the steps to go from the start vertices. A step_count must be a non-negative integer. Its default value is 1. When <step_count> is specified to N , the Nebula Graph returns zero to N steps subgraph. FROM Specifies the start vertices. IN Gets the subgraphs from the start vertices over the specified incoming edges (edges pointing to the start vertices). OUT Gets the subgraphs from the start vertices over the specified outgoing edges (edges pointing out from the start vertices). BOTH Gets the subgraphs from the start vertices over the specified types of edges, both incoming and outgoing. When the traversal direction is not specified, both the incoming and outgoing edges are returned. Examples \u00b6 The following graph is used as the sample. Go one step from the vertex with VID \"player100\" over all types of edges and get the subgraph. nebula> GET SUBGRAPH 1 STEPS FROM \"player100\"; +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | _vertices | _edges | +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | [(player100) player.name:Tim,player.age:42] | [player100-[follow]->player101@0 degree:96,player100-[follow]->player102@0 degree:90,player100-[serve]->team200@0 end_year:2016,start_year:1997] | +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | [(player101) player.age:36,player.name:Tony Parker,(player102) player.age:33,player.name:LaMarcus Aldridge,(team200) team.name:Warriors] | [player102-[follow]->player101@0 degree:75] | +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ Got 2 rows (time spent 6289/7423 us) The returned subgraph is as follows. Go one step from the vertex with VID \"player100\" over incoming follow edges and get the subgraph. nebula> GET SUBGRAPH 1 STEPS FROM \"player100\" IN follow; +-----------+--------+ | _vertices | _edges | +-----------+--------+ | [] | [] | +-----------+--------+ | [] | [] | +-----------+--------+ Got 2 rows (time spent 2292/3091 us) There is no incoming follow edge to \"player100\", so no vertex or edge is returned. Go one step from the vertex \"player100\" over outgoing serve edges and get the subgraph. nebula> GET SUBGRAPH 1 STEPS FROM \"player100\" OUT serve; +---------------------------------------------+--------------------------------------------------------------+ | _vertices | _edges | +---------------------------------------------+--------------------------------------------------------------+ | [(player100) player.age:42,player.name:Tim] | [player100-[serve]->team200@0 start_year:1997,end_year:2016] | +---------------------------------------------+--------------------------------------------------------------+ | [(team200) team.name:Warriors] | [] | +---------------------------------------------+--------------------------------------------------------------+ Got 2 rows (time spent 2107/2547 us) The returned subgraph is as follows.","title":"GET SUBGRAPH"},{"location":"3.ngql-guide/16.subgraph-and-path/1.get-subgraph/#get_subgraph","text":"The GET SUBGRAPH statement retrieves information of vertices and edges reachable from the start vertices over the specified types of edges.","title":"GET SUBGRAPH"},{"location":"3.ngql-guide/16.subgraph-and-path/1.get-subgraph/#syntax","text":"GET SUBGRAPH [<step_count> STEPS] FROM {<vid>, <vid>...} [IN <edge_type>, <edge_type>...] [OUT <edge_type>, <edge_type>...] [BOTH <edge_type>, <edge_type>...] Clause Description STEPS Specifies the steps to go from the start vertices. A step_count must be a non-negative integer. Its default value is 1. When <step_count> is specified to N , the Nebula Graph returns zero to N steps subgraph. FROM Specifies the start vertices. IN Gets the subgraphs from the start vertices over the specified incoming edges (edges pointing to the start vertices). OUT Gets the subgraphs from the start vertices over the specified outgoing edges (edges pointing out from the start vertices). BOTH Gets the subgraphs from the start vertices over the specified types of edges, both incoming and outgoing. When the traversal direction is not specified, both the incoming and outgoing edges are returned.","title":"Syntax"},{"location":"3.ngql-guide/16.subgraph-and-path/1.get-subgraph/#examples","text":"The following graph is used as the sample. Go one step from the vertex with VID \"player100\" over all types of edges and get the subgraph. nebula> GET SUBGRAPH 1 STEPS FROM \"player100\"; +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | _vertices | _edges | +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | [(player100) player.name:Tim,player.age:42] | [player100-[follow]->player101@0 degree:96,player100-[follow]->player102@0 degree:90,player100-[serve]->team200@0 end_year:2016,start_year:1997] | +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | [(player101) player.age:36,player.name:Tony Parker,(player102) player.age:33,player.name:LaMarcus Aldridge,(team200) team.name:Warriors] | [player102-[follow]->player101@0 degree:75] | +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ Got 2 rows (time spent 6289/7423 us) The returned subgraph is as follows. Go one step from the vertex with VID \"player100\" over incoming follow edges and get the subgraph. nebula> GET SUBGRAPH 1 STEPS FROM \"player100\" IN follow; +-----------+--------+ | _vertices | _edges | +-----------+--------+ | [] | [] | +-----------+--------+ | [] | [] | +-----------+--------+ Got 2 rows (time spent 2292/3091 us) There is no incoming follow edge to \"player100\", so no vertex or edge is returned. Go one step from the vertex \"player100\" over outgoing serve edges and get the subgraph. nebula> GET SUBGRAPH 1 STEPS FROM \"player100\" OUT serve; +---------------------------------------------+--------------------------------------------------------------+ | _vertices | _edges | +---------------------------------------------+--------------------------------------------------------------+ | [(player100) player.age:42,player.name:Tim] | [player100-[serve]->team200@0 start_year:1997,end_year:2016] | +---------------------------------------------+--------------------------------------------------------------+ | [(team200) team.name:Warriors] | [] | +---------------------------------------------+--------------------------------------------------------------+ Got 2 rows (time spent 2107/2547 us) The returned subgraph is as follows.","title":"Examples"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/","text":"EXPLAIN and PROFILE \u00b6 EXPLAIN helps output the execution plan of an nGQL statement without executing the statement. PROFILE executes the statement, then outputs the execution plan as well as the execution profile. You can optimize the queries for better performance with the execution plan and profile. Execution Plan \u00b6 The execution plan is determined by the execution planner in the Nebula Graph query engine. The execution planner processes the parsed nGQL statements into actions. An action is the smallest unit that can be executed. A typical action fetches all neighbors of a given vertex, gets the properties of an edge, or filters vertices or edges based on the given conditions. Each action is assigned to an operator that performs the action. For example, a SHOW TAGS statement is processed into two actions and assigned to a Start operator and a ShowTags operator, while a more complex GO statement may be processed into more than 10 actions and assigned to 10 operators. Syntax \u00b6 EXPLAIN EXPLAIN [format=\"row\" | \"dot\"] <your_nGQL_statement> PROFILE PROFILE [format=\"row\" | \"dot\"] <your_nGQL_statement> Output formats \u00b6 The output of an EXPLAIN or a PROFILE statement has two formats, the default \"row\" format and the \"dot\" format. You can use the format option to modify the output format. Omitting the format option indicates using the default \"row\" format. Format \"row\" \u00b6 The \"row\" format outputs the return message in a table as follows. EXPLAIN : nebula> EXPLAIN format=\"row\" SHOW TAGS; Execution succeeded (time spent 104/705 us) Execution Plan +----+----------+--------------+----------------+-----------------------------------------------------------------------+ | id | name | dependencies | profiling data | operator info | +----+----------+--------------+----------------+-----------------------------------------------------------------------+ | 0 | ShowTags | 2 | | outputVar: [ {\"colNames\":[],\"name\":\"__ShowTags_0\",\"type\":\"DATASET\"}] | | | | | | inputVar: | +----+----------+--------------+----------------+-----------------------------------------------------------------------+ | 2 | Start | | | outputVar: [ {\"colNames\":[],\"name\":\"__Start_2\",\"type\":\"DATASET\"}] | +----+----------+--------------+----------------+-----------------------------------------------------------------------+ PROFILE : nebula> PROFILE format=\"row\" SHOW TAGS; +--------+ | Name | +--------+ | player | +--------+ | team | +--------+ Got 2 rows (time spent 2038/2728 us) Execution Plan +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ | id | name | dependencies | profiling data | operator info | +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ | 0 | ShowTags | 2 | ver: 0, rows: 1, execTime: 79us, totalTime: 1692us | outputVar: [{\"colNames\":[],\"name\":\"__ShowTags_0\",\"type\":\"DATASET\"}] | | | | | | inputVar: | +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ | 2 | Start | | ver: 0, rows: 0, execTime: 1us, totalTime: 57us | outputVar: [{\"colNames\":[],\"name\":\"__Start_2\",\"type\":\"DATASET\"}] | +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ The descriptions of the columns are as follows: Column Description id Indicates the ID of the operator. name Indicates the name of the operator. dependencies Shows the ID of the operator that the current operator depends on. profiling data Shows the execution profile. ver is the version of the operator, which you can use to identify loops; rows shows the number of rows to be output by the operator; execTime shows the execution time only; totalTime contains the execution time and the system scheduling and queueing time. operator info Shows the detailed information of the operator. Format \"dot\" \u00b6 You can use the format=\"dot\" option to output the return message in the DOT language, and then use Graphviz to generate a graph of the plan. NOTE : Graphviz is open source graph visualization software. Graphviz provides an online tool for previewing DOT language files and exporting them to other formats such as SVG or JSON. For more information, see Graphviz Online . nebula> EXPLAIN format=\"dot\" SHOW TAGS; Execution succeeded (time spent 161/665 us) Execution Plan --------------------------------------------------------------------------------------------------------------------------------------------- ------------- plan --------------------------------------------------------------------------------------------------------------------------------------------- ------------- digraph exec_plan { rankdir=LR; \"ShowTags_0\"[label=\"ShowTags_0|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__ShowTags_0\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar:\\l\", shape=Mrecord]; \"Start_2\"->\"ShowTags_0\"; \"Start_2\"[label=\"Start_2|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__Start_2\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar: \\l\", shape=Mrecord]; } --------------------------------------------------------------------------------------------------------------------------------------------- ------------- Transformed into a Graphviz graph, it is as follows:","title":"EXPLAIN and PROFILE"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#explain_and_profile","text":"EXPLAIN helps output the execution plan of an nGQL statement without executing the statement. PROFILE executes the statement, then outputs the execution plan as well as the execution profile. You can optimize the queries for better performance with the execution plan and profile.","title":"EXPLAIN and PROFILE"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#execution_plan","text":"The execution plan is determined by the execution planner in the Nebula Graph query engine. The execution planner processes the parsed nGQL statements into actions. An action is the smallest unit that can be executed. A typical action fetches all neighbors of a given vertex, gets the properties of an edge, or filters vertices or edges based on the given conditions. Each action is assigned to an operator that performs the action. For example, a SHOW TAGS statement is processed into two actions and assigned to a Start operator and a ShowTags operator, while a more complex GO statement may be processed into more than 10 actions and assigned to 10 operators.","title":"Execution Plan"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#syntax","text":"EXPLAIN EXPLAIN [format=\"row\" | \"dot\"] <your_nGQL_statement> PROFILE PROFILE [format=\"row\" | \"dot\"] <your_nGQL_statement>","title":"Syntax"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#output_formats","text":"The output of an EXPLAIN or a PROFILE statement has two formats, the default \"row\" format and the \"dot\" format. You can use the format option to modify the output format. Omitting the format option indicates using the default \"row\" format.","title":"Output formats"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#format_row","text":"The \"row\" format outputs the return message in a table as follows. EXPLAIN : nebula> EXPLAIN format=\"row\" SHOW TAGS; Execution succeeded (time spent 104/705 us) Execution Plan +----+----------+--------------+----------------+-----------------------------------------------------------------------+ | id | name | dependencies | profiling data | operator info | +----+----------+--------------+----------------+-----------------------------------------------------------------------+ | 0 | ShowTags | 2 | | outputVar: [ {\"colNames\":[],\"name\":\"__ShowTags_0\",\"type\":\"DATASET\"}] | | | | | | inputVar: | +----+----------+--------------+----------------+-----------------------------------------------------------------------+ | 2 | Start | | | outputVar: [ {\"colNames\":[],\"name\":\"__Start_2\",\"type\":\"DATASET\"}] | +----+----------+--------------+----------------+-----------------------------------------------------------------------+ PROFILE : nebula> PROFILE format=\"row\" SHOW TAGS; +--------+ | Name | +--------+ | player | +--------+ | team | +--------+ Got 2 rows (time spent 2038/2728 us) Execution Plan +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ | id | name | dependencies | profiling data | operator info | +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ | 0 | ShowTags | 2 | ver: 0, rows: 1, execTime: 79us, totalTime: 1692us | outputVar: [{\"colNames\":[],\"name\":\"__ShowTags_0\",\"type\":\"DATASET\"}] | | | | | | inputVar: | +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ | 2 | Start | | ver: 0, rows: 0, execTime: 1us, totalTime: 57us | outputVar: [{\"colNames\":[],\"name\":\"__Start_2\",\"type\":\"DATASET\"}] | +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ The descriptions of the columns are as follows: Column Description id Indicates the ID of the operator. name Indicates the name of the operator. dependencies Shows the ID of the operator that the current operator depends on. profiling data Shows the execution profile. ver is the version of the operator, which you can use to identify loops; rows shows the number of rows to be output by the operator; execTime shows the execution time only; totalTime contains the execution time and the system scheduling and queueing time. operator info Shows the detailed information of the operator.","title":"Format \"row\""},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#format_dot","text":"You can use the format=\"dot\" option to output the return message in the DOT language, and then use Graphviz to generate a graph of the plan. NOTE : Graphviz is open source graph visualization software. Graphviz provides an online tool for previewing DOT language files and exporting them to other formats such as SVG or JSON. For more information, see Graphviz Online . nebula> EXPLAIN format=\"dot\" SHOW TAGS; Execution succeeded (time spent 161/665 us) Execution Plan --------------------------------------------------------------------------------------------------------------------------------------------- ------------- plan --------------------------------------------------------------------------------------------------------------------------------------------- ------------- digraph exec_plan { rankdir=LR; \"ShowTags_0\"[label=\"ShowTags_0|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__ShowTags_0\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar:\\l\", shape=Mrecord]; \"Start_2\"->\"ShowTags_0\"; \"Start_2\"[label=\"Start_2|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__Start_2\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar: \\l\", shape=Mrecord]; } --------------------------------------------------------------------------------------------------------------------------------------------- ------------- Transformed into a Graphviz graph, it is as follows:","title":"Format \"dot\""},{"location":"3.ngql-guide/18.operation-and-maintenance-statements/4.job-statements/","text":"Job manager and the JOB statements \u00b6 The long-term tasks running by the Storage Service are called jobs. For example, there are jobs for COMPACT , FLUSH , and STATS . These jobs can be time-consuming if the data size in the graph space is large. The job manager helps you run, show, stop, and recover the jobs. SUBMIT JOB COMPACT \u00b6 The SUBMIT JOB COMPACT statement triggers the long-term RocksDB compact operation. nebula> SUBMIT JOB COMPACT; +------------+ | New Job Id | +------------+ | 40 | +------------+ For more information about compact configuration, see Storage Service configuration (doc TODO). SUBMIT JOB FLUSH \u00b6 The SUBMIT JOB FLUSH statement writes the RocksDB memfile in memory to the hard disk. nebula> SUBMIT JOB COMPACT; +------------+ | New Job Id | +------------+ | 96 | +------------+ SUBMIT JOB STATS \u00b6 The SUBMIT JOB STATS statement starts a job that makes the statistics of the current graph space. Once this job succeeds, you can use the SHOW STATS statement to list the statistics. For more information, see SHOW STATS . NOTE: If the data stored in the graph space changes, in order to get the latest statistics, you have to run SUBMIT JOB STATS again. nebula> SUBMIT JOB COMPACT; +------------+ | New Job Id | +------------+ | 97 | +------------+ SHOW JOB \u00b6 The Meta Service parses a SUBMIT JOB request into tasks and assigns them to the nebula-storaged processes. The SHOW JOB <job_id> statement shows the information about a specific job and all its tasks. The job ID is created when you run the SUBMIT JOB statement. nebula> SHOW JOB 96; +----------------+---------------+------------+------------+------------+ | Job Id(TaskId) | Command(Dest) | Status | Start Time | Stop Time | +----------------+---------------+------------+------------+------------+ | 96 | \"FLUSH\" | \"FINISHED\" | 1606544069 | 1606544069 | +----------------+---------------+------------+------------+------------+ | 0 | \"storaged2\" | \"FINISHED\" | 1606544069 | 1606544069 | +----------------+---------------+------------+------------+------------+ | 1 | \"storaged0\" | \"FINISHED\" | 1606544069 | 1606544069 | +----------------+---------------+------------+------------+------------+ | 2 | \"storaged1\" | \"FINISHED\" | 1606544069 | 1606544069 | +----------------+---------------+------------+------------+------------+ The description of the return message is as follows. Column Description Job Id(TaskId) The first row shows the job ID, and the other rows show the task IDs. Command(Dest) The first row shows the command executed, and the other rows show on which storaged processes the task is running. Status Shows the status of the job or task. For more information about job status, see Job status . Start Time Shows a timestamp indicating the time when the job or task enters the RUNNING phase. Stop Time Shows a timestamp indicating the time when the job or task gets FINISHED , FAILED , or STOPPED . Job status \u00b6 The description of the job status is as follows. Status Description QUEUE The job or task is waiting in a queue. The Start Time is empty in this phase. RUNNING The job or task is running. The Start Time shows the beginning of this phase. FINISHED The job or task is successfully finished. The Stop Time shows the time when the job or task enters this phase. FAILED The job or task failed. STOPPED The job or task is stopped without running. REMOVED The job or task is removed. Status switching is described as follows. Queue -- running -- finished -- removed \\ \\ / \\ \\ -- failed -- / \\ \\ / \\ ---------- stopped -/ SHOW JOBS \u00b6 The SHOW JOBS statement lists all the unexpired jobs. The default job expiration interval is one week. You can change it by modifying the job_expired_secs parameter of the Meta Service. For how to modify job_expired_secs , see Meta Service configuration (doc TODO). nebula> SHOW JOBS +--------+----------------------+------------+------------+------------+ | Job Id | Command | Status | Start Time | Stop Time | +--------+----------------------+------------+------------+------------+ | 97 | \"STATS\" | \"FINISHED\" | 1606546132 | 1606546132 | +--------+----------------------+------------+------------+------------+ | 96 | \"FLUSH\" | \"FINISHED\" | 1606544069 | 1606544069 | +--------+----------------------+------------+------------+------------+ | 95 | \"STATS\" | \"FINISHED\" | 1606539731 | 1606539731 | +--------+----------------------+------------+------------+------------+ | 86 | \"REBUILD_EDGE_INDEX\" | \"FINISHED\" | 1606369104 | 1606369104 | +--------+----------------------+------------+------------+------------+ STOP JOB \u00b6 The STOP JOB statement stops jobs that are not finished. nebula> STOP JOB 22 +---------------+ | Result | +---------------+ | \"Job stopped\" | +---------------+ RECOVER JOB \u00b6 The RECOVER JOB statement re-executes the failed jobs and returns the number of recovered jobs. nebula> RECOVER JOB +-------------------+ | Recovered job num | +-------------------+ | 5 job recovered | +-------------------+ FAQ \u00b6 How to troubleshoot job problems \u00b6 The SUBMIT JOB operations use the HTTP port. Please check if the HTTP ports on the machines where the Storage Service is running are working well. You can use the following command to debug. curl \"http://{storaged-ip}:12000/admin?space={test}&op=compact\"","title":"Job manager and the JOB statements"},{"location":"3.ngql-guide/18.operation-and-maintenance-statements/4.job-statements/#job_manager_and_the_job_statements","text":"The long-term tasks running by the Storage Service are called jobs. For example, there are jobs for COMPACT , FLUSH , and STATS . These jobs can be time-consuming if the data size in the graph space is large. The job manager helps you run, show, stop, and recover the jobs.","title":"Job manager and the JOB statements"},{"location":"3.ngql-guide/18.operation-and-maintenance-statements/4.job-statements/#submit_job_compact","text":"The SUBMIT JOB COMPACT statement triggers the long-term RocksDB compact operation. nebula> SUBMIT JOB COMPACT; +------------+ | New Job Id | +------------+ | 40 | +------------+ For more information about compact configuration, see Storage Service configuration (doc TODO).","title":"SUBMIT JOB COMPACT"},{"location":"3.ngql-guide/18.operation-and-maintenance-statements/4.job-statements/#submit_job_flush","text":"The SUBMIT JOB FLUSH statement writes the RocksDB memfile in memory to the hard disk. nebula> SUBMIT JOB COMPACT; +------------+ | New Job Id | +------------+ | 96 | +------------+","title":"SUBMIT JOB FLUSH"},{"location":"3.ngql-guide/18.operation-and-maintenance-statements/4.job-statements/#submit_job_stats","text":"The SUBMIT JOB STATS statement starts a job that makes the statistics of the current graph space. Once this job succeeds, you can use the SHOW STATS statement to list the statistics. For more information, see SHOW STATS . NOTE: If the data stored in the graph space changes, in order to get the latest statistics, you have to run SUBMIT JOB STATS again. nebula> SUBMIT JOB COMPACT; +------------+ | New Job Id | +------------+ | 97 | +------------+","title":"SUBMIT JOB STATS"},{"location":"3.ngql-guide/18.operation-and-maintenance-statements/4.job-statements/#show_job","text":"The Meta Service parses a SUBMIT JOB request into tasks and assigns them to the nebula-storaged processes. The SHOW JOB <job_id> statement shows the information about a specific job and all its tasks. The job ID is created when you run the SUBMIT JOB statement. nebula> SHOW JOB 96; +----------------+---------------+------------+------------+------------+ | Job Id(TaskId) | Command(Dest) | Status | Start Time | Stop Time | +----------------+---------------+------------+------------+------------+ | 96 | \"FLUSH\" | \"FINISHED\" | 1606544069 | 1606544069 | +----------------+---------------+------------+------------+------------+ | 0 | \"storaged2\" | \"FINISHED\" | 1606544069 | 1606544069 | +----------------+---------------+------------+------------+------------+ | 1 | \"storaged0\" | \"FINISHED\" | 1606544069 | 1606544069 | +----------------+---------------+------------+------------+------------+ | 2 | \"storaged1\" | \"FINISHED\" | 1606544069 | 1606544069 | +----------------+---------------+------------+------------+------------+ The description of the return message is as follows. Column Description Job Id(TaskId) The first row shows the job ID, and the other rows show the task IDs. Command(Dest) The first row shows the command executed, and the other rows show on which storaged processes the task is running. Status Shows the status of the job or task. For more information about job status, see Job status . Start Time Shows a timestamp indicating the time when the job or task enters the RUNNING phase. Stop Time Shows a timestamp indicating the time when the job or task gets FINISHED , FAILED , or STOPPED .","title":"SHOW JOB "},{"location":"3.ngql-guide/18.operation-and-maintenance-statements/4.job-statements/#job_status","text":"The description of the job status is as follows. Status Description QUEUE The job or task is waiting in a queue. The Start Time is empty in this phase. RUNNING The job or task is running. The Start Time shows the beginning of this phase. FINISHED The job or task is successfully finished. The Stop Time shows the time when the job or task enters this phase. FAILED The job or task failed. STOPPED The job or task is stopped without running. REMOVED The job or task is removed. Status switching is described as follows. Queue -- running -- finished -- removed \\ \\ / \\ \\ -- failed -- / \\ \\ / \\ ---------- stopped -/","title":"Job status"},{"location":"3.ngql-guide/18.operation-and-maintenance-statements/4.job-statements/#show_jobs","text":"The SHOW JOBS statement lists all the unexpired jobs. The default job expiration interval is one week. You can change it by modifying the job_expired_secs parameter of the Meta Service. For how to modify job_expired_secs , see Meta Service configuration (doc TODO). nebula> SHOW JOBS +--------+----------------------+------------+------------+------------+ | Job Id | Command | Status | Start Time | Stop Time | +--------+----------------------+------------+------------+------------+ | 97 | \"STATS\" | \"FINISHED\" | 1606546132 | 1606546132 | +--------+----------------------+------------+------------+------------+ | 96 | \"FLUSH\" | \"FINISHED\" | 1606544069 | 1606544069 | +--------+----------------------+------------+------------+------------+ | 95 | \"STATS\" | \"FINISHED\" | 1606539731 | 1606539731 | +--------+----------------------+------------+------------+------------+ | 86 | \"REBUILD_EDGE_INDEX\" | \"FINISHED\" | 1606369104 | 1606369104 | +--------+----------------------+------------+------------+------------+","title":"SHOW JOBS"},{"location":"3.ngql-guide/18.operation-and-maintenance-statements/4.job-statements/#stop_job","text":"The STOP JOB statement stops jobs that are not finished. nebula> STOP JOB 22 +---------------+ | Result | +---------------+ | \"Job stopped\" | +---------------+","title":"STOP JOB"},{"location":"3.ngql-guide/18.operation-and-maintenance-statements/4.job-statements/#recover_job","text":"The RECOVER JOB statement re-executes the failed jobs and returns the number of recovered jobs. nebula> RECOVER JOB +-------------------+ | Recovered job num | +-------------------+ | 5 job recovered | +-------------------+","title":"RECOVER JOB"},{"location":"3.ngql-guide/18.operation-and-maintenance-statements/4.job-statements/#faq","text":"","title":"FAQ"},{"location":"3.ngql-guide/18.operation-and-maintenance-statements/4.job-statements/#how_to_troubleshoot_job_problems","text":"The SUBMIT JOB operations use the HTTP port. Please check if the HTTP ports on the machines where the Storage Service is running are working well. You can use the following command to debug. curl \"http://{storaged-ip}:12000/admin?space={test}&op=compact\"","title":"How to troubleshoot job problems"},{"location":"3.ngql-guide/3.data-types/1.numeric/","text":"Numeric types \u00b6 Integer \u00b6 An integer is declared with keyword int , which is 64-bit signed . The supported range is [-9223372036854775808, 9223372036854775807]. Integer constants support multiple formats: Decimal, for example 123456 Hexadecimal, for example 0xdeadbeaf Octal, for example 01234567 Double floating point \u00b6 Double floating point data type is used for storing double precision floating point values. The keyword used for double floating point data type is double . There are no upper bounds and lower bounds.","title":"Numeric"},{"location":"3.ngql-guide/3.data-types/1.numeric/#numeric_types","text":"","title":"Numeric types"},{"location":"3.ngql-guide/3.data-types/1.numeric/#integer","text":"An integer is declared with keyword int , which is 64-bit signed . The supported range is [-9223372036854775808, 9223372036854775807]. Integer constants support multiple formats: Decimal, for example 123456 Hexadecimal, for example 0xdeadbeaf Octal, for example 01234567","title":"Integer"},{"location":"3.ngql-guide/3.data-types/1.numeric/#double_floating_point","text":"Double floating point data type is used for storing double precision floating point values. The keyword used for double floating point data type is double . There are no upper bounds and lower bounds.","title":"Double floating point"},{"location":"3.ngql-guide/3.data-types/2.boolean/","text":"Boolean \u00b6 A boolean data type is declared with the bool keyword and can only take the values true or false .","title":"Boolean"},{"location":"3.ngql-guide/3.data-types/2.boolean/#boolean","text":"A boolean data type is declared with the bool keyword and can only take the values true or false .","title":"Boolean"},{"location":"3.ngql-guide/3.data-types/3.string/","text":"String \u00b6 The string type is used to store a sequence of characters (text). The literal constant is a sequence of characters of any length surrounded by double or single quotes. For example \"Shaquille O'Neal\" or '\"This is a double-quoted literal string\"' . Line breaks are not allowed in a string. Embedded escape sequences are supported within strings, for example: \"\\n\\t\\r\\b\\f\" \"\\110ello world\" Nebula Graph supports two kind of strings: fixed length string and variable length string. For example: nebula> CREATE TAG t1 (p1 FIXED_STRING(10)); -- Fixed length string type nebula> CREATE TAG t2 (p2 string); -- Variable length string type","title":"String"},{"location":"3.ngql-guide/3.data-types/3.string/#string","text":"The string type is used to store a sequence of characters (text). The literal constant is a sequence of characters of any length surrounded by double or single quotes. For example \"Shaquille O'Neal\" or '\"This is a double-quoted literal string\"' . Line breaks are not allowed in a string. Embedded escape sequences are supported within strings, for example: \"\\n\\t\\r\\b\\f\" \"\\110ello world\" Nebula Graph supports two kind of strings: fixed length string and variable length string. For example: nebula> CREATE TAG t1 (p1 FIXED_STRING(10)); -- Fixed length string type nebula> CREATE TAG t2 (p2 string); -- Variable length string type","title":"String"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/","text":"Date and time types \u00b6 This document describes the DATE , TIME , DATETIME , and TIMESTAMP types. Nebula Graph converts the DATE , TIME , DATETIME , and TIMESTAMP values from the current time zone to UTC for storage. Nebula Graph converts back from UTC to the current time zone for retrieval. Combined with YIELD , functions date() , time() , datetime() all accept empty parameters to return the current date, time and datetime. DATE \u00b6 The DATE type is used for values with a date part but no time part. Nebula Graph retrieves and displays DATE values in the YYYY-MM-DD format. The supported range is -32768-01-01 to 32767-12-31 . TIME \u00b6 The TIME type is used for values with a time part but no date part. Nebula Graph retrieves and displays TIME values in hh:mm:ss:usus format. The supported range is 0:0:0:0 to 23:59:59:999999 . DATETIME \u00b6 The DATETIME type is used for values that contain both date and time parts. Nebula Graph retrieves and displays DATETIME values in YYYY-MM-DD hh:mm:ss:usus format. The supported range is -32768-01-01 00:00:00:00 to 32767-12-31 23:59:59:999999 . TIMESTAMP \u00b6 The TIMESTAMP data type is used for values that contain both date and time parts. TIMESTAMP has a range of 1970-01-01 00:00:01 UTC to 2262-04-11 23:47:16 UTC. Timestamp is measured in units of seconds. Supported TIMESTAMP inserting methods: Call the now() function. Input TIMESTAMP by using a string. For example: 2019-10-01 10:00:00 . Input TIMESTAMP directly, namely the number of seconds from 1970-01-01 00:00:00 . The underlying storage data type is: int64 . Examples \u00b6 Create a tag named date. nebula> CREATE TAG date(p1 date, p2 time, p3 datetime); Insert a vertex named Date1. nebula> INSERT VERTEX date(p1, p2, p3) VALUES \"Date1\":(date(\"2017-03-04\"), time(\"23:01:00\"), datetime(\"2017-03-04T22:30:40\")); Create a tag named school. nebula> CREATE TAG school(name string , create_time timestamp); Insert a vertex named \"stanford\" with the foundation date \"1885-10-01 08:00:00\" . nebula> INSERT VERTEX school(name, create_time) VALUES \"Stanford\":(\"Stanford\", \"1985-10-01 08:00:00\"); Insert a vertex named \"dut\" with the foundation date now. nebula> INSERT VERTEX school(name, create_time) VALUES \"dut\":(\"dut\", now());","title":"Date and time"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#date_and_time_types","text":"This document describes the DATE , TIME , DATETIME , and TIMESTAMP types. Nebula Graph converts the DATE , TIME , DATETIME , and TIMESTAMP values from the current time zone to UTC for storage. Nebula Graph converts back from UTC to the current time zone for retrieval. Combined with YIELD , functions date() , time() , datetime() all accept empty parameters to return the current date, time and datetime.","title":"Date and time types"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#date","text":"The DATE type is used for values with a date part but no time part. Nebula Graph retrieves and displays DATE values in the YYYY-MM-DD format. The supported range is -32768-01-01 to 32767-12-31 .","title":"DATE"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#time","text":"The TIME type is used for values with a time part but no date part. Nebula Graph retrieves and displays TIME values in hh:mm:ss:usus format. The supported range is 0:0:0:0 to 23:59:59:999999 .","title":"TIME"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#datetime","text":"The DATETIME type is used for values that contain both date and time parts. Nebula Graph retrieves and displays DATETIME values in YYYY-MM-DD hh:mm:ss:usus format. The supported range is -32768-01-01 00:00:00:00 to 32767-12-31 23:59:59:999999 .","title":"DATETIME"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#timestamp","text":"The TIMESTAMP data type is used for values that contain both date and time parts. TIMESTAMP has a range of 1970-01-01 00:00:01 UTC to 2262-04-11 23:47:16 UTC. Timestamp is measured in units of seconds. Supported TIMESTAMP inserting methods: Call the now() function. Input TIMESTAMP by using a string. For example: 2019-10-01 10:00:00 . Input TIMESTAMP directly, namely the number of seconds from 1970-01-01 00:00:00 . The underlying storage data type is: int64 .","title":"TIMESTAMP"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#examples","text":"Create a tag named date. nebula> CREATE TAG date(p1 date, p2 time, p3 datetime); Insert a vertex named Date1. nebula> INSERT VERTEX date(p1, p2, p3) VALUES \"Date1\":(date(\"2017-03-04\"), time(\"23:01:00\"), datetime(\"2017-03-04T22:30:40\")); Create a tag named school. nebula> CREATE TAG school(name string , create_time timestamp); Insert a vertex named \"stanford\" with the foundation date \"1885-10-01 08:00:00\" . nebula> INSERT VERTEX school(name, create_time) VALUES \"Stanford\":(\"Stanford\", \"1985-10-01 08:00:00\"); Insert a vertex named \"dut\" with the foundation date now. nebula> INSERT VERTEX school(name, create_time) VALUES \"dut\":(\"dut\", now());","title":"Examples"},{"location":"3.ngql-guide/3.data-types/5.null/","text":"NULL \u00b6 You can set the properties for vertices or edges to NULL . Also, you can set NOT NULL constraint to make sure that the property values are NOT NULL . If not specified, the property is set to NULL by default. Examples \u00b6 Create a tag named player. Specify the property name with NOT NULL . Skip the property age constraint. nebula> CREATE TAG player(name string NOT NULL, age int); Execution succeeded (time spent 5001/5980 us) The property name is NOT NULL . The property age is NULL by default. nebula> SHOW CREATE TAG player; +-----------+-----------------------------------+ | Tag | Create Tag | +-----------+-----------------------------------+ | \"student\" | \"CREATE TAG `player` ( | | | `name` string NOT NULL, | | | `age` int64 NULL | | | ) ttl_duration = 0, ttl_col = \"\"\" | +-----------+-----------------------------------+ nebula> INSERT VERTEX player(name, age) VALUES \"Kobe\":(\"Kobe\",null); Execution succeeded (time spent 6367/7357 us)","title":"NULL"},{"location":"3.ngql-guide/3.data-types/5.null/#null","text":"You can set the properties for vertices or edges to NULL . Also, you can set NOT NULL constraint to make sure that the property values are NOT NULL . If not specified, the property is set to NULL by default.","title":"NULL"},{"location":"3.ngql-guide/3.data-types/5.null/#examples","text":"Create a tag named player. Specify the property name with NOT NULL . Skip the property age constraint. nebula> CREATE TAG player(name string NOT NULL, age int); Execution succeeded (time spent 5001/5980 us) The property name is NOT NULL . The property age is NULL by default. nebula> SHOW CREATE TAG player; +-----------+-----------------------------------+ | Tag | Create Tag | +-----------+-----------------------------------+ | \"student\" | \"CREATE TAG `player` ( | | | `name` string NOT NULL, | | | `age` int64 NULL | | | ) ttl_duration = 0, ttl_col = \"\"\" | +-----------+-----------------------------------+ nebula> INSERT VERTEX player(name, age) VALUES \"Kobe\":(\"Kobe\",null); Execution succeeded (time spent 6367/7357 us)","title":"Examples"},{"location":"3.ngql-guide/3.data-types/6.list/","text":"List \u00b6 List is a composite data type. A composite data type cannot be stored as properties. List is a sequence of values. Individual list elements can be accessed by their positions. A list starts with a left square bracket [ and ends with a right square bracket ] . A list contains zero, one, or more expressions. List elements are separated from each other with a comma , . Whitespace around elements is ignored in list, thus line breaks, tab stops, and blanks can be used for formatting. CAUTION: A composite data type (i.e. set, map, and list) cannot be stored as properties. Examples \u00b6 [] [1, 2, 3]","title":"List"},{"location":"3.ngql-guide/3.data-types/6.list/#list","text":"List is a composite data type. A composite data type cannot be stored as properties. List is a sequence of values. Individual list elements can be accessed by their positions. A list starts with a left square bracket [ and ends with a right square bracket ] . A list contains zero, one, or more expressions. List elements are separated from each other with a comma , . Whitespace around elements is ignored in list, thus line breaks, tab stops, and blanks can be used for formatting. CAUTION: A composite data type (i.e. set, map, and list) cannot be stored as properties.","title":"List"},{"location":"3.ngql-guide/3.data-types/6.list/#examples","text":"[] [1, 2, 3]","title":"Examples"},{"location":"3.ngql-guide/3.data-types/7.set/","text":"Set \u00b6 Set is a composite data type. A composite data type cannot be stored as properties. Set is a string object that can have zero or more unique values. Individual set elements must be chosen from the list of values 'value1', 'value2', ... CAUTION: A composite data type (i.e. set, map, and list) cannot be stored as properties.","title":"Set"},{"location":"3.ngql-guide/3.data-types/7.set/#set","text":"Set is a composite data type. A composite data type cannot be stored as properties. Set is a string object that can have zero or more unique values. Individual set elements must be chosen from the list of values 'value1', 'value2', ... CAUTION: A composite data type (i.e. set, map, and list) cannot be stored as properties.","title":"Set"},{"location":"3.ngql-guide/3.data-types/8.map/","text":"Map \u00b6 Map is a composite data type. A composite data type cannot be stored as properties. Maps are unordered collections of key-value pairs. In maps, the key is a string. The value can have any data type. You can get the map element by using map['key'] .","title":"Map"},{"location":"3.ngql-guide/3.data-types/8.map/#map","text":"Map is a composite data type. A composite data type cannot be stored as properties. Maps are unordered collections of key-value pairs. In maps, the key is a string. The value can have any data type. You can get the map element by using map['key'] .","title":"Map"},{"location":"3.ngql-guide/3.data-types/9.type-conversion/","text":"Type Conversion \u00b6 Converting an expression of a given type to another type is known as type conversion. In nGQL, type conversion is divided into explicit conversion. Explicit type conversion \u00b6 In addition to implicit type conversion, explicit type conversion is also supported in case of semantics compliance. The syntax is similar to the C language: (type_name)expression . For example, the results of YIELD length((string)(123)), (int)\"123\" + 1 are 3, 124 respectively. The results of YIELD (int)(TRUE) is 1 . And YIELD (int)(\"12ab3\") fails in conversion.","title":"Type conversion"},{"location":"3.ngql-guide/3.data-types/9.type-conversion/#type_conversion","text":"Converting an expression of a given type to another type is known as type conversion. In nGQL, type conversion is divided into explicit conversion.","title":"Type Conversion"},{"location":"3.ngql-guide/3.data-types/9.type-conversion/#explicit_type_conversion","text":"In addition to implicit type conversion, explicit type conversion is also supported in case of semantics compliance. The syntax is similar to the C language: (type_name)expression . For example, the results of YIELD length((string)(123)), (int)\"123\" + 1 are 3, 124 respectively. The results of YIELD (int)(TRUE) is 1 . And YIELD (int)(\"12ab3\") fails in conversion.","title":"Explicit type conversion"},{"location":"3.ngql-guide/5.operators/1.comparison/","text":"Comparison operators \u00b6 Name Description = Assign a value / Division operator == Equal operator != Not equal operator < Less than operator <= Less than or equal operator - Minus operator % Modulo operator + Addition operator * Multiplication operator - Change the sign of the argument IS NULL NULL test IS NOT NULL not NULL test Comparison operations result in a value of true and false . == Equal. String comparisons are case-sensitive. Values of different types are not equal. NOTE: The equality operator is == in nGQL and is = in openCypher. nebula> YIELD 'A' == 'a'; +--------+ | (A==a) | +--------+ | false | +--------+ nebula> YIELD '2' == 2; +--------+ | (2==2) | +--------+ | false | +--------+ > Greater than: nebula> YIELD 3 > 2; +-------+ | (3>2) | +-------+ | true | +-------+ >= Greater than or equal to: nebula> YIELD 2 >= \"2\"; +--------+ | (2>=2) | +--------+ | false | +--------+ nebula> YIELD 2 >= 2; +--------+ | (2>=2) | +--------+ | true | +--------+ < Less than: nebula> YIELD 2.0 < 1.9; +---------+ | (2<1.9) | +---------+ | false | +---------+ <= Less than or equal to: nebula> YIELD 0.11 <= 0.11; +--------------+ | (0.11<=0.11) | +--------------+ | true | +--------------+ != Not equal: nebula> YIELD 1 != '1'; +--------+ | (1!=1) | +--------+ | true | +--------+ NULL nebula> TODO","title":"Comparison"},{"location":"3.ngql-guide/5.operators/1.comparison/#comparison_operators","text":"Name Description = Assign a value / Division operator == Equal operator != Not equal operator < Less than operator <= Less than or equal operator - Minus operator % Modulo operator + Addition operator * Multiplication operator - Change the sign of the argument IS NULL NULL test IS NOT NULL not NULL test Comparison operations result in a value of true and false . == Equal. String comparisons are case-sensitive. Values of different types are not equal. NOTE: The equality operator is == in nGQL and is = in openCypher. nebula> YIELD 'A' == 'a'; +--------+ | (A==a) | +--------+ | false | +--------+ nebula> YIELD '2' == 2; +--------+ | (2==2) | +--------+ | false | +--------+ > Greater than: nebula> YIELD 3 > 2; +-------+ | (3>2) | +-------+ | true | +-------+ >= Greater than or equal to: nebula> YIELD 2 >= \"2\"; +--------+ | (2>=2) | +--------+ | false | +--------+ nebula> YIELD 2 >= 2; +--------+ | (2>=2) | +--------+ | true | +--------+ < Less than: nebula> YIELD 2.0 < 1.9; +---------+ | (2<1.9) | +---------+ | false | +---------+ <= Less than or equal to: nebula> YIELD 0.11 <= 0.11; +--------------+ | (0.11<=0.11) | +--------------+ | true | +--------------+ != Not equal: nebula> YIELD 1 != '1'; +--------+ | (1!=1) | +--------+ | true | +--------+ NULL nebula> TODO","title":"Comparison operators"},{"location":"3.ngql-guide/5.operators/4.pipe/","text":"Pipe operator \u00b6 One major difference between nGQL and SQL is how sub-queries are composed. In SQL, to form a statement, sub-queries are nested (embedded). In nGQL the shell style PIPE (|) is introduced. Examples \u00b6 nebula> GO FROM \"player100\" OVER follow \\ YIELD follow._dst AS dstid, $$.player.name AS Name \\ | GO FROM $-.dstid OVER follow; +-------------+ | follow._dst | +-------------+ | \"player101\" | +-------------+ If no YIELD is used, the destination vertex ID is returned by default. If YIELD is declared explicitly, (the default value) id are not returned. To use pipe, always define alias names in the YIELD statement for the placeholder $-. . For example, the alias names are dstid and Name here.","title":"Pipe"},{"location":"3.ngql-guide/5.operators/4.pipe/#pipe_operator","text":"One major difference between nGQL and SQL is how sub-queries are composed. In SQL, to form a statement, sub-queries are nested (embedded). In nGQL the shell style PIPE (|) is introduced.","title":"Pipe operator"},{"location":"3.ngql-guide/5.operators/4.pipe/#examples","text":"nebula> GO FROM \"player100\" OVER follow \\ YIELD follow._dst AS dstid, $$.player.name AS Name \\ | GO FROM $-.dstid OVER follow; +-------------+ | follow._dst | +-------------+ | \"player101\" | +-------------+ If no YIELD is used, the destination vertex ID is returned by default. If YIELD is declared explicitly, (the default value) id are not returned. To use pipe, always define alias names in the YIELD statement for the placeholder $-. . For example, the alias names are dstid and Name here.","title":"Examples"},{"location":"3.ngql-guide/5.operators/5.property-reference/","text":"Property reference operator \u00b6 You can refer properties in WHERE or YIELD syntax. Reference from vertex \u00b6 For source vertex \u00b6 $^.<tag_name>.<prop_name> The symbol $^ is used to get the property of the source vertex, <tag_name> indicates the tag of the source vertex, and <prop_name> specifies the property name. For destination vertex \u00b6 $$.<tag_name>.<prop_name> The symbol $$ indicates the destination vertex, <tag_name> and <prop_name> are the tag and property of the destination vertex. Reference from edge \u00b6 For property \u00b6 To get properties of an edge, use the following syntax. <edge_type>.<edge_prop> The <edge_type> is the type of the edg. The <edge_prop> is the property of the edge. For Built-in Properties \u00b6 There are four built-in properties in the edge: _src: source vertex ID of the edge _dst: destination ID of the edge _type: edge type _rank: the edge's rank You can use _src and _dst to get the starting and ending vertices' ID, and they are very commonly used to show a graph path. Examples \u00b6 nebula> GO FROM \"player100\" OVER follow YIELD $^.player.name AS startName, $$.player.age AS endAge; +-----------+--------+ | startName | endAge | +-----------+--------+ | \"Tim\" | 36 | +-----------+--------+ | \"Tim\" | 33 | +-----------+--------+ Use the above query to get the name property of the source vertex and the age property of the destination vertex. nebula> GO FROM \"player100\" OVER follow YIELD follow.degree; +---------------+ | follow.degree | +---------------+ | 96 | +---------------+ | 90 | +---------------+ nebula> GO FROM \"player100\" OVER follow YIELD follow._src, follow._dst, follow._type, follow._rank; +-------------+-------------+--------------+--------------+ | follow._src | follow._dst | follow._type | follow._rank | +-------------+-------------+--------------+--------------+ | \"player100\" | \"player101\" | 11 | 0 | +-------------+-------------+--------------+--------------+ | \"player100\" | \"player102\" | 11 | 0 | +-------------+-------------+--------------+--------------+ This statement returns all the neighbors of vertex player100 over edge type follow , by referencing follow._src as the starting vertex ID (which, of course, is player100 ) and follow._dst as the ending vertex ID.","title":"Property reference"},{"location":"3.ngql-guide/5.operators/5.property-reference/#property_reference_operator","text":"You can refer properties in WHERE or YIELD syntax.","title":"Property reference operator"},{"location":"3.ngql-guide/5.operators/5.property-reference/#reference_from_vertex","text":"","title":"Reference from vertex"},{"location":"3.ngql-guide/5.operators/5.property-reference/#for_source_vertex","text":"$^.<tag_name>.<prop_name> The symbol $^ is used to get the property of the source vertex, <tag_name> indicates the tag of the source vertex, and <prop_name> specifies the property name.","title":"For source vertex"},{"location":"3.ngql-guide/5.operators/5.property-reference/#for_destination_vertex","text":"$$.<tag_name>.<prop_name> The symbol $$ indicates the destination vertex, <tag_name> and <prop_name> are the tag and property of the destination vertex.","title":"For destination vertex"},{"location":"3.ngql-guide/5.operators/5.property-reference/#reference_from_edge","text":"","title":"Reference from edge"},{"location":"3.ngql-guide/5.operators/5.property-reference/#for_property","text":"To get properties of an edge, use the following syntax. <edge_type>.<edge_prop> The <edge_type> is the type of the edg. The <edge_prop> is the property of the edge.","title":"For property"},{"location":"3.ngql-guide/5.operators/5.property-reference/#for_built-in_properties","text":"There are four built-in properties in the edge: _src: source vertex ID of the edge _dst: destination ID of the edge _type: edge type _rank: the edge's rank You can use _src and _dst to get the starting and ending vertices' ID, and they are very commonly used to show a graph path.","title":"For Built-in Properties"},{"location":"3.ngql-guide/5.operators/5.property-reference/#examples","text":"nebula> GO FROM \"player100\" OVER follow YIELD $^.player.name AS startName, $$.player.age AS endAge; +-----------+--------+ | startName | endAge | +-----------+--------+ | \"Tim\" | 36 | +-----------+--------+ | \"Tim\" | 33 | +-----------+--------+ Use the above query to get the name property of the source vertex and the age property of the destination vertex. nebula> GO FROM \"player100\" OVER follow YIELD follow.degree; +---------------+ | follow.degree | +---------------+ | 96 | +---------------+ | 90 | +---------------+ nebula> GO FROM \"player100\" OVER follow YIELD follow._src, follow._dst, follow._type, follow._rank; +-------------+-------------+--------------+--------------+ | follow._src | follow._dst | follow._type | follow._rank | +-------------+-------------+--------------+--------------+ | \"player100\" | \"player101\" | 11 | 0 | +-------------+-------------+--------------+--------------+ | \"player100\" | \"player102\" | 11 | 0 | +-------------+-------------+--------------+--------------+ This statement returns all the neighbors of vertex player100 over edge type follow , by referencing follow._src as the starting vertex ID (which, of course, is player100 ) and follow._dst as the ending vertex ID.","title":"Examples"},{"location":"3.ngql-guide/5.operators/6.set/","text":"Set operations \u00b6 This document descriptions the set operations, including UNION , UNION ALL , INTERSECT , and MINUS . To combine multiple queries, use the set operators. All set operators have equal precedence. If a nGQL statement contains multiple set operators, Nebula Graph evaluates them from the left to right unless parentheses explicitly specify another order. To use the set operators, always match the return results of the GO clause with the same number and data type. UNION, UNION DISTINCT, and UNION ALL \u00b6 <left> UNION [DISTINCT | ALL] <right> [ UNION [DISTINCT | ALL] <right> ...] Operator UNION DISTINCT (or by short UNION ) returns the union of two sets A and B without the duplicate elements. Operator UNION ALL returns the union of two sets A and B with duplicated elements. The <left> and <right> must have the same number of columns and data types. Different data types are converted according to the Type Conversion . Example \u00b6 The following statement nebula> GO FROM \"player102\" OVER follow \\ UNION \\ GO FROM \"player100\" OVER follow; +-------------+ | follow._dst | +-------------+ | \"player101\" | +-------------+ | \"player102\" | +-------------+ returns the neighbors' id of vertex \"player102\" and \"player100 (along with edge follow ) without duplication. While nebula> GO FROM \"player102\" OVER follow \\ UNION ALL \\ GO FROM \"player100\" OVER follow; +-------------+ | follow._dst | +-------------+ | \"player101\" | +-------------+ | \"player101\" | +-------------+ | \"player102\" | +-------------+ returns all the neighbors of vertex \"player102\" and \"player100 , with all possible duplications. UNION can also work with the YIELD statement. For example, let's suppose the results of the following two queries. nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; -- query 1 +-------------+--------+-----+ | id | Degree | Age | +-------------+--------+-----+ | \"player101\" | 75 | 36 | -- line 1 +-------------+--------+-----+ nebula> GO FROM \"player100\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; -- query 2 +-------------+--------+-----+ | id | Degree | Age | +-------------+--------+-----+ | \"player101\" | 96 | 36 | -- line 2 +-------------+--------+-----+ | \"player102\" | 90 | 33 | -- line 3 +-------------+--------+-----+ And the following statement nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age \\ UNION /* DISTINCT */ \\ GO FROM \"player100\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; returns the follows: +-------------+--------+-----+ | id | Degree | Age | +-------------+--------+-----+ | \"player101\" | 75 | 36 | -- line 1 +-------------+--------+-----+ | \"player101\" | 96 | 36 | -- line 2 +-------------+--------+-----+ | \"player102\" | 90 | 33 | -- line 3 +-------------+--------+-----+ The DISTINCT check duplication by all the columns for every line. So line 1 and line 2 are different. INTERSECT \u00b6 <left> INTERSECT <right> Operator INTERSECT returns the intersection of two sets A and B (denoted by A \u22c2 B). Similar to UNION , the <left> and <right> must have the same number of columns and data types. Only the INTERSECT columns of <left> and <right> are returned. For example, the following query nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age \\ INTERSECT \\ GO FROM \"player100\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; returns Empty set (time spent 5194/6264 us) MINUS \u00b6 <left> MINUS <right> Operator MINUS returns the subtraction (or difference) of two sets A and B (denoted by A - B). Always pay attention to the order of the <left> and <right> . The set A - B consists of elements that are in A but not in B. For example, the following query nebula> GO FROM \"player100\" OVER follow \\ MINUS \\ GO FROM \"player102\" OVER follow; returns +-------------+ | follow._dst | +-------------+ | \"player102\" | +-------------+ If you reverse the MINUS order, the query nebula> GO FROM \"player102\" OVER follow \\ MINUS \\ GO FROM \"player100\" OVER follow; returns Empty set (time spent 2243/3259 us) Precedence of the SET Operations and Pipe \u00b6 Please note that when a query contains pipe | and set operations, pipe takes precedence. Refer to the Pipe Doc for details. Query GO FROM 1 UNION GO FROM 2 | GO FROM 3 is the same as query GO FROM 1 UNION (GO FROM 2 | GO FROM 3) . For example: nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS play_dst \\ UNION \\ GO FROM \"team200\" OVER serve REVERSELY YIELD serve._dst AS play_dst \\ | GO FROM $-.play_dst OVER follow YIELD follow._dst AS play_dst; +-------------+ | play_dst | +-------------+ | \"player101\" | +-------------+ | \"player102\" | +-------------+ The statements in the red bar are executed first. And then the statement in the green box is executed. nebula> (GO FROM \"player102\" OVER follow YIELD follow._dst AS play_dst \\ UNION \\ GO FROM \"team200\" OVER serve REVERSELY YIELD serve._dst AS play_dst) \\ | GO FROM $-.play_dst OVER follow YIELD follow._dst AS play_dst; In the above query, the parentheses change the execution priority, and the statements within the parentheses take the precedence.","title":"Set"},{"location":"3.ngql-guide/5.operators/6.set/#set_operations","text":"This document descriptions the set operations, including UNION , UNION ALL , INTERSECT , and MINUS . To combine multiple queries, use the set operators. All set operators have equal precedence. If a nGQL statement contains multiple set operators, Nebula Graph evaluates them from the left to right unless parentheses explicitly specify another order. To use the set operators, always match the return results of the GO clause with the same number and data type.","title":"Set operations"},{"location":"3.ngql-guide/5.operators/6.set/#union_union_distinct_and_union_all","text":"<left> UNION [DISTINCT | ALL] <right> [ UNION [DISTINCT | ALL] <right> ...] Operator UNION DISTINCT (or by short UNION ) returns the union of two sets A and B without the duplicate elements. Operator UNION ALL returns the union of two sets A and B with duplicated elements. The <left> and <right> must have the same number of columns and data types. Different data types are converted according to the Type Conversion .","title":"UNION, UNION DISTINCT, and UNION ALL"},{"location":"3.ngql-guide/5.operators/6.set/#example","text":"The following statement nebula> GO FROM \"player102\" OVER follow \\ UNION \\ GO FROM \"player100\" OVER follow; +-------------+ | follow._dst | +-------------+ | \"player101\" | +-------------+ | \"player102\" | +-------------+ returns the neighbors' id of vertex \"player102\" and \"player100 (along with edge follow ) without duplication. While nebula> GO FROM \"player102\" OVER follow \\ UNION ALL \\ GO FROM \"player100\" OVER follow; +-------------+ | follow._dst | +-------------+ | \"player101\" | +-------------+ | \"player101\" | +-------------+ | \"player102\" | +-------------+ returns all the neighbors of vertex \"player102\" and \"player100 , with all possible duplications. UNION can also work with the YIELD statement. For example, let's suppose the results of the following two queries. nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; -- query 1 +-------------+--------+-----+ | id | Degree | Age | +-------------+--------+-----+ | \"player101\" | 75 | 36 | -- line 1 +-------------+--------+-----+ nebula> GO FROM \"player100\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; -- query 2 +-------------+--------+-----+ | id | Degree | Age | +-------------+--------+-----+ | \"player101\" | 96 | 36 | -- line 2 +-------------+--------+-----+ | \"player102\" | 90 | 33 | -- line 3 +-------------+--------+-----+ And the following statement nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age \\ UNION /* DISTINCT */ \\ GO FROM \"player100\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; returns the follows: +-------------+--------+-----+ | id | Degree | Age | +-------------+--------+-----+ | \"player101\" | 75 | 36 | -- line 1 +-------------+--------+-----+ | \"player101\" | 96 | 36 | -- line 2 +-------------+--------+-----+ | \"player102\" | 90 | 33 | -- line 3 +-------------+--------+-----+ The DISTINCT check duplication by all the columns for every line. So line 1 and line 2 are different.","title":"Example"},{"location":"3.ngql-guide/5.operators/6.set/#intersect","text":"<left> INTERSECT <right> Operator INTERSECT returns the intersection of two sets A and B (denoted by A \u22c2 B). Similar to UNION , the <left> and <right> must have the same number of columns and data types. Only the INTERSECT columns of <left> and <right> are returned. For example, the following query nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age \\ INTERSECT \\ GO FROM \"player100\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; returns Empty set (time spent 5194/6264 us)","title":"INTERSECT"},{"location":"3.ngql-guide/5.operators/6.set/#minus","text":"<left> MINUS <right> Operator MINUS returns the subtraction (or difference) of two sets A and B (denoted by A - B). Always pay attention to the order of the <left> and <right> . The set A - B consists of elements that are in A but not in B. For example, the following query nebula> GO FROM \"player100\" OVER follow \\ MINUS \\ GO FROM \"player102\" OVER follow; returns +-------------+ | follow._dst | +-------------+ | \"player102\" | +-------------+ If you reverse the MINUS order, the query nebula> GO FROM \"player102\" OVER follow \\ MINUS \\ GO FROM \"player100\" OVER follow; returns Empty set (time spent 2243/3259 us)","title":"MINUS"},{"location":"3.ngql-guide/5.operators/6.set/#precedence_of_the_set_operations_and_pipe","text":"Please note that when a query contains pipe | and set operations, pipe takes precedence. Refer to the Pipe Doc for details. Query GO FROM 1 UNION GO FROM 2 | GO FROM 3 is the same as query GO FROM 1 UNION (GO FROM 2 | GO FROM 3) . For example: nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS play_dst \\ UNION \\ GO FROM \"team200\" OVER serve REVERSELY YIELD serve._dst AS play_dst \\ | GO FROM $-.play_dst OVER follow YIELD follow._dst AS play_dst; +-------------+ | play_dst | +-------------+ | \"player101\" | +-------------+ | \"player102\" | +-------------+ The statements in the red bar are executed first. And then the statement in the green box is executed. nebula> (GO FROM \"player102\" OVER follow YIELD follow._dst AS play_dst \\ UNION \\ GO FROM \"team200\" OVER serve REVERSELY YIELD serve._dst AS play_dst) \\ | GO FROM $-.play_dst OVER follow YIELD follow._dst AS play_dst; In the above query, the parentheses change the execution priority, and the statements within the parentheses take the precedence.","title":"Precedence of the SET Operations and Pipe"},{"location":"3.ngql-guide/5.operators/7.string/","text":"String operators \u00b6 Name Description CONTAINS Perform case-sensitive inclusion searching in strings IN Whether a value is within a set of values (NOT) STARTS WITH Perform case-sensitive matching on the beginning of a string (NOT) ENDS WITH Perform case-sensitive matching on the ending of a string Regular expressions Perform regular expression matching on a string NOTE: All the string matchings are case-sensitive. Examples \u00b6 CONTAINS The CONTAINS operator requires string type in both left and right side. nebula> GO FROM \"player101\" OVER serve WHERE $$.team.name CONTAINS \"ets\" \\ YIELD $^.player.name, serve.start_year, serve.end_year, $$.team.name; +----------------+------------------+----------------+--------------+ | $^.player.name | serve.start_year | serve.end_year | $$.team.name | +----------------+------------------+----------------+--------------+ | \"Tony Parker\" | 1999 | 2018 | \"Nuggets\" | +----------------+------------------+----------------+--------------+ nebula> GO FROM \"player101\" OVER serve WHERE (STRING)serve.start_year CONTAINS \"19\" AND \\ $^.player.name CONTAINS \"ny\" \\ YIELD $^.player.name, serve.start_year, serve.end_year, $$.team.name; +----------------+------------------+----------------+--------------+ | $^.player.name | serve.start_year | serve.end_year | $$.team.name | +----------------+------------------+----------------+--------------+ | \"Tony Parker\" | 1999 | 2018 | \"Nuggets\" | +----------------+------------------+----------------+--------------+ nebula> GO FROM \"player101\" OVER serve WHERE !($$.team.name CONTAINS \"ets\") \\ YIELD $^.player.name, serve.start_year, serve.end_year, $$.team.name; Empty set (time spent 13040/14021 us) IN nebula> YIELD 1 IN [1,2,3]; +----------------+ | (1 IN [1,2,3]) | +----------------+ | true | +----------------+ nebula> YIELD \"Yao\" IN [\"Yi\", \"Tim\", \"Kobe\"]; +------------------------+ | (Yao IN [Yi,Tim,Kobe]) | +------------------------+ | false | +------------------------+ nebula> YIELD NULL in [\"Yi\", \"Tim\", \"Kobe\"]; +-----------------------------+ | (__NULL__ IN [Yi,Tim,Kobe]) | +-----------------------------+ | NULL | +-----------------------------+ (NOT) STARTS WITH nebula> YIELD 'apple' STARTS WITH 'app'; +-------------------------+ | (apple STARTS WITH app) | +-------------------------+ | true | +-------------------------+ nebula> YIELD 'apple' STARTS WITH 'a'; +-----------------------+ | (apple STARTS WITH a) | +-----------------------+ | true | +-----------------------+ nebula> YIELD 'apple' STARTS WITH 'A'; +-----------------------+ | (apple STARTS WITH A) | +-----------------------+ | false | +-----------------------+ nebula> YIELD 'apple' STARTS WITH 'b'; +-----------------------+ | (apple STARTS WITH b) | +-----------------------+ | false | +-----------------------+ nebula> YIELD 'apple' NOT STARTS WITH 'app'; +-----------------------------+ | (apple NOT STARTS WITH app) | +-----------------------------+ | false | +-----------------------------+ (NOT) ENDS WITH nebula> YIELD 'apple' ENDS WITH 'app'; +-----------------------+ | (apple ENDS WITH app) | +-----------------------+ | false | +-----------------------+ nebula> YIELD 'apple' ENDS WITH 'e'; +---------------------+ | (apple ENDS WITH e) | +---------------------+ | true | +---------------------+ nebula> YIELD 'apple' ENDS WITH 'E'; +---------------------+ | (apple ENDS WITH E) | +---------------------+ | false | +---------------------+ nebula> YIELD 'apple' ENDS WITH 'b'; +---------------------+ | (apple ENDS WITH b) | +---------------------+ | false | +---------------------+ Regular expressions Nebula Graph supports filtering by using regular expressions. The regular expression syntax is inherited from st::regex . You can match on regular expressions by using =~ 'regexp' . For example: nebula> FETCH PROP ON player WHERE player.name =~ 'Tony.*' YIELD player.name; The preceding statement returns the players whose name starts with 'Tony'. nebula> YIELD \"384748.39\" =~ \"\\\\d+(\\\\.\\\\d{2})?\"; +----------------------------+ | (384748.39=~\\d+(\\.\\d{2})?) | +----------------------------+ | true | +----------------------------+","title":"String"},{"location":"3.ngql-guide/5.operators/7.string/#string_operators","text":"Name Description CONTAINS Perform case-sensitive inclusion searching in strings IN Whether a value is within a set of values (NOT) STARTS WITH Perform case-sensitive matching on the beginning of a string (NOT) ENDS WITH Perform case-sensitive matching on the ending of a string Regular expressions Perform regular expression matching on a string NOTE: All the string matchings are case-sensitive.","title":"String operators"},{"location":"3.ngql-guide/5.operators/7.string/#examples","text":"CONTAINS The CONTAINS operator requires string type in both left and right side. nebula> GO FROM \"player101\" OVER serve WHERE $$.team.name CONTAINS \"ets\" \\ YIELD $^.player.name, serve.start_year, serve.end_year, $$.team.name; +----------------+------------------+----------------+--------------+ | $^.player.name | serve.start_year | serve.end_year | $$.team.name | +----------------+------------------+----------------+--------------+ | \"Tony Parker\" | 1999 | 2018 | \"Nuggets\" | +----------------+------------------+----------------+--------------+ nebula> GO FROM \"player101\" OVER serve WHERE (STRING)serve.start_year CONTAINS \"19\" AND \\ $^.player.name CONTAINS \"ny\" \\ YIELD $^.player.name, serve.start_year, serve.end_year, $$.team.name; +----------------+------------------+----------------+--------------+ | $^.player.name | serve.start_year | serve.end_year | $$.team.name | +----------------+------------------+----------------+--------------+ | \"Tony Parker\" | 1999 | 2018 | \"Nuggets\" | +----------------+------------------+----------------+--------------+ nebula> GO FROM \"player101\" OVER serve WHERE !($$.team.name CONTAINS \"ets\") \\ YIELD $^.player.name, serve.start_year, serve.end_year, $$.team.name; Empty set (time spent 13040/14021 us) IN nebula> YIELD 1 IN [1,2,3]; +----------------+ | (1 IN [1,2,3]) | +----------------+ | true | +----------------+ nebula> YIELD \"Yao\" IN [\"Yi\", \"Tim\", \"Kobe\"]; +------------------------+ | (Yao IN [Yi,Tim,Kobe]) | +------------------------+ | false | +------------------------+ nebula> YIELD NULL in [\"Yi\", \"Tim\", \"Kobe\"]; +-----------------------------+ | (__NULL__ IN [Yi,Tim,Kobe]) | +-----------------------------+ | NULL | +-----------------------------+ (NOT) STARTS WITH nebula> YIELD 'apple' STARTS WITH 'app'; +-------------------------+ | (apple STARTS WITH app) | +-------------------------+ | true | +-------------------------+ nebula> YIELD 'apple' STARTS WITH 'a'; +-----------------------+ | (apple STARTS WITH a) | +-----------------------+ | true | +-----------------------+ nebula> YIELD 'apple' STARTS WITH 'A'; +-----------------------+ | (apple STARTS WITH A) | +-----------------------+ | false | +-----------------------+ nebula> YIELD 'apple' STARTS WITH 'b'; +-----------------------+ | (apple STARTS WITH b) | +-----------------------+ | false | +-----------------------+ nebula> YIELD 'apple' NOT STARTS WITH 'app'; +-----------------------------+ | (apple NOT STARTS WITH app) | +-----------------------------+ | false | +-----------------------------+ (NOT) ENDS WITH nebula> YIELD 'apple' ENDS WITH 'app'; +-----------------------+ | (apple ENDS WITH app) | +-----------------------+ | false | +-----------------------+ nebula> YIELD 'apple' ENDS WITH 'e'; +---------------------+ | (apple ENDS WITH e) | +---------------------+ | true | +---------------------+ nebula> YIELD 'apple' ENDS WITH 'E'; +---------------------+ | (apple ENDS WITH E) | +---------------------+ | false | +---------------------+ nebula> YIELD 'apple' ENDS WITH 'b'; +---------------------+ | (apple ENDS WITH b) | +---------------------+ | false | +---------------------+ Regular expressions Nebula Graph supports filtering by using regular expressions. The regular expression syntax is inherited from st::regex . You can match on regular expressions by using =~ 'regexp' . For example: nebula> FETCH PROP ON player WHERE player.name =~ 'Tony.*' YIELD player.name; The preceding statement returns the players whose name starts with 'Tony'. nebula> YIELD \"384748.39\" =~ \"\\\\d+(\\\\.\\\\d{2})?\"; +----------------------------+ | (384748.39=~\\d+(\\.\\d{2})?) | +----------------------------+ | true | +----------------------------+","title":"Examples"},{"location":"3.ngql-guide/5.operators/9.precedence/","text":"Operator precedence \u00b6 The following list shows the precedence of nGQL operators in descending order. Operators that are shown together on a line have the same precedence. - (negative number) ! *, /, % -, + == , >=, >, <=, <, <>, != AND OR = (assignment) For operators that occur at the same precedence level within an expression, evaluation proceeds left to right, with the exception that assignments evaluate right to left. The precedence of operators determines the order of evaluation of terms in an expression. To override this order and group terms explicitly, use parentheses. Examples \u00b6 nebula> YIELD 2+3*5; +-----------+ | (2+(3*5)) | +-----------+ | 17 | +-----------+ nebula> YIELD (2+3)*5; +-----------+ | ((2+3)*5) | +-----------+ | 25 | +-----------+","title":"Precedence"},{"location":"3.ngql-guide/5.operators/9.precedence/#operator_precedence","text":"The following list shows the precedence of nGQL operators in descending order. Operators that are shown together on a line have the same precedence. - (negative number) ! *, /, % -, + == , >=, >, <=, <, <>, != AND OR = (assignment) For operators that occur at the same precedence level within an expression, evaluation proceeds left to right, with the exception that assignments evaluate right to left. The precedence of operators determines the order of evaluation of terms in an expression. To override this order and group terms explicitly, use parentheses.","title":"Operator precedence"},{"location":"3.ngql-guide/5.operators/9.precedence/#examples","text":"nebula> YIELD 2+3*5; +-----------+ | (2+(3*5)) | +-----------+ | 17 | +-----------+ nebula> YIELD (2+3)*5; +-----------+ | ((2+3)*5) | +-----------+ | 25 | +-----------+","title":"Examples"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/","text":"Built-in math functions \u00b6 Nebula Graph supports the following built-in math functions: Function Description double abs(double x) Return absolute value of the argument. double floor(double x) Return the largest integer value smaller than or equal to the argument. (Rounds down) double ceil(double x) Return the smallest integer greater than or equal to the argument. (Rounds up) double round(double x) Return integral value nearest to the argument, returns a number farther away from 0 if the parameter is in the middle. double sqrt(double x) Return the square root of the argument. double cbrt(double x) Return the cubic root of the argument. double hypot(double x, double y) Return the hypotenuse of a right-angled triangle. double pow(double x, double y) Compute the power of the argument. double exp(double x) Return the value of e raised to the x power. double exp2(double x) Return 2 raised to the argument. double log(double x) Return natural logarithm of the argument. double log2(double x) Return the base-2 logarithm of the argument. double log10(double x) Return the base-10 logarithm of the argument. double sin(double x) Return sine of the argument. double asin(double x) Return inverse sine of the argument. double cos(double x) Return cosine of the argument. double acos(double x) Return inverse cosine of the argument. double tan(double x) Return tangent of the argument. double atan(double x) Return inverse tangent the argument. int rand32() Return a random 32 bit integer. int rand32(int max) Return a random 32 bit integer in [0, max). int rand32(int min, int max) Return a random 32 bit integer in [min, max). int rand64() Return a random 64 bit integer. int rand64(int max) Return a random 64 bit integer in [0, max). int rand64(int min, int max) Return a random 64 bit integer in [min, max). collect() Put all the collected values to a list. collect_set() Put all the collected values to a set. int size() Return the number of elements in a list. map(fun, iter) Return a map object after applying the given function to each item of a given iterable.","title":"Math"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#built-in_math_functions","text":"Nebula Graph supports the following built-in math functions: Function Description double abs(double x) Return absolute value of the argument. double floor(double x) Return the largest integer value smaller than or equal to the argument. (Rounds down) double ceil(double x) Return the smallest integer greater than or equal to the argument. (Rounds up) double round(double x) Return integral value nearest to the argument, returns a number farther away from 0 if the parameter is in the middle. double sqrt(double x) Return the square root of the argument. double cbrt(double x) Return the cubic root of the argument. double hypot(double x, double y) Return the hypotenuse of a right-angled triangle. double pow(double x, double y) Compute the power of the argument. double exp(double x) Return the value of e raised to the x power. double exp2(double x) Return 2 raised to the argument. double log(double x) Return natural logarithm of the argument. double log2(double x) Return the base-2 logarithm of the argument. double log10(double x) Return the base-10 logarithm of the argument. double sin(double x) Return sine of the argument. double asin(double x) Return inverse sine of the argument. double cos(double x) Return cosine of the argument. double acos(double x) Return inverse cosine of the argument. double tan(double x) Return tangent of the argument. double atan(double x) Return inverse tangent the argument. int rand32() Return a random 32 bit integer. int rand32(int max) Return a random 32 bit integer in [0, max). int rand32(int min, int max) Return a random 32 bit integer in [min, max). int rand64() Return a random 64 bit integer. int rand64(int max) Return a random 64 bit integer in [0, max). int rand64(int min, int max) Return a random 64 bit integer in [min, max). collect() Put all the collected values to a list. collect_set() Put all the collected values to a set. int size() Return the number of elements in a list. map(fun, iter) Return a map object after applying the given function to each item of a given iterable.","title":"Built-in math functions"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/","text":"Built-in string functions \u00b6 Nebula Graph supports the following built-in string functions: NOTE: Like SQL, the character index (location) for nGQL starts from 1 . However, the character index (i.e. location in a list) for the C language starts from 0 . Function Description int strcasecmp(string a, string b) Compare strings without case sensitivity, when a = b, return 0, when a > b returned value is greater than 0, otherwise less than 0. string lower(string a) Return the argument in lowercase. string upper(string a) Return the argument in uppercase. int length(string a) Return the length (int) of given string in bytes. string trim(string a) Remove leading and trailing spaces. string ltrim(string a) Remove leading spaces. string rtrim(string a) Remove trailing spaces. string left(string a, int count) Return the substring in [1, count], if length a is less than count, return a. string right(string a, int count) Return the substring in [size - count + 1, size], if length a is less than count, return a. string lpad(string a, int size, string letters) Left-pads a string with another string to a certain length. string rpad(string a, int size, string letters) Reft-pads a string with another string to a certain length. string substr(string a, int pos, int count) Extract a substring from a string, starting at the specified position, extract the specified length characters. int hash(string a) Encode the data into an integer value. Explanations on the returns of function substr : If pos is 0, return an empty string. If the absolute value of pos is greater than the string, return an empty string. If pos is greater than 0, return substring in [pos, pos + count). If pos is less than 0, and set position N as length(a) + pos + 1, return substring in [N, N + count). If count is greater than length(a), return the whole string.","title":"String"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#built-in_string_functions","text":"Nebula Graph supports the following built-in string functions: NOTE: Like SQL, the character index (location) for nGQL starts from 1 . However, the character index (i.e. location in a list) for the C language starts from 0 . Function Description int strcasecmp(string a, string b) Compare strings without case sensitivity, when a = b, return 0, when a > b returned value is greater than 0, otherwise less than 0. string lower(string a) Return the argument in lowercase. string upper(string a) Return the argument in uppercase. int length(string a) Return the length (int) of given string in bytes. string trim(string a) Remove leading and trailing spaces. string ltrim(string a) Remove leading spaces. string rtrim(string a) Remove trailing spaces. string left(string a, int count) Return the substring in [1, count], if length a is less than count, return a. string right(string a, int count) Return the substring in [size - count + 1, size], if length a is less than count, return a. string lpad(string a, int size, string letters) Left-pads a string with another string to a certain length. string rpad(string a, int size, string letters) Reft-pads a string with another string to a certain length. string substr(string a, int pos, int count) Extract a substring from a string, starting at the specified position, extract the specified length characters. int hash(string a) Encode the data into an integer value. Explanations on the returns of function substr : If pos is 0, return an empty string. If the absolute value of pos is greater than the string, return an empty string. If pos is greater than 0, return substring in [pos, pos + count). If pos is less than 0, and set position N as length(a) + pos + 1, return substring in [N, N + count). If count is greater than length(a), return the whole string.","title":"Built-in string functions"},{"location":"3.ngql-guide/6.functions-and-expressions/3.date-and-time/","text":"Built-in date and time functions \u00b6 Nebula Graph supports the following built-in date and time functions: Function Description int now() Return the current date and time. date date() Return the current date based on the current system. time time() Return the current calendar time of the current time zone. datetime datetime() Return the current datetime based on the current time. The date(), time(), and datetime() functions accept three kind of parameters, namely empty, string, and map.","title":"Date and time"},{"location":"3.ngql-guide/6.functions-and-expressions/3.date-and-time/#built-in_date_and_time_functions","text":"Nebula Graph supports the following built-in date and time functions: Function Description int now() Return the current date and time. date date() Return the current date based on the current system. time time() Return the current calendar time of the current time zone. datetime datetime() Return the current datetime based on the current time. The date(), time(), and datetime() functions accept three kind of parameters, namely empty, string, and map.","title":"Built-in date and time functions"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/","text":"Built-in schema functions \u00b6 Nebula Graph supports the following built-in schema functions: Function Description id() Return the id of a vertex. tags() Return the tags of a vertex. labels() Return the tags of a vertex. map properties() Return the properties of a vertex or an edge. type() Return the edge types of an edge. string src() Return the source vertex ID of an edge. string dst() Return the destination vertex ID of an edge. int rank() Return the rank value of an edge.","title":"Schema"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#built-in_schema_functions","text":"Nebula Graph supports the following built-in schema functions: Function Description id() Return the id of a vertex. tags() Return the tags of a vertex. labels() Return the tags of a vertex. map properties() Return the properties of a vertex or an edge. type() Return the edge types of an edge. string src() Return the source vertex ID of an edge. string dst() Return the destination vertex ID of an edge. int rank() Return the rank value of an edge.","title":"Built-in schema functions"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/","text":"CASE expressions \u00b6 The CASE expression uses conditions to filter the result of an nGQL query statement. It is usually used in the YIELD or RETURN clause. nGQL provides two forms of CASE expressions just like openCypher: the simple form and the generic form. The CASE expression goes through conditions and returns a result when the first condition is met. Then the CASE expression stops reading the conditions and returns the result. If no conditions are met, it returns the result in the ELSE clause. If there is no ELSE clause and no conditions are met, it returns NULL . The following graph is used for the examples in this topic. The simple form of CASE expressions \u00b6 Syntax \u00b6 CASE <comparer> WHEN <value> THEN <result> [WHEN ...] [ELSE <default>] END CAUTION: Always remember to end a CASE expression with END . Parameters Description comparer A value or a valid expression that outputs a value. This value is used to compare with value . value It will be compared with comparer . If they match, then this condition is met. result It is returned by the CASE expression if value matches comparer . default It is returned by the CASE expression if no conditions are met. Examples \u00b6 Example 1: nebula> YIELD \\ CASE 2+3 \\ WHEN 4 THEN 0 \\ WHEN 5 THEN 1 \\ ELSE -1 \\ END \\ AS result; +--------+ | result | +--------+ | 1 | +--------+ Got 1 rows (time spent 188/583 us) Example 2: nebula> GO FROM \"player100\" OVER follow \\ YIELD $$.player.name AS Name, \\ CASE $$.player.age > 35 \\ WHEN true THEN \"Yes\" \\ WHEN false THEN \"No\" \\ ELSE \"Nah\" \\ END \\ AS Age_above_35; +---------------------+--------------+ | Name | Age_above_35 | +---------------------+--------------+ | \"Tony Parker\" | \"Yes\" | +---------------------+--------------+ | \"LaMarcus Aldridge\" | \"No\" | +---------------------+--------------+ Got 2 rows (time spent 3910/4348 us) The generic form of CASE expressions \u00b6 Syntax \u00b6 CASE WHEN <condition> THEN <result> [WHEN ...] [ELSE <default>] END Parameters Description condition If condition is evaluated as true, result is returned by the CASE expression. result It is returned by the CASE expression if condition is evaluated as true. default It is returned by the CASE expression if no conditions are met. Examples \u00b6 Example 1: nebula> YIELD \\ CASE WHEN 4 > 5 THEN 0 \\ WHEN 3+4==7 THEN 1 \\ ELSE 2 \\ END \\ AS result; +--------+ | result | +--------+ | 1 | +--------+ Got 1 rows (time spent 233/693 us) Example 2: nebula> MATCH (v:player) WHERE v.age > 30 \\ RETURN v.name AS Name, \\ CASE \\ WHEN v.name STARTS WITH \"T\" THEN \"Yes\" \\ ELSE \"No\" \\ END \\ AS Starts_with_T; +---------------------+---------------+ | Name | Starts_with_T | +---------------------+---------------+ | \"Tim\" | \"Yes\" | +---------------------+---------------+ | \"LaMarcus Aldridge\" | \"No\" | +---------------------+---------------+ | \"Tony Parker\" | \"Yes\" | +---------------------+---------------+ Got 3 rows (time spent 3859/4326 us) Differences between the simple form and the generic form \u00b6 To avoid the misuse of the simple form and the generic form, it is important to understand their differences. The following example can help explain them. nebula> GO FROM \"player100\" OVER follow \\ YIELD $$.player.name AS Name, $$.player.age AS Age, \\ CASE $$.player.age \\ WHEN $$.player.age > 35 THEN \"Yes\" \\ ELSE \"No\" \\ END \\ AS Age_above_35; +---------------------+-----+--------------+ | Name | Age | Age_above_35 | +---------------------+-----+--------------+ | \"Tony Parker\" | 36 | \"No\" | +---------------------+-----+--------------+ | \"LaMarcus Aldridge\" | 33 | \"No\" | +---------------------+-----+--------------+ Got 2 rows (time spent 2170/2642 us) The preceding GO query is intended to output \"Yes\" when the player age is above 35. However, in this example, when the player age is 36, the actual output is not as expected: It is \"No\" instead of \"Yes\". This is because the query uses the CASE expression in the simple form, and a comparison between the values of $$.player.age and $$.player.age > 35 is made. When the player age is 36: The value of $$.player.age is 36 . It is an integer. $$.player.age > 35 is evaluated to true . It is a boolean. The values of $$.player.age and $$.player.age > 35 do not match. This condition is not met and \"No\" is returned.","title":"Case expressions"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#case_expressions","text":"The CASE expression uses conditions to filter the result of an nGQL query statement. It is usually used in the YIELD or RETURN clause. nGQL provides two forms of CASE expressions just like openCypher: the simple form and the generic form. The CASE expression goes through conditions and returns a result when the first condition is met. Then the CASE expression stops reading the conditions and returns the result. If no conditions are met, it returns the result in the ELSE clause. If there is no ELSE clause and no conditions are met, it returns NULL . The following graph is used for the examples in this topic.","title":"CASE expressions"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#the_simple_form_of_case_expressions","text":"","title":"The simple form of CASE expressions"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#syntax","text":"CASE <comparer> WHEN <value> THEN <result> [WHEN ...] [ELSE <default>] END CAUTION: Always remember to end a CASE expression with END . Parameters Description comparer A value or a valid expression that outputs a value. This value is used to compare with value . value It will be compared with comparer . If they match, then this condition is met. result It is returned by the CASE expression if value matches comparer . default It is returned by the CASE expression if no conditions are met.","title":"Syntax"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#examples","text":"Example 1: nebula> YIELD \\ CASE 2+3 \\ WHEN 4 THEN 0 \\ WHEN 5 THEN 1 \\ ELSE -1 \\ END \\ AS result; +--------+ | result | +--------+ | 1 | +--------+ Got 1 rows (time spent 188/583 us) Example 2: nebula> GO FROM \"player100\" OVER follow \\ YIELD $$.player.name AS Name, \\ CASE $$.player.age > 35 \\ WHEN true THEN \"Yes\" \\ WHEN false THEN \"No\" \\ ELSE \"Nah\" \\ END \\ AS Age_above_35; +---------------------+--------------+ | Name | Age_above_35 | +---------------------+--------------+ | \"Tony Parker\" | \"Yes\" | +---------------------+--------------+ | \"LaMarcus Aldridge\" | \"No\" | +---------------------+--------------+ Got 2 rows (time spent 3910/4348 us)","title":"Examples"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#the_generic_form_of_case_expressions","text":"","title":"The generic form of CASE expressions"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#syntax_1","text":"CASE WHEN <condition> THEN <result> [WHEN ...] [ELSE <default>] END Parameters Description condition If condition is evaluated as true, result is returned by the CASE expression. result It is returned by the CASE expression if condition is evaluated as true. default It is returned by the CASE expression if no conditions are met.","title":"Syntax"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#examples_1","text":"Example 1: nebula> YIELD \\ CASE WHEN 4 > 5 THEN 0 \\ WHEN 3+4==7 THEN 1 \\ ELSE 2 \\ END \\ AS result; +--------+ | result | +--------+ | 1 | +--------+ Got 1 rows (time spent 233/693 us) Example 2: nebula> MATCH (v:player) WHERE v.age > 30 \\ RETURN v.name AS Name, \\ CASE \\ WHEN v.name STARTS WITH \"T\" THEN \"Yes\" \\ ELSE \"No\" \\ END \\ AS Starts_with_T; +---------------------+---------------+ | Name | Starts_with_T | +---------------------+---------------+ | \"Tim\" | \"Yes\" | +---------------------+---------------+ | \"LaMarcus Aldridge\" | \"No\" | +---------------------+---------------+ | \"Tony Parker\" | \"Yes\" | +---------------------+---------------+ Got 3 rows (time spent 3859/4326 us)","title":"Examples"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#differences_between_the_simple_form_and_the_generic_form","text":"To avoid the misuse of the simple form and the generic form, it is important to understand their differences. The following example can help explain them. nebula> GO FROM \"player100\" OVER follow \\ YIELD $$.player.name AS Name, $$.player.age AS Age, \\ CASE $$.player.age \\ WHEN $$.player.age > 35 THEN \"Yes\" \\ ELSE \"No\" \\ END \\ AS Age_above_35; +---------------------+-----+--------------+ | Name | Age | Age_above_35 | +---------------------+-----+--------------+ | \"Tony Parker\" | 36 | \"No\" | +---------------------+-----+--------------+ | \"LaMarcus Aldridge\" | 33 | \"No\" | +---------------------+-----+--------------+ Got 2 rows (time spent 2170/2642 us) The preceding GO query is intended to output \"Yes\" when the player age is above 35. However, in this example, when the player age is 36, the actual output is not as expected: It is \"No\" instead of \"Yes\". This is because the query uses the CASE expression in the simple form, and a comparison between the values of $$.player.age and $$.player.age > 35 is made. When the player age is 36: The value of $$.player.age is 36 . It is an integer. $$.player.age > 35 is evaluated to true . It is a boolean. The values of $$.player.age and $$.player.age > 35 do not match. This condition is not met and \"No\" is returned.","title":"Differences between the simple form and the generic form"},{"location":"3.ngql-guide/7.general-query-statements/2.match/","text":"MATCH \u00b6 The MATCH statement provides the searching ability based on pattern matching. A MATCH statement defines a search pattern and uses it to match data stored in the Nebula Graph database and to retrieve the data in the form defined in the RETURN clause. A WHERE clause is often used together with the pattern as a filter to the search result. Syntax \u00b6 The syntax of MATCH is relatively more flexible compared with that of other query statements such as GO or LOOKUP . But generally, it can be summarized as follows. MATCH <pattern> [<WHERE clause>] RETURN <output> Patterns and WHERE clauses \u00b6 The MATCH patterns, with the help of curly brackets (\"{}\"), can do the same thing with WHERE clauses when making equality comparisons. You may find an example as follows. NOTE : In nGQL, == is the equality operator and = is the assignment operator (as in C++ or Java). In openCypher 9, = is the equality operator. nebula> MATCH (v:player) WHERE v.name == \"Tim\" RETURN v.age AS Age; +-----+ | Age | +-----+ | 42 | +-----+ Got 1 rows (time spent 2849/3256 us) nebula> MATCH (v:player {name: \"Tim\"}) RETURN v.age AS Age; +-----+ | Age | +-----+ | 42 | +-----+ Got 1 rows (time spent 1924/2673 us) But besides equality comparisons, WHERE clauses can do a lot more than patterns in curly brackets. For more information, see WHERE [TODO]. Match modes \u00b6 Currently, MATCH supports the following modes. Match mode Description Match on property Uses specific properties to match the start vertices, then expand the pattern to match related edges or vertices if needed, and fetch data according to the RETURN statement at last. Match on ID Uses specific vertex IDs to match the start vertices, then expand the pattern to match related edges or vertices if needed, and fetch data according to the RETURN statement at last. Must-read for matching on property \u00b6 The MATCH statement is based on indexes. While parsing a MATCH statement, the Graph Service scans for properties with indexes in the curly brackets and the WHERE clause. Make sure there is at least one property with an Index, otherwise the parsing fails. No such attention is needed when matching on ID because the index for vertex IDs is created by default. Examples for matching on property \u00b6 Example 1: Search for a specific age and return the names of players of that age. The v is a user-defined variable that represents a vertex. nebula> MATCH (v:player {age: 36}) RETURN v.name AS Name; +-------------+ | Name | +-------------+ | Tony Parker | +-------------+ Got 1 rows (time spent 2849/3256 us) Example 2: Search for the players whose ages are above 30 and names start with \"T\", and return their names and ages. Use STARTS WITH or ENDS WITH to filter strings. nebula> MATCH (v:player) WHERE v.age > 30 AND v.name STARTS WITH \"T\" \\ RETURN v.name AS Name, v.age AS Age; +-------------+-----+ | Name | Age | +-------------+-----+ | Tony Parker | 36 | +-------------+-----+ | Tim | 42 | +-------------+-----+ Got 2 rows (time spent 2407/3244 us) Example 3: Search for the player whose name is \"Tim\", and return the player's relationships (edges) with others and the names of these people. The r is a user-defined variable that represents an edge. The type(e) function returns to the edge type. nebula> MATCH (v1:player{name: \"Tim\"}) -[e]-> (v2) \\ RETURN type(e) AS Relationship, v2.name AS Name; +--------------+-------------------+ | Relationship | Name | +--------------+-------------------+ | follow | Tony Parker | +--------------+-------------------+ | follow | LaMarcus Aldridge | +--------------+-------------------+ | serve | Warriors | +--------------+-------------------+ Got 3 rows (time spent 4844/6660 us) Example 3: Search for the team that \"Tim\" serves, and return the team name, the start year, and the end year. e:serve represents edges with the serve type. nebula> MATCH (v1:player{name: \"Tim\"}) -[e:serve]-> (v2) \\ RETURN v2.name AS Team_Name, e.start_year AS Start_Year, e.end_year AS End_Year; +-----------+------------+----------+ | Team_Name | Start_Year | End_Year | +-----------+------------+----------+ | Warriors | 1997 | 2016 | +-----------+------------+----------+ Got 1 rows (time spent 2768/3412 us) Example 4: Search for the player whose name is \"Tim\", find the people that \"Tim\" follows with age above 35 and the teams they serve, and return the names of the people and teams. nebula> MATCH (v1:player) -[:follow]-> (v2) -[:serve]-> (v3) \\ WHERE v1.name == \"Tim\" AND v2.age > 35 \\ RETURN v1.name AS Player, v2.name AS Friend, v3.name AS Friends_Team; +--------+-------------+--------------+ | Player | Friend | Friends_Team | +--------+-------------+--------------+ | Tim | Tony Parker | Nuggets | +--------+-------------+--------------+ Got 1 rows (time spent 3623/4220 us) Examples for matching on ID \u00b6 Example 1: Search for the vertex with VID \"player100\" and return all its information. NOTE : In nGQL, id() returns a vertex ID, which is a string. In openCypher 9, id() returns an integer. nebula> MATCH (v) WHERE id(v) == 'player101' RETURN v; +---------------------------------------------------+ | v | +---------------------------------------------------+ | (player101) player.name:Tony Parker,player.age:36 | +---------------------------------------------------+ Got 1 rows (time spent 1710/2406 us) Example 2: Search for the vertices with VIDs in a specific list and return all their information. A non-existing VID returns nothing. nebula> MATCH (v) WHERE id(v) IN ['player100', 'player101', 'no_one'] RETURN v; +---------------------------------------------------+ | v | +---------------------------------------------------+ | (player101) player.name:Tony Parker,player.age:36 | +---------------------------------------------------+ | (player100) player.name:Tim,player.age:42 | +---------------------------------------------------+ Got 2 rows (time spent 1307/2079 us) Example 3: Search for the players with age above 35, and return the VID of the vertices representing these players. nebula> MATCH (v:player) WHERE v.age > 35 RETURN v.name AS Name, id(v) AS VID; +---------------------+-------------+ | Name | VID | +---------------------+-------------+ | \"Steve Nash\" | \"player136\" | +---------------------+-------------+ | \"Amar'e Stoudemire\" | \"player147\" | +---------------------+-------------+ | \"Vince Carter\" | \"player127\" | +---------------------+-------------+ | \"Jason Kidd\" | \"player148\" | +---------------------+-------------+ | \"Dwyane Wade\" | \"player129\" | +---------------------+-------------+ | \"Paul Gasol\" | \"player138\" | +---------------------+-------------+","title":"Match"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match","text":"The MATCH statement provides the searching ability based on pattern matching. A MATCH statement defines a search pattern and uses it to match data stored in the Nebula Graph database and to retrieve the data in the form defined in the RETURN clause. A WHERE clause is often used together with the pattern as a filter to the search result.","title":"MATCH"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#syntax","text":"The syntax of MATCH is relatively more flexible compared with that of other query statements such as GO or LOOKUP . But generally, it can be summarized as follows. MATCH <pattern> [<WHERE clause>] RETURN <output>","title":"Syntax"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#patterns_and_where_clauses","text":"The MATCH patterns, with the help of curly brackets (\"{}\"), can do the same thing with WHERE clauses when making equality comparisons. You may find an example as follows. NOTE : In nGQL, == is the equality operator and = is the assignment operator (as in C++ or Java). In openCypher 9, = is the equality operator. nebula> MATCH (v:player) WHERE v.name == \"Tim\" RETURN v.age AS Age; +-----+ | Age | +-----+ | 42 | +-----+ Got 1 rows (time spent 2849/3256 us) nebula> MATCH (v:player {name: \"Tim\"}) RETURN v.age AS Age; +-----+ | Age | +-----+ | 42 | +-----+ Got 1 rows (time spent 1924/2673 us) But besides equality comparisons, WHERE clauses can do a lot more than patterns in curly brackets. For more information, see WHERE [TODO].","title":"Patterns and WHERE clauses"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_modes","text":"Currently, MATCH supports the following modes. Match mode Description Match on property Uses specific properties to match the start vertices, then expand the pattern to match related edges or vertices if needed, and fetch data according to the RETURN statement at last. Match on ID Uses specific vertex IDs to match the start vertices, then expand the pattern to match related edges or vertices if needed, and fetch data according to the RETURN statement at last.","title":"Match modes"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#must-read_for_matching_on_property","text":"The MATCH statement is based on indexes. While parsing a MATCH statement, the Graph Service scans for properties with indexes in the curly brackets and the WHERE clause. Make sure there is at least one property with an Index, otherwise the parsing fails. No such attention is needed when matching on ID because the index for vertex IDs is created by default.","title":"Must-read for matching on property"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#examples_for_matching_on_property","text":"Example 1: Search for a specific age and return the names of players of that age. The v is a user-defined variable that represents a vertex. nebula> MATCH (v:player {age: 36}) RETURN v.name AS Name; +-------------+ | Name | +-------------+ | Tony Parker | +-------------+ Got 1 rows (time spent 2849/3256 us) Example 2: Search for the players whose ages are above 30 and names start with \"T\", and return their names and ages. Use STARTS WITH or ENDS WITH to filter strings. nebula> MATCH (v:player) WHERE v.age > 30 AND v.name STARTS WITH \"T\" \\ RETURN v.name AS Name, v.age AS Age; +-------------+-----+ | Name | Age | +-------------+-----+ | Tony Parker | 36 | +-------------+-----+ | Tim | 42 | +-------------+-----+ Got 2 rows (time spent 2407/3244 us) Example 3: Search for the player whose name is \"Tim\", and return the player's relationships (edges) with others and the names of these people. The r is a user-defined variable that represents an edge. The type(e) function returns to the edge type. nebula> MATCH (v1:player{name: \"Tim\"}) -[e]-> (v2) \\ RETURN type(e) AS Relationship, v2.name AS Name; +--------------+-------------------+ | Relationship | Name | +--------------+-------------------+ | follow | Tony Parker | +--------------+-------------------+ | follow | LaMarcus Aldridge | +--------------+-------------------+ | serve | Warriors | +--------------+-------------------+ Got 3 rows (time spent 4844/6660 us) Example 3: Search for the team that \"Tim\" serves, and return the team name, the start year, and the end year. e:serve represents edges with the serve type. nebula> MATCH (v1:player{name: \"Tim\"}) -[e:serve]-> (v2) \\ RETURN v2.name AS Team_Name, e.start_year AS Start_Year, e.end_year AS End_Year; +-----------+------------+----------+ | Team_Name | Start_Year | End_Year | +-----------+------------+----------+ | Warriors | 1997 | 2016 | +-----------+------------+----------+ Got 1 rows (time spent 2768/3412 us) Example 4: Search for the player whose name is \"Tim\", find the people that \"Tim\" follows with age above 35 and the teams they serve, and return the names of the people and teams. nebula> MATCH (v1:player) -[:follow]-> (v2) -[:serve]-> (v3) \\ WHERE v1.name == \"Tim\" AND v2.age > 35 \\ RETURN v1.name AS Player, v2.name AS Friend, v3.name AS Friends_Team; +--------+-------------+--------------+ | Player | Friend | Friends_Team | +--------+-------------+--------------+ | Tim | Tony Parker | Nuggets | +--------+-------------+--------------+ Got 1 rows (time spent 3623/4220 us)","title":"Examples for matching on property"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#examples_for_matching_on_id","text":"Example 1: Search for the vertex with VID \"player100\" and return all its information. NOTE : In nGQL, id() returns a vertex ID, which is a string. In openCypher 9, id() returns an integer. nebula> MATCH (v) WHERE id(v) == 'player101' RETURN v; +---------------------------------------------------+ | v | +---------------------------------------------------+ | (player101) player.name:Tony Parker,player.age:36 | +---------------------------------------------------+ Got 1 rows (time spent 1710/2406 us) Example 2: Search for the vertices with VIDs in a specific list and return all their information. A non-existing VID returns nothing. nebula> MATCH (v) WHERE id(v) IN ['player100', 'player101', 'no_one'] RETURN v; +---------------------------------------------------+ | v | +---------------------------------------------------+ | (player101) player.name:Tony Parker,player.age:36 | +---------------------------------------------------+ | (player100) player.name:Tim,player.age:42 | +---------------------------------------------------+ Got 2 rows (time spent 1307/2079 us) Example 3: Search for the players with age above 35, and return the VID of the vertices representing these players. nebula> MATCH (v:player) WHERE v.age > 35 RETURN v.name AS Name, id(v) AS VID; +---------------------+-------------+ | Name | VID | +---------------------+-------------+ | \"Steve Nash\" | \"player136\" | +---------------------+-------------+ | \"Amar'e Stoudemire\" | \"player147\" | +---------------------+-------------+ | \"Vince Carter\" | \"player127\" | +---------------------+-------------+ | \"Jason Kidd\" | \"player148\" | +---------------------+-------------+ | \"Dwyane Wade\" | \"player129\" | +---------------------+-------------+ | \"Paul Gasol\" | \"player138\" | +---------------------+-------------+","title":"Examples for matching on ID"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/","text":"LOOKUP \u00b6 The LOOKUP statement retrieves data based on indexes. You can use LOOKUP for the following purposes: Search for the specific data based on conditions defined by the WHERE clause. List vertices with a tag: retrieve the VID of all vertices with a tag. List edges with an edge type: retrieve the source Vertex IDs, destination vertex IDs, and ranks of all edges with an edge type. Count the number of vertices or edges with a tag or an edge type. Prerequisites \u00b6 Before using the LOOKUP statement, make sure that relative indexes are created. For how to create indexes, see CREATE INDEX . Syntax \u00b6 LOOKUP ON {<vertex_tag> | <edge_type>} [WHERE <expression> [AND <expression> ...]] [YIELD <return_list>] <return_list> <prop_name> [AS <col_alias>] [, <prop_name> [AS <prop_alias>] ...] The WHERE clause filters data with the specified conditions. Both AND and OR are supported between different expressions. For more information, see WHERE (doc TODO). The YIELD clause specifies the results to be returned and the format of the results. It is not supported when there is no WHERE clause. If there is a WHERE clause but no YIELD clause: The Vertex ID is returned when LOOKUP a tag. The source vertex ID, destination vertex ID, and rank of the edge is returned when LOOKUP an edge type. Limitations of using WHERE in LOOKUP \u00b6 The WHERE clause in a LOOKUP statement does not support the following operations: $- and $^ . In relational expressions, expressions with field names on both sides of the operator are not supported, such as tagName.prop1> tagName.prop2 . Nested AliasProp expressions in operation expressions and function expressions are not supported. Range scan is not supported in the string-type index. The OR and XOR operations are not supported. Retrieve Vertices \u00b6 The following example returns vertices whose name is Tony Parker and tagged with player . nebula> CREATE TAG INDEX index_player ON player(name, age); nebula> LOOKUP ON player WHERE player.name == \"Tony Parker\"; ============ | VertexID | ============ | 101 | ------------ nebula> LOOKUP ON player WHERE player.name == \"Tony Parker\" \\ YIELD player.name, player.age; ======================================= | VertexID | player.name | player.age | ======================================= | 101 | Tony Parker | 36 | --------------------------------------- nebula> LOOKUP ON player WHERE player.name== \"Kobe Bryant\" YIELD player.name AS name | \\ GO FROM $-.VertexID OVER serve YIELD $-.name, serve.start_year, serve.end_year, $$.team.name; ================================================================== | $-.name | serve.start_year | serve.end_year | $$.team.name | ================================================================== | Kobe Bryant | 1996 | 2016 | Lakers | ------------------------------------------------------------------ Retrieve Edges \u00b6 The following example returns edges whose degree is 90 and the edge type is follow . nebula> CREATE EDGE INDEX index_follow ON follow(degree); nebula> LOOKUP ON follow WHERE follow.degree == 90; ============================= | SrcVID | DstVID | Ranking | ============================= | 100 | 106 | 0 | ----------------------------- nebula> LOOKUP ON follow WHERE follow.degree == 90 YIELD follow.degree; ============================================= | SrcVID | DstVID | Ranking | follow.degree | ============================================= | 100 | 106 | 0 | 90 | --------------------------------------------- nebula> LOOKUP ON follow WHERE follow.degree == 60 YIELD follow.degree AS Degree | \\ GO FROM $-.DstVID OVER serve YIELD $-.DstVID, serve.start_year, serve.end_year, $$.team.name; ================================================================ | $-.DstVID | serve.start_year | serve.end_year | $$.team.name | ================================================================ | 105 | 2010 | 2018 | Spurs | ---------------------------------------------------------------- | 105 | 2009 | 2010 | Cavaliers | ---------------------------------------------------------------- | 105 | 2018 | 2019 | Raptors | ---------------------------------------------------------------- List vertices or edges with a tag or an edge type \u00b6 To list vertices or edges with a tag or an edge type, at least one index must exist on the tag or the edge type, or its property. For example, if there is a player tag with a name property and an age property, to retrieve the VID of all vertices tagged with player , there has to be an index on the player tag itself, the name property, or the age property. The following example shows how to retrieve the VID of all vertices tagged with player . nebula> CREATE TAG player(name string,age int); Execution succeeded (time spent 3235/3865 us) nebula> CREATE TAG INDEX player_index on player(); Execution succeeded (time spent 3486/4124 us) nebula> INSERT VERTEX player(name,age) VALUES \"player100\":(\"Tim Duncan\", 42), \"player101\":(\"Tony Parker\", 36); Execution succeeded (time spent 1695/2268 us) nebula> LOOKUP ON player; +-------------+ | _vid | +-------------+ | \"player100\" | +-------------+ | \"player101\" | +-------------+ Got 2 rows (time spent 1514/2070 us) The following example shows how to retrieve the source Vertex IDs, destination vertex IDs, and ranks of all edges of the like edge type. nebula)> CREATE EDGE like(likeness int); Execution succeeded (time spent 3710/4483 us) nebula)> CREATE EDGE INDEX like_index on like(); Execution succeeded (time spent 3422/4026 us) nebula)> INSERT EDGE like(likeness) values \"player100\"->\"player101\":(95); Execution succeeded (time spent 1638/2351 us) nebula)> LOOKUP ON like; +-------------+----------+-------------+ | _src | _ranking | _dst | +-------------+----------+-------------+ | \"player100\" | 0 | \"player101\" | +-------------+----------+-------------+ Got 1 rows (time spent 1163/1748 us) Count the numbers of vertices or edges \u00b6 The following example shows how to count the number of vertices tagged with player and edges of the like edge type. nebula> LOOKUP ON player | YIELD COUNT(*) AS Player_Number; +---------------+ | Player_Number | +---------------+ | 2 | +---------------+ Got 1 rows (time spent 1158/1864 us) nebula> LOOKUP ON like | YIELD COUNT(*) AS Like_Number; +-------------+ | Like_Number | +-------------+ | 1 | +-------------+ Got 1 rows (time spent 1190/1970 us) FAQ \u00b6 Error code 411 \u00b6 [ ERROR ( -8 )] : Unknown error ( 411 ) : Error code 411 shows there is no valid index for the current WHERE filter. Nebula Graph uses the left matching mode to select indexes. That is, columns in the WHERE filter must be in the first N columns of the index. For example: nebula> CREATE TAG INDEX example_index ON TAG t(p1, p2, p3); -- Create an index for the first 3 properties of tag t nebula> LOOKUP ON t WHERE p2 == 1 and p3 == 1; -- Not supported nebula> LOOKUP ON t WHERE p1 == 1; -- Supported nebula> LOOKUP ON t WHERE p1 == 1 and p2 == 1; -- Supported nebula> LOOKUP ON t WHERE p1 == 1 and p2 == 1 and p3 == 1; -- Supported No valid index found \u00b6 No valid index found If your query filter contains a string type field, Nebula Graph selects the index that matches all the fields. For example: nebula> CREATE TAG t1 (c1 string, c2 int); nebula> CREATE TAG INDEX i1 ON t1 (c1, c2); nebula> LOOKUP ON t1 WHERE t1.c1 == \"a\"; -- Index i1 is invalid nebula> LOOKUP ON t1 WHERE t1.c1 == \"a\" and t1.c2 == 1; -- Index i1 is valid","title":"LOOKUP"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#lookup","text":"The LOOKUP statement retrieves data based on indexes. You can use LOOKUP for the following purposes: Search for the specific data based on conditions defined by the WHERE clause. List vertices with a tag: retrieve the VID of all vertices with a tag. List edges with an edge type: retrieve the source Vertex IDs, destination vertex IDs, and ranks of all edges with an edge type. Count the number of vertices or edges with a tag or an edge type.","title":"LOOKUP"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#prerequisites","text":"Before using the LOOKUP statement, make sure that relative indexes are created. For how to create indexes, see CREATE INDEX .","title":"Prerequisites"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#syntax","text":"LOOKUP ON {<vertex_tag> | <edge_type>} [WHERE <expression> [AND <expression> ...]] [YIELD <return_list>] <return_list> <prop_name> [AS <col_alias>] [, <prop_name> [AS <prop_alias>] ...] The WHERE clause filters data with the specified conditions. Both AND and OR are supported between different expressions. For more information, see WHERE (doc TODO). The YIELD clause specifies the results to be returned and the format of the results. It is not supported when there is no WHERE clause. If there is a WHERE clause but no YIELD clause: The Vertex ID is returned when LOOKUP a tag. The source vertex ID, destination vertex ID, and rank of the edge is returned when LOOKUP an edge type.","title":"Syntax"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#limitations_of_using_where_in_lookup","text":"The WHERE clause in a LOOKUP statement does not support the following operations: $- and $^ . In relational expressions, expressions with field names on both sides of the operator are not supported, such as tagName.prop1> tagName.prop2 . Nested AliasProp expressions in operation expressions and function expressions are not supported. Range scan is not supported in the string-type index. The OR and XOR operations are not supported.","title":"Limitations of using WHERE in LOOKUP"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#retrieve_vertices","text":"The following example returns vertices whose name is Tony Parker and tagged with player . nebula> CREATE TAG INDEX index_player ON player(name, age); nebula> LOOKUP ON player WHERE player.name == \"Tony Parker\"; ============ | VertexID | ============ | 101 | ------------ nebula> LOOKUP ON player WHERE player.name == \"Tony Parker\" \\ YIELD player.name, player.age; ======================================= | VertexID | player.name | player.age | ======================================= | 101 | Tony Parker | 36 | --------------------------------------- nebula> LOOKUP ON player WHERE player.name== \"Kobe Bryant\" YIELD player.name AS name | \\ GO FROM $-.VertexID OVER serve YIELD $-.name, serve.start_year, serve.end_year, $$.team.name; ================================================================== | $-.name | serve.start_year | serve.end_year | $$.team.name | ================================================================== | Kobe Bryant | 1996 | 2016 | Lakers | ------------------------------------------------------------------","title":"Retrieve Vertices"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#retrieve_edges","text":"The following example returns edges whose degree is 90 and the edge type is follow . nebula> CREATE EDGE INDEX index_follow ON follow(degree); nebula> LOOKUP ON follow WHERE follow.degree == 90; ============================= | SrcVID | DstVID | Ranking | ============================= | 100 | 106 | 0 | ----------------------------- nebula> LOOKUP ON follow WHERE follow.degree == 90 YIELD follow.degree; ============================================= | SrcVID | DstVID | Ranking | follow.degree | ============================================= | 100 | 106 | 0 | 90 | --------------------------------------------- nebula> LOOKUP ON follow WHERE follow.degree == 60 YIELD follow.degree AS Degree | \\ GO FROM $-.DstVID OVER serve YIELD $-.DstVID, serve.start_year, serve.end_year, $$.team.name; ================================================================ | $-.DstVID | serve.start_year | serve.end_year | $$.team.name | ================================================================ | 105 | 2010 | 2018 | Spurs | ---------------------------------------------------------------- | 105 | 2009 | 2010 | Cavaliers | ---------------------------------------------------------------- | 105 | 2018 | 2019 | Raptors | ----------------------------------------------------------------","title":"Retrieve Edges"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#list_vertices_or_edges_with_a_tag_or_an_edge_type","text":"To list vertices or edges with a tag or an edge type, at least one index must exist on the tag or the edge type, or its property. For example, if there is a player tag with a name property and an age property, to retrieve the VID of all vertices tagged with player , there has to be an index on the player tag itself, the name property, or the age property. The following example shows how to retrieve the VID of all vertices tagged with player . nebula> CREATE TAG player(name string,age int); Execution succeeded (time spent 3235/3865 us) nebula> CREATE TAG INDEX player_index on player(); Execution succeeded (time spent 3486/4124 us) nebula> INSERT VERTEX player(name,age) VALUES \"player100\":(\"Tim Duncan\", 42), \"player101\":(\"Tony Parker\", 36); Execution succeeded (time spent 1695/2268 us) nebula> LOOKUP ON player; +-------------+ | _vid | +-------------+ | \"player100\" | +-------------+ | \"player101\" | +-------------+ Got 2 rows (time spent 1514/2070 us) The following example shows how to retrieve the source Vertex IDs, destination vertex IDs, and ranks of all edges of the like edge type. nebula)> CREATE EDGE like(likeness int); Execution succeeded (time spent 3710/4483 us) nebula)> CREATE EDGE INDEX like_index on like(); Execution succeeded (time spent 3422/4026 us) nebula)> INSERT EDGE like(likeness) values \"player100\"->\"player101\":(95); Execution succeeded (time spent 1638/2351 us) nebula)> LOOKUP ON like; +-------------+----------+-------------+ | _src | _ranking | _dst | +-------------+----------+-------------+ | \"player100\" | 0 | \"player101\" | +-------------+----------+-------------+ Got 1 rows (time spent 1163/1748 us)","title":"List vertices or edges with a tag or an edge type"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#count_the_numbers_of_vertices_or_edges","text":"The following example shows how to count the number of vertices tagged with player and edges of the like edge type. nebula> LOOKUP ON player | YIELD COUNT(*) AS Player_Number; +---------------+ | Player_Number | +---------------+ | 2 | +---------------+ Got 1 rows (time spent 1158/1864 us) nebula> LOOKUP ON like | YIELD COUNT(*) AS Like_Number; +-------------+ | Like_Number | +-------------+ | 1 | +-------------+ Got 1 rows (time spent 1190/1970 us)","title":"Count the numbers of vertices or edges"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#faq","text":"","title":"FAQ"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#error_code_411","text":"[ ERROR ( -8 )] : Unknown error ( 411 ) : Error code 411 shows there is no valid index for the current WHERE filter. Nebula Graph uses the left matching mode to select indexes. That is, columns in the WHERE filter must be in the first N columns of the index. For example: nebula> CREATE TAG INDEX example_index ON TAG t(p1, p2, p3); -- Create an index for the first 3 properties of tag t nebula> LOOKUP ON t WHERE p2 == 1 and p3 == 1; -- Not supported nebula> LOOKUP ON t WHERE p1 == 1; -- Supported nebula> LOOKUP ON t WHERE p1 == 1 and p2 == 1; -- Supported nebula> LOOKUP ON t WHERE p1 == 1 and p2 == 1 and p3 == 1; -- Supported","title":"Error code 411"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#no_valid_index_found","text":"No valid index found If your query filter contains a string type field, Nebula Graph selects the index that matches all the fields. For example: nebula> CREATE TAG t1 (c1 string, c2 int); nebula> CREATE TAG INDEX i1 ON t1 (c1, c2); nebula> LOOKUP ON t1 WHERE t1.c1 == \"a\"; -- Index i1 is invalid nebula> LOOKUP ON t1 WHERE t1.c1 == \"a\" and t1.c2 == 1; -- Index i1 is valid","title":"No valid index found"},{"location":"3.ngql-guide/7.general-query-statements/6.show/14.show-stats/","text":"SHOW STATS \u00b6 The SHOW STATS statement shows the statistics of the graph space collected by the latest STATS job. The statistics list the following information: The number of vertices and edges in the graph space The number of vertices with each tag The number of edges of each edge type Prerequisites \u00b6 You have successfully run the SUBMIT JOB STATS statement in the graph space you want to collect statistics. For more information, see SUBMIT JOB STATS . NOTE: The result of the SHOW STATS statement is based on the last executed SUBMIT JOB STATS statement. If you want to update the result, run SUBMIT JOB STATS again. Syntax \u00b6 SHOW STATS Example \u00b6 nebula> USE nba; Execution succeeded (time spent 1075/1646 us) --Start a `STATS` job. nebula> SUBMIT JOB STATS; +------------+ | New Job Id | +------------+ | 98 | +------------+ Got 1 rows (time spent 2058/2609 us) --Make sure the job is finished. nebula> SHOW JOB 98; +----------------+---------------+------------+------------+------------+ | Job Id(TaskId) | Command(Dest) | Status | Start Time | Stop Time | +----------------+---------------+------------+------------+------------+ | 98 | \"STATS\" | \"FINISHED\" | 1606552675 | 1606552675 | +----------------+---------------+------------+------------+------------+ | 0 | \"storaged2\" | \"FINISHED\" | 1606552675 | 1606552675 | +----------------+---------------+------------+------------+------------+ | 1 | \"storaged0\" | \"FINISHED\" | 1606552675 | 1606552675 | +----------------+---------------+------------+------------+------------+ | 2 | \"storaged1\" | \"FINISHED\" | 1606552675 | 1606552675 | +----------------+---------------+------------+------------+------------+ Got 4 rows (time spent 1233/1924 us) --Check the statistics. nebula> SHOW STATS; +---------+------------+-------+ | Type | Name | Count | +---------+------------+-------+ | \"Tag\" | \"player\" | 51 | +---------+------------+-------+ | \"Tag\" | \"team\" | 30 | +---------+------------+-------+ | \"Edge\" | \"like\" | 81 | +---------+------------+-------+ | \"Edge\" | \"serve\" | 152 | +---------+------------+-------+ | \"Space\" | \"vertices\" | 81 | +---------+------------+-------+ | \"Space\" | \"edges\" | 233 | +---------+------------+-------+ Got 6 rows (time spent 996/1637 us)","title":"SHOW STATS"},{"location":"3.ngql-guide/7.general-query-statements/6.show/14.show-stats/#show_stats","text":"The SHOW STATS statement shows the statistics of the graph space collected by the latest STATS job. The statistics list the following information: The number of vertices and edges in the graph space The number of vertices with each tag The number of edges of each edge type","title":"SHOW STATS"},{"location":"3.ngql-guide/7.general-query-statements/6.show/14.show-stats/#prerequisites","text":"You have successfully run the SUBMIT JOB STATS statement in the graph space you want to collect statistics. For more information, see SUBMIT JOB STATS . NOTE: The result of the SHOW STATS statement is based on the last executed SUBMIT JOB STATS statement. If you want to update the result, run SUBMIT JOB STATS again.","title":"Prerequisites"},{"location":"3.ngql-guide/7.general-query-statements/6.show/14.show-stats/#syntax","text":"SHOW STATS","title":"Syntax"},{"location":"3.ngql-guide/7.general-query-statements/6.show/14.show-stats/#example","text":"nebula> USE nba; Execution succeeded (time spent 1075/1646 us) --Start a `STATS` job. nebula> SUBMIT JOB STATS; +------------+ | New Job Id | +------------+ | 98 | +------------+ Got 1 rows (time spent 2058/2609 us) --Make sure the job is finished. nebula> SHOW JOB 98; +----------------+---------------+------------+------------+------------+ | Job Id(TaskId) | Command(Dest) | Status | Start Time | Stop Time | +----------------+---------------+------------+------------+------------+ | 98 | \"STATS\" | \"FINISHED\" | 1606552675 | 1606552675 | +----------------+---------------+------------+------------+------------+ | 0 | \"storaged2\" | \"FINISHED\" | 1606552675 | 1606552675 | +----------------+---------------+------------+------------+------------+ | 1 | \"storaged0\" | \"FINISHED\" | 1606552675 | 1606552675 | +----------------+---------------+------------+------------+------------+ | 2 | \"storaged1\" | \"FINISHED\" | 1606552675 | 1606552675 | +----------------+---------------+------------+------------+------------+ Got 4 rows (time spent 1233/1924 us) --Check the statistics. nebula> SHOW STATS; +---------+------------+-------+ | Type | Name | Count | +---------+------------+-------+ | \"Tag\" | \"player\" | 51 | +---------+------------+-------+ | \"Tag\" | \"team\" | 30 | +---------+------------+-------+ | \"Edge\" | \"like\" | 81 | +---------+------------+-------+ | \"Edge\" | \"serve\" | 152 | +---------+------------+-------+ | \"Space\" | \"vertices\" | 81 | +---------+------------+-------+ | \"Space\" | \"edges\" | 233 | +---------+------------+-------+ Got 6 rows (time spent 996/1637 us)","title":"Example"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/","text":"CREATE SPACE \u00b6 CREATE SPACE [IF NOT EXISTS] <graph_space_name> [(partition_num = <partition_number>, replica_factor = <replica_number>, charset = <charset>, collate = <collate>, vid_type = FIXED_STRING(<max_string_length>))] The CREATE SPACE statement creates a new graph space with the given name. A SPACE is a region that provides physically isolated graphs in Nebula Graph. An error occurs if a graph space with the same name exists if you did not specify IF NOT EXISTS . IF NOT EXISTS \u00b6 You can use the IF NOT EXISTS keywords when creating graph spaces. These keywords automatically detects if the related graph space exists. If it does not exist, a new one is created. Otherwise, no graph space is created. NOTE : The graph space existence detection here only compares the graph space name (excluding properties). Graph space name \u00b6 The graph_space_name uniquely identifies a graph space in a Nebula Graph instance. Customized graph space options \u00b6 You can set four optional options for a new graph space: partition_num Specifies the number of partitions in each replica. The suggested number is five times the number of the hard disks in the cluster. For example, if you have 3 hard disks in the cluster, we recommend that you set 15 partitions. replica_factor Specifies the number of replicas in the cluster. The default replica factor is 1. The suggested number is 3 in a production environment and 1 in a test environment. Always set the replica to an odd number for the need of quorum-based voting. charset Short for character set. A character set is a set of symbols and encodings. The default value is utf8 . collate A set of rules for comparing characters in a character set. The default value is utf8_bin . vid_type Specifies the data type of vertex IDs (VIDs) in a graph space. In Nebula Graph 2.0.0-alpha, only fixed_string(N) is valid, indicating VIDs must be string type. N represents the maximum length of the VIDs. You must set the fixed_string to a positive integer. The default value is 8. If your VID length is greater than the maximum VID length, Nebula Graph throws an error. If no option is given, Nebula Graph creates the graph space with the default options. Example \u00b6 nebula> CREATE SPACE my_space_1; -- create a graph space with default options nebula> CREATE SPACE my_space_2(partition_num=10); -- create a graph space with customized partition number nebula> CREATE SPACE my_space_3(replica_factor=1); -- create a graph space with customized replica factor nebula> CREATE SPACE my_space_4(vid_type = FIXED_STRING(30)); -- create a graph space with customized VID maximum length Check partition distribution \u00b6 On some large clusters, the partition distribution is possibly unbalanced because of the different startup time. You can run the command to do a check of the machine distribution. nebula> SHOW HOSTS; +-----------+-------+--------+--------------+---------------------+------------------------+ | Host | Port | Status | Leader count | Leader distribution | Partition distribution | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged0 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged1 | 44500 | ONLINE | 2 | test:1, nba:5 | nba:5, test:1 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged2 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ To balance the request loads, use the following command. nebula> BALANCE LEADER;","title":"CREATE SPACE"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/#create_space","text":"CREATE SPACE [IF NOT EXISTS] <graph_space_name> [(partition_num = <partition_number>, replica_factor = <replica_number>, charset = <charset>, collate = <collate>, vid_type = FIXED_STRING(<max_string_length>))] The CREATE SPACE statement creates a new graph space with the given name. A SPACE is a region that provides physically isolated graphs in Nebula Graph. An error occurs if a graph space with the same name exists if you did not specify IF NOT EXISTS .","title":"CREATE SPACE"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/#if_not_exists","text":"You can use the IF NOT EXISTS keywords when creating graph spaces. These keywords automatically detects if the related graph space exists. If it does not exist, a new one is created. Otherwise, no graph space is created. NOTE : The graph space existence detection here only compares the graph space name (excluding properties).","title":"IF NOT EXISTS"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/#graph_space_name","text":"The graph_space_name uniquely identifies a graph space in a Nebula Graph instance.","title":"Graph space name"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/#customized_graph_space_options","text":"You can set four optional options for a new graph space: partition_num Specifies the number of partitions in each replica. The suggested number is five times the number of the hard disks in the cluster. For example, if you have 3 hard disks in the cluster, we recommend that you set 15 partitions. replica_factor Specifies the number of replicas in the cluster. The default replica factor is 1. The suggested number is 3 in a production environment and 1 in a test environment. Always set the replica to an odd number for the need of quorum-based voting. charset Short for character set. A character set is a set of symbols and encodings. The default value is utf8 . collate A set of rules for comparing characters in a character set. The default value is utf8_bin . vid_type Specifies the data type of vertex IDs (VIDs) in a graph space. In Nebula Graph 2.0.0-alpha, only fixed_string(N) is valid, indicating VIDs must be string type. N represents the maximum length of the VIDs. You must set the fixed_string to a positive integer. The default value is 8. If your VID length is greater than the maximum VID length, Nebula Graph throws an error. If no option is given, Nebula Graph creates the graph space with the default options.","title":"Customized graph space options"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/#example","text":"nebula> CREATE SPACE my_space_1; -- create a graph space with default options nebula> CREATE SPACE my_space_2(partition_num=10); -- create a graph space with customized partition number nebula> CREATE SPACE my_space_3(replica_factor=1); -- create a graph space with customized replica factor nebula> CREATE SPACE my_space_4(vid_type = FIXED_STRING(30)); -- create a graph space with customized VID maximum length","title":"Example"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/#check_partition_distribution","text":"On some large clusters, the partition distribution is possibly unbalanced because of the different startup time. You can run the command to do a check of the machine distribution. nebula> SHOW HOSTS; +-----------+-------+--------+--------------+---------------------+------------------------+ | Host | Port | Status | Leader count | Leader distribution | Partition distribution | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged0 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged1 | 44500 | ONLINE | 2 | test:1, nba:5 | nba:5, test:1 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged2 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ To balance the request loads, use the following command. nebula> BALANCE LEADER;","title":"Check partition distribution"},{"location":"3.ngql-guide/9.space-statements.md/2.use-space/","text":"USE \u00b6 USE <graph_space_name> The USE statement specifies a graph space as the current working space for subsequent queries. To manage multiple graph spaces, use the USE statement. The USE statement requires some privileges. (TODO: authentication doc) The graph space remains the same unless another USE statement is executed. nebula> USE space1; -- Traverse in graph space1. nebula> GO FROM 1 OVER edge1; nebula> USE space2; -- Traverse in graph space2. These vertices and edges have no relevance with space1. nebula> GO FROM 2 OVER edge2; -- Now you are back to space1. Hereafter, you can not read any data from space2. nebula> USE space1; Different from SQL, making a graph space as the working graph space prevents you from accessing other spaces. The only way to traverse in a new graph space is to switch by the USE statement. Graph spaces are FULLY ISOLATED from each other. Unlike MySQL, you can only use one graph space at a time in Nebula Graph. But in MySQL, you can select two tables from different databases in one statement.","title":"USE SPACE"},{"location":"3.ngql-guide/9.space-statements.md/2.use-space/#use","text":"USE <graph_space_name> The USE statement specifies a graph space as the current working space for subsequent queries. To manage multiple graph spaces, use the USE statement. The USE statement requires some privileges. (TODO: authentication doc) The graph space remains the same unless another USE statement is executed. nebula> USE space1; -- Traverse in graph space1. nebula> GO FROM 1 OVER edge1; nebula> USE space2; -- Traverse in graph space2. These vertices and edges have no relevance with space1. nebula> GO FROM 2 OVER edge2; -- Now you are back to space1. Hereafter, you can not read any data from space2. nebula> USE space1; Different from SQL, making a graph space as the working graph space prevents you from accessing other spaces. The only way to traverse in a new graph space is to switch by the USE statement. Graph spaces are FULLY ISOLATED from each other. Unlike MySQL, you can only use one graph space at a time in Nebula Graph. But in MySQL, you can select two tables from different databases in one statement.","title":"USE"},{"location":"3.ngql-guide/9.space-statements.md/3.show-spaces/","text":"SHOW SPACES \u00b6 SHOW SPACES The SHOW SPACES statement lists the all the graph spaces in a Nebula Graph instance. For example: nebula> SHOW SPACES; +--------+ | Name | +--------+ | \"nba\" | +--------+ To create graph spaces, see Create Space document .","title":"SHOW SPACES"},{"location":"3.ngql-guide/9.space-statements.md/3.show-spaces/#show_spaces","text":"SHOW SPACES The SHOW SPACES statement lists the all the graph spaces in a Nebula Graph instance. For example: nebula> SHOW SPACES; +--------+ | Name | +--------+ | \"nba\" | +--------+ To create graph spaces, see Create Space document .","title":"SHOW SPACES"},{"location":"3.ngql-guide/9.space-statements.md/4.describe-space/","text":"DESCRIBE SPACE \u00b6 DESC[RIBE] SPACE <graph_space_name> The DESCRIBE SPACE statement returns information about a graph space. The DESCRIBE SPACE statement is different from the SHOW SPACES statement. For details about SHOW SPACES , see SHOW SPACES document . You can use DESC instead of DESCRIBE for short. Example \u00b6 Get information about a graph space. nebula> DESCRIBE SPACE nba; +----+-------+------------------+----------------+---------+------------+--------------------+ | ID | Name | Partition Number | Replica Factor | Charset | Collate | Vid Type | +----+-------+------------------+----------------+---------+------------+--------------------+ | 8 | \"nba\" | 15 | 1 | \"utf8\" | \"utf8_bin\" | \"FIXED_STRING(30)\" | +----+-------+------------------+----------------+---------+------------+--------------------+","title":"DESCRIBE SPACE"},{"location":"3.ngql-guide/9.space-statements.md/4.describe-space/#describe_space","text":"DESC[RIBE] SPACE <graph_space_name> The DESCRIBE SPACE statement returns information about a graph space. The DESCRIBE SPACE statement is different from the SHOW SPACES statement. For details about SHOW SPACES , see SHOW SPACES document . You can use DESC instead of DESCRIBE for short.","title":"DESCRIBE SPACE"},{"location":"3.ngql-guide/9.space-statements.md/4.describe-space/#example","text":"Get information about a graph space. nebula> DESCRIBE SPACE nba; +----+-------+------------------+----------------+---------+------------+--------------------+ | ID | Name | Partition Number | Replica Factor | Charset | Collate | Vid Type | +----+-------+------------------+----------------+---------+------------+--------------------+ | 8 | \"nba\" | 15 | 1 | \"utf8\" | \"utf8_bin\" | \"FIXED_STRING(30)\" | +----+-------+------------------+----------------+---------+------------+--------------------+","title":"Example"},{"location":"3.ngql-guide/9.space-statements.md/5.drop-space/","text":"DROP SPACE \u00b6 DROP SPACE [IF EXISTS] <graph_space_name> The DROP SPACE statement deletes everything in the related graph space. You must have the DROP privilege for the related graph space.(TODO: authentication doc) You can use the IF EXISTS keywords when dropping spaces. These keywords automatically detects if the related graph space exists. If it exists, it is deleted. Otherwise, no graph space is deleted. Other graph spaces stay unchanged. The DROP SPACE statement does not immediately remove all the files and directories in the storage engine (and release disk space). The deletion depends on the implementation of different storage engines. NOTE: Be very careful with this statement.","title":"DROP SPACE"},{"location":"3.ngql-guide/9.space-statements.md/5.drop-space/#drop_space","text":"DROP SPACE [IF EXISTS] <graph_space_name> The DROP SPACE statement deletes everything in the related graph space. You must have the DROP privilege for the related graph space.(TODO: authentication doc) You can use the IF EXISTS keywords when dropping spaces. These keywords automatically detects if the related graph space exists. If it exists, it is deleted. Otherwise, no graph space is deleted. Other graph spaces stay unchanged. The DROP SPACE statement does not immediately remove all the files and directories in the storage engine (and release disk space). The deletion depends on the implementation of different storage engines. NOTE: Be very careful with this statement.","title":"DROP SPACE"},{"location":"4.deployment-and-installation/1.resource-preparations/","text":"Prepare resources for compiling, installing, and running Nebula Graph \u00b6 This topic describes the requirements and suggestions for compiling and installing Nebula Graph, as well as how to estimate the resource you need to reserve for running a Nebula Graph cluster. Reading guide \u00b6 If you are reading this topic with the questions listed below, click them to jump to their answers. What do I need to compile Nebula Graph? What do I need to run Nebula Graph in a test environment? What do I need to run Nebula Graph in a production environment? How much memory and disk space do I need to reserve for my Nebula Graph cluster? How to optimize the configuration for HDD and Gigabit Networks? Requirements for compiling the Nebula Graph source code \u00b6 Hardware requirements for compiling Nebula Graph \u00b6 Item Requirement CPU architecture x86_64 Memory 4 GB Disk 10 GB, SSD Supported operating systems for compiling Nebula Graph \u00b6 For now, we can only compile Nebula Graph in the Linux system. We recommend that you use any Linux system with kernel version 2.6.32 or above. Software requirements for compiling Nebula Graph \u00b6 You must have the correct version of the software listed below to compile Nebula Graph. If they are not as required or you are not sure, follow the steps in Prepare software for compiling Nebula Graph to get them ready. Software Version Note glibc 2.12 or above You can run ldd --version to check the glibc version. make Any stable version - m4 Any stable version - git Any stable version - wget Any stable version - unzip Any stable version - xz Any stable version - readline-devel Any stable version - ncurses-devel Any stable version - zlid-devel Any stable version - gcc 7.1.0 or above You can run gcc -v to check the gcc version. gcc-c++ Any stable version - cmake 3.5.0 or above You can run cmake --version to check the cmake version. gettext Any stable version - curl Any stable version - redhat-lsb-core Any stable version - libstdc++-static Any stable version Only needed in CentOS 8+, RedHat 8+, and Fedora systems. libasan Any stable version Only needed in CentOS 8+, RedHat 8+, and Fedora systems. Other third-party software will be automatically downloaded and installed to the build directory at the configure (cmake) stage. Prepare software for compiling Nebula Graph \u00b6 This section guides you through the downloading and installation of software required for compiling Nebula Graph. Install dependencies. For CentOS, RedHat, and Fedora users, run the following commands. ```bash $ yum update $ yum install -y make \\ m4 \\ git \\ wget \\ unzip \\ xz \\ readline-devel \\ ncurses-devel \\ zlib-devel \\ gcc \\ gcc-c++ \\ cmake \\ gettext \\ curl \\ redhat-lsb-core # For CentOS 8+, RedHat 8+, and Fedora, install libstdc++-static, libasan as well $ yum install -y libstdc++-static libasan ``` For Debian and Ubuntu users, run the following commands. ```bash $ apt-get update $ apt-get install -y make \\ m4 \\ git \\ wget \\ unzip \\ xz-utils \\ curl \\ lsb-core \\ build-essential \\ libreadline-dev \\ ncurses-dev \\ cmake \\ gettext ``` Check if the GCC and cmake on your host are in the right version. See Software requirements for compiling Nebula Graph for the required versions. $ g++ --version $ cmake --version If your GCC and cmake are in the right version, then you are all set. If they are not, follow the sub-steps as follows. 1. Clone the nebula-common repository to your host. ```bash $ git clone https://github.com/vesoft-inc/nebula-common.git ``` The source code of Nebula Graph versions like 2.0 alpha or 2.0 beta is stored in particular branches. You can use the `--branch` or `-b` option to specify the branch to be cloned. For example, for 2.0 alpha, run the following command. ```bash $ git clone --branch v2.0.0-alpha https://github.com/vesoft-inc/nebula-common.git ``` 2. Make nebula-common the current working directory. ```bash $ cd nebula-common ``` 3. Run the following commands to install and enable CMake and GCC. ```bash # Install CMake. $ ./third-party/install-cmake.sh cmake-install CMake has been installed to prefix=cmake-install Run 'source cmake-install/bin/enable-cmake.sh' to make it ready to use. Run 'source cmake-install/bin/disable-cmake.sh' to disable it. # Enable CMake $ source cmake-install/bin/enable-cmake.sh # Install GCC. Installing GCC to /opt requires root privilege, you can change it to other locations. $ ./third-party/install-gcc.sh --prefix=/opt GCC-7.5.0 has been installed to /opt/vesoft/toolset/gcc/7.5.0 Performing usability tests Performing regular C++14 tests...OK Performing LeakSanitizer tests...OK Run 'source /opt/vesoft/toolset/gcc/7.5.0/enable' to start using. Run 'source /opt/vesoft/toolset/gcc/7.5.0/disable' to stop using. #Enable GCC. Please note that the path and specific version might be different from your environment. $ source /opt/vesoft/toolset/gcc/7.5.0/enable ``` Requirements and suggestions for installing Nebula Graph in test environments \u00b6 Hardware requirements for test environments \u00b6 Item Requirement CPU architecture x86_64 Number of CPU core 4 Memory 8 GB Disk 100 GB, SSD Supported operating systems for test environments \u00b6 For now, we can only install Nebula Graph in the Linux system. To install Nebula Graph in a test environment, we recommend that you use any Linux system with kernel version 3.9 or above. You can adjust some of the kernel parameters to better accommodate the need for running Nebula Graph. For more information, see Optimize Linux kernel configuration [TODO]. Suggested service architecture for test environments \u00b6 Process Suggested number metad (the metadata service process) 1 storaged (the storage service process) 1 or more graphd (the query engine service process) 1 or more For example, for a single-machine environment, you can deploy 1 metad, 1 storaged, and 1 graphd processes in the machine. For a more common environment, such as a cluster of 3 machines (named as A, B, and C), you can deploy Nebula Graph as follows: Machine name Number of metad Number of storaged Number of graphd A 1 1 1 B None 1 1 C None 1 1 Requirements and suggestions for installing Nebula Graph in production environments \u00b6 Hardware requirements for production environments \u00b6 Item Requirement CPU architecture x86_64 Number of CPU core 48 Memory 96 GB Disk 2 * 900 GB, NVMe SSD Supported operating systems for production environments \u00b6 For now, we can only install Nebula Graph in the Linux system. To install Nebula Graph in a production environment, we recommend that you use any Linux system with kernel version 3.9 or above. You can adjust some of the kernel parameters to better accommodate the need for running Nebula Graph. For more information, see Optimize Linux kernel configuration [TODO]. Suggested service architecture for production environments \u00b6 Process Suggested number metad (the metadata service process) 3 storaged (the storage service process) 3 or more graphd (the query engine service process) 3 or more Each metad process automatically creates and maintains a copy of the metadata. Usually, you only need 3 metad processes. The number of storaged processes does not affect the number of graph space copies. You can deploy multiple processes on a single machine. For example, on a cluster of 5 machines (named as A, B, C, D, and E), you can deploy Nebula Graph as follows: WARNING : Do not deploy a cluster across IDCs. Machine name Number of metad Number of storaged Number of graphd A 1 1 1 B 1 1 1 C 1 1 1 D None 1 1 E None 1 1 Capacity requirements for running a Nebula Graph cluster \u00b6 You can estimate the memory, disk space, and partition number needed for a Nebula Graph cluster of 3 replicas as follows. Resource Unit How to estimate Disk space for a cluster Bytes * * 6 * 120% Memory for a cluster Bytes [ * 15 + * ( * ) + ] * 120% Number of partitions for a graph space - * Question 1: Why do we multiply the disk space and memory by 120%? Answer: The extra 20% is for buffer. Question 2: How to get the number of RocksDB instances? Answer: Each directory in the --data_path item in the etc/nebula-storaged.conf file corresponds to a RocksDB instance. Count the number of directories to get the RocksDB instance number. NOTE : You can decrease the memory size occupied by the bloom filter by adding --enable_partitioned_index_filter=true in etc/nebula-storaged.conf . But it may decrease the read performance in some random-seek cases. Question 3: What is the disk_partition_num_multiplier ? Answer: disk_partition_num_multiplier is a value between 2 to 10, the better performance of the hard disk, the larger the value. Use 2 for HDD. Optimize the configuration for HDD \u00b6 [This part might be moved to the configuration doc map later.] Nebula Graph is intended for NVMe SSD, but if you don't have a choice, optimizing the configuration as follows may better accommodate HDD. etc/nebula-storage.conf: --raft_rpc_timeout_ms = 5000 ~ 10000 --rocksdb_batch_size = 4096 ~ 16384 --heartbeat_interval_secs = 30 ~ 60 --raft_heartbeat_interval_secs = 30 ~ 60 etc/nebula-meta.conf: --heartbeat_interval_secs is the same as etc/nebula-storage.conf Spark Writer: ra te : { t imeou t : 5000 t o 10000 } go-importer: batchSize : 10 to 50 concurrency : 1 to 10 channelBufferSize : 100 to 500","title":"Resource preparations"},{"location":"4.deployment-and-installation/1.resource-preparations/#prepare_resources_for_compiling_installing_and_running_nebula_graph","text":"This topic describes the requirements and suggestions for compiling and installing Nebula Graph, as well as how to estimate the resource you need to reserve for running a Nebula Graph cluster.","title":"Prepare resources for compiling, installing, and running Nebula Graph"},{"location":"4.deployment-and-installation/1.resource-preparations/#reading_guide","text":"If you are reading this topic with the questions listed below, click them to jump to their answers. What do I need to compile Nebula Graph? What do I need to run Nebula Graph in a test environment? What do I need to run Nebula Graph in a production environment? How much memory and disk space do I need to reserve for my Nebula Graph cluster? How to optimize the configuration for HDD and Gigabit Networks?","title":"Reading guide"},{"location":"4.deployment-and-installation/1.resource-preparations/#requirements_for_compiling_the_nebula_graph_source_code","text":"","title":"Requirements for compiling the Nebula Graph source code"},{"location":"4.deployment-and-installation/1.resource-preparations/#hardware_requirements_for_compiling_nebula_graph","text":"Item Requirement CPU architecture x86_64 Memory 4 GB Disk 10 GB, SSD","title":"Hardware requirements for compiling Nebula Graph"},{"location":"4.deployment-and-installation/1.resource-preparations/#supported_operating_systems_for_compiling_nebula_graph","text":"For now, we can only compile Nebula Graph in the Linux system. We recommend that you use any Linux system with kernel version 2.6.32 or above.","title":"Supported operating systems for compiling Nebula Graph"},{"location":"4.deployment-and-installation/1.resource-preparations/#software_requirements_for_compiling_nebula_graph","text":"You must have the correct version of the software listed below to compile Nebula Graph. If they are not as required or you are not sure, follow the steps in Prepare software for compiling Nebula Graph to get them ready. Software Version Note glibc 2.12 or above You can run ldd --version to check the glibc version. make Any stable version - m4 Any stable version - git Any stable version - wget Any stable version - unzip Any stable version - xz Any stable version - readline-devel Any stable version - ncurses-devel Any stable version - zlid-devel Any stable version - gcc 7.1.0 or above You can run gcc -v to check the gcc version. gcc-c++ Any stable version - cmake 3.5.0 or above You can run cmake --version to check the cmake version. gettext Any stable version - curl Any stable version - redhat-lsb-core Any stable version - libstdc++-static Any stable version Only needed in CentOS 8+, RedHat 8+, and Fedora systems. libasan Any stable version Only needed in CentOS 8+, RedHat 8+, and Fedora systems. Other third-party software will be automatically downloaded and installed to the build directory at the configure (cmake) stage.","title":"Software requirements for compiling Nebula Graph"},{"location":"4.deployment-and-installation/1.resource-preparations/#prepare_software_for_compiling_nebula_graph","text":"This section guides you through the downloading and installation of software required for compiling Nebula Graph. Install dependencies. For CentOS, RedHat, and Fedora users, run the following commands. ```bash $ yum update $ yum install -y make \\ m4 \\ git \\ wget \\ unzip \\ xz \\ readline-devel \\ ncurses-devel \\ zlib-devel \\ gcc \\ gcc-c++ \\ cmake \\ gettext \\ curl \\ redhat-lsb-core # For CentOS 8+, RedHat 8+, and Fedora, install libstdc++-static, libasan as well $ yum install -y libstdc++-static libasan ``` For Debian and Ubuntu users, run the following commands. ```bash $ apt-get update $ apt-get install -y make \\ m4 \\ git \\ wget \\ unzip \\ xz-utils \\ curl \\ lsb-core \\ build-essential \\ libreadline-dev \\ ncurses-dev \\ cmake \\ gettext ``` Check if the GCC and cmake on your host are in the right version. See Software requirements for compiling Nebula Graph for the required versions. $ g++ --version $ cmake --version If your GCC and cmake are in the right version, then you are all set. If they are not, follow the sub-steps as follows. 1. Clone the nebula-common repository to your host. ```bash $ git clone https://github.com/vesoft-inc/nebula-common.git ``` The source code of Nebula Graph versions like 2.0 alpha or 2.0 beta is stored in particular branches. You can use the `--branch` or `-b` option to specify the branch to be cloned. For example, for 2.0 alpha, run the following command. ```bash $ git clone --branch v2.0.0-alpha https://github.com/vesoft-inc/nebula-common.git ``` 2. Make nebula-common the current working directory. ```bash $ cd nebula-common ``` 3. Run the following commands to install and enable CMake and GCC. ```bash # Install CMake. $ ./third-party/install-cmake.sh cmake-install CMake has been installed to prefix=cmake-install Run 'source cmake-install/bin/enable-cmake.sh' to make it ready to use. Run 'source cmake-install/bin/disable-cmake.sh' to disable it. # Enable CMake $ source cmake-install/bin/enable-cmake.sh # Install GCC. Installing GCC to /opt requires root privilege, you can change it to other locations. $ ./third-party/install-gcc.sh --prefix=/opt GCC-7.5.0 has been installed to /opt/vesoft/toolset/gcc/7.5.0 Performing usability tests Performing regular C++14 tests...OK Performing LeakSanitizer tests...OK Run 'source /opt/vesoft/toolset/gcc/7.5.0/enable' to start using. Run 'source /opt/vesoft/toolset/gcc/7.5.0/disable' to stop using. #Enable GCC. Please note that the path and specific version might be different from your environment. $ source /opt/vesoft/toolset/gcc/7.5.0/enable ```","title":"Prepare software for compiling Nebula Graph"},{"location":"4.deployment-and-installation/1.resource-preparations/#requirements_and_suggestions_for_installing_nebula_graph_in_test_environments","text":"","title":"Requirements and suggestions for installing Nebula Graph in test environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#hardware_requirements_for_test_environments","text":"Item Requirement CPU architecture x86_64 Number of CPU core 4 Memory 8 GB Disk 100 GB, SSD","title":"Hardware requirements for test environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#supported_operating_systems_for_test_environments","text":"For now, we can only install Nebula Graph in the Linux system. To install Nebula Graph in a test environment, we recommend that you use any Linux system with kernel version 3.9 or above. You can adjust some of the kernel parameters to better accommodate the need for running Nebula Graph. For more information, see Optimize Linux kernel configuration [TODO].","title":"Supported operating systems for test environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#suggested_service_architecture_for_test_environments","text":"Process Suggested number metad (the metadata service process) 1 storaged (the storage service process) 1 or more graphd (the query engine service process) 1 or more For example, for a single-machine environment, you can deploy 1 metad, 1 storaged, and 1 graphd processes in the machine. For a more common environment, such as a cluster of 3 machines (named as A, B, and C), you can deploy Nebula Graph as follows: Machine name Number of metad Number of storaged Number of graphd A 1 1 1 B None 1 1 C None 1 1","title":"Suggested service architecture for test environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#requirements_and_suggestions_for_installing_nebula_graph_in_production_environments","text":"","title":"Requirements and suggestions for installing Nebula Graph in production environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#hardware_requirements_for_production_environments","text":"Item Requirement CPU architecture x86_64 Number of CPU core 48 Memory 96 GB Disk 2 * 900 GB, NVMe SSD","title":"Hardware requirements for production environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#supported_operating_systems_for_production_environments","text":"For now, we can only install Nebula Graph in the Linux system. To install Nebula Graph in a production environment, we recommend that you use any Linux system with kernel version 3.9 or above. You can adjust some of the kernel parameters to better accommodate the need for running Nebula Graph. For more information, see Optimize Linux kernel configuration [TODO].","title":"Supported operating systems for production environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#suggested_service_architecture_for_production_environments","text":"Process Suggested number metad (the metadata service process) 3 storaged (the storage service process) 3 or more graphd (the query engine service process) 3 or more Each metad process automatically creates and maintains a copy of the metadata. Usually, you only need 3 metad processes. The number of storaged processes does not affect the number of graph space copies. You can deploy multiple processes on a single machine. For example, on a cluster of 5 machines (named as A, B, C, D, and E), you can deploy Nebula Graph as follows: WARNING : Do not deploy a cluster across IDCs. Machine name Number of metad Number of storaged Number of graphd A 1 1 1 B 1 1 1 C 1 1 1 D None 1 1 E None 1 1","title":"Suggested service architecture for production environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#capacity_requirements_for_running_a_nebula_graph_cluster","text":"You can estimate the memory, disk space, and partition number needed for a Nebula Graph cluster of 3 replicas as follows. Resource Unit How to estimate Disk space for a cluster Bytes * * 6 * 120% Memory for a cluster Bytes [ * 15 + * ( * ) + ] * 120% Number of partitions for a graph space - * Question 1: Why do we multiply the disk space and memory by 120%? Answer: The extra 20% is for buffer. Question 2: How to get the number of RocksDB instances? Answer: Each directory in the --data_path item in the etc/nebula-storaged.conf file corresponds to a RocksDB instance. Count the number of directories to get the RocksDB instance number. NOTE : You can decrease the memory size occupied by the bloom filter by adding --enable_partitioned_index_filter=true in etc/nebula-storaged.conf . But it may decrease the read performance in some random-seek cases. Question 3: What is the disk_partition_num_multiplier ? Answer: disk_partition_num_multiplier is a value between 2 to 10, the better performance of the hard disk, the larger the value. Use 2 for HDD.","title":"Capacity requirements for running a Nebula Graph cluster"},{"location":"4.deployment-and-installation/1.resource-preparations/#optimize_the_configuration_for_hdd","text":"[This part might be moved to the configuration doc map later.] Nebula Graph is intended for NVMe SSD, but if you don't have a choice, optimizing the configuration as follows may better accommodate HDD. etc/nebula-storage.conf: --raft_rpc_timeout_ms = 5000 ~ 10000 --rocksdb_batch_size = 4096 ~ 16384 --heartbeat_interval_secs = 30 ~ 60 --raft_heartbeat_interval_secs = 30 ~ 60 etc/nebula-meta.conf: --heartbeat_interval_secs is the same as etc/nebula-storage.conf Spark Writer: ra te : { t imeou t : 5000 t o 10000 } go-importer: batchSize : 10 to 50 concurrency : 1 to 10 channelBufferSize : 100 to 500","title":"Optimize the configuration for HDD"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/","text":"Install Nebula Graph by compiling the source code \u00b6 Installing Nebula Graph from the source code allows you to customize the compiling and installation settings and test the latest features. Prerequisites \u00b6 You have prepared the necessary resources described in Prepare resources for compiling, installing, and running Nebula Graph . You can access the Internet from the host you plan to install Nebula Graph. How to install \u00b6 Use Git to clone the source code of Nebula Graph to your host. * To install the latest version of Nebula Graph 2.x, run the following command to download the source code from the master branch. ```bash $ git clone https://github.com/vesoft-inc/nebula-graph.git ``` * To install a specific version of Nebula Graph 2.x, use the --branch <branch_name> option to specify the correct branch. For example, to install 2.0.0 beta, run the following command. ```bash $ git clone --branch v2.0.0-beta https://github.com/vesoft-inc/nebula-graph.git ``` Make the nebula-graph directory the current working directory. $ cd nebula-graph Create a build directory and make it the current working directory. $ mkdir build && cd build Generate the Makefile with CMake. NOTE : The installation path is /user/local/nebula by default. To customize it, add the -DCMAKE_INSTALL_PREFIX=/your/install/path/ CMake variable in the following command. For more information about CMake variables, see CMake variables . If you are installing the latest version of Nebula Graph 2.x and has cloned the master branch in step 1, run the following command. ```bash $ cmake -DENABLE_BUILD_STORAGE=on -DENABLE_TESTING=OFF -DCMAKE_BUILD_TYPE=Release .. ``` If you are installing a specific version of Nebula Graph 2.x and has cloned the corresponding branch in step 1, use the -DNEBULA_COMMON_REPO_TAG and -DNEBULA_STORAGE_REPO_TAG options to specify the correct branches of the nebula-common and nebula-storage repositories. For example, to install 2.0.0 beta, run the following command. ```bash $ cmake -DENABLE_BUILD_STORAGE=on -DENABLE_TESTING=OFF -DCMAKE_BUILD_TYPE=Release \\ -DNEBULA_COMMON_REPO_TAG=v2.0.0-beta -DNEBULA_STORAGE_REPO_TAG=v2.0.0-beta .. ``` Compile Nebula Graph. Assuming cores is the number of CPU cores and mem_gb is the memory size (in GB), to appropriately speed up the compiling, you can use the value of the smaller one between cores and mem_gb/2 as the value of N in the following command. $ make -j { N } Install Nebula Graph. $ make install-all CMake variables \u00b6 Usage of CMake variables: $ cmake -DVariable = <value> ... The following CMake variables can be used at the configure (cmake) stage to adjust the compiling settings. ENABLE_BUILD_STORAGE \u00b6 Starting from the 2.0 pre-release, Nebula Graph supports separated compute and storage. The ENABLE_BUILD_STORAGE variable is set to OFF by default so that the storage service is not installed together with the graph service. If you are deploying Nebula Graph on a single host for testing, you can set ENABLE_BUILD_STORAGE to ON to download and install the storage service automatically. CMAKE_INSTALL_PREFIX \u00b6 CMAKE_INSTALL_PREFIX specifies the path where the service modules, scripts, configuration files are installed. The default path is /usr/local/nebula . ENABLE_WERROR \u00b6 ENABLE_WERROR is ON by default and it makes all warnings into errors. You can set it to OFF if needed. ENABLE_TESTING \u00b6 ENABLE_TESTING is ON by default and unit tests are built with the Nebula Graph services. If you just need the service modules, set it to OFF . ENABLE_ASAN \u00b6 ENABLE_ASAN is OFF by default and the building of ASan (AddressSanitizer), a memory error detector, is disabled. To enable it, set ENABLE_ASAN to ON . This variable is intended for Nebula Graph developers. CMAKE_BUILD_TYPE \u00b6 Nebula Graph supports the following building types: Debug , the default value of CMAKE_BUILD_TYPE , indicates building Nebula Graph with the debug info but not the optimization options. Release , indicates building Nebula Graph with the optimization options but not the debug info. RelWithDebInfo , indicates building Nebula Graph with the optimization options and the debug info. MinSizeRel , indicates building Nebula Graph with the optimization options for controlling the code size but not the debug info. CMAKE_C_COMPILER/CMAKE_CXX_COMPILER \u00b6 Usually, CMake locates and uses a C/C++ compiler installed in the host automatically. But if your compiler is not installed at the standard path, or if you want to use a different one, run the command as follows to specify the installation path of the target compiler: $ cmake -DCMAKE_C_COMPILER = /path/to/gcc/bin/gcc -DCMAKE_CXX_COMPILER = /path/to/gcc/bin/g++ .. $ cmake -DCMAKE_C_COMPILER = /path/to/clang/bin/clang -DCMAKE_CXX_COMPILER = /path/to/clang/bin/clang++ .. ENABLE_CCACHE \u00b6 ENABLE_CCACHE is ON by default and ccache is used to speed up the compiling of Nebula Graph. To disable ccache , set ENABLE_CCACHE to OFF . On some platforms, the ccache installation hooks up or precedes the compiler. In such a case, you have to set an environment variable export CCACHE_DISABLE=true or add a line disable=true in ~/.ccache/ccache.conf as well. For more information, see the ccache official documentation . NEBULA_THIRDPARTY_ROOT \u00b6 NEBULA_THIRDPARTY_ROOT specifies the path where the third party software is installed. By default it is /opt/vesoft/third-party . What to do next \u00b6 Start and stop Nebula Graph [TODO] Connect to Nebula Graph Try Nebula Graph CRUD","title":"Install Nebula\u00a0Graph by compiling the source code"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#install_nebula_graph_by_compiling_the_source_code","text":"Installing Nebula Graph from the source code allows you to customize the compiling and installation settings and test the latest features.","title":"Install Nebula Graph by compiling the source code"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#prerequisites","text":"You have prepared the necessary resources described in Prepare resources for compiling, installing, and running Nebula Graph . You can access the Internet from the host you plan to install Nebula Graph.","title":"Prerequisites"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#how_to_install","text":"Use Git to clone the source code of Nebula Graph to your host. * To install the latest version of Nebula Graph 2.x, run the following command to download the source code from the master branch. ```bash $ git clone https://github.com/vesoft-inc/nebula-graph.git ``` * To install a specific version of Nebula Graph 2.x, use the --branch <branch_name> option to specify the correct branch. For example, to install 2.0.0 beta, run the following command. ```bash $ git clone --branch v2.0.0-beta https://github.com/vesoft-inc/nebula-graph.git ``` Make the nebula-graph directory the current working directory. $ cd nebula-graph Create a build directory and make it the current working directory. $ mkdir build && cd build Generate the Makefile with CMake. NOTE : The installation path is /user/local/nebula by default. To customize it, add the -DCMAKE_INSTALL_PREFIX=/your/install/path/ CMake variable in the following command. For more information about CMake variables, see CMake variables . If you are installing the latest version of Nebula Graph 2.x and has cloned the master branch in step 1, run the following command. ```bash $ cmake -DENABLE_BUILD_STORAGE=on -DENABLE_TESTING=OFF -DCMAKE_BUILD_TYPE=Release .. ``` If you are installing a specific version of Nebula Graph 2.x and has cloned the corresponding branch in step 1, use the -DNEBULA_COMMON_REPO_TAG and -DNEBULA_STORAGE_REPO_TAG options to specify the correct branches of the nebula-common and nebula-storage repositories. For example, to install 2.0.0 beta, run the following command. ```bash $ cmake -DENABLE_BUILD_STORAGE=on -DENABLE_TESTING=OFF -DCMAKE_BUILD_TYPE=Release \\ -DNEBULA_COMMON_REPO_TAG=v2.0.0-beta -DNEBULA_STORAGE_REPO_TAG=v2.0.0-beta .. ``` Compile Nebula Graph. Assuming cores is the number of CPU cores and mem_gb is the memory size (in GB), to appropriately speed up the compiling, you can use the value of the smaller one between cores and mem_gb/2 as the value of N in the following command. $ make -j { N } Install Nebula Graph. $ make install-all","title":"How to install"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#cmake_variables","text":"Usage of CMake variables: $ cmake -DVariable = <value> ... The following CMake variables can be used at the configure (cmake) stage to adjust the compiling settings.","title":"CMake variables"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_build_storage","text":"Starting from the 2.0 pre-release, Nebula Graph supports separated compute and storage. The ENABLE_BUILD_STORAGE variable is set to OFF by default so that the storage service is not installed together with the graph service. If you are deploying Nebula Graph on a single host for testing, you can set ENABLE_BUILD_STORAGE to ON to download and install the storage service automatically.","title":"ENABLE_BUILD_STORAGE"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#cmake_install_prefix","text":"CMAKE_INSTALL_PREFIX specifies the path where the service modules, scripts, configuration files are installed. The default path is /usr/local/nebula .","title":"CMAKE_INSTALL_PREFIX"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_werror","text":"ENABLE_WERROR is ON by default and it makes all warnings into errors. You can set it to OFF if needed.","title":"ENABLE_WERROR"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_testing","text":"ENABLE_TESTING is ON by default and unit tests are built with the Nebula Graph services. If you just need the service modules, set it to OFF .","title":"ENABLE_TESTING"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_asan","text":"ENABLE_ASAN is OFF by default and the building of ASan (AddressSanitizer), a memory error detector, is disabled. To enable it, set ENABLE_ASAN to ON . This variable is intended for Nebula Graph developers.","title":"ENABLE_ASAN"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#cmake_build_type","text":"Nebula Graph supports the following building types: Debug , the default value of CMAKE_BUILD_TYPE , indicates building Nebula Graph with the debug info but not the optimization options. Release , indicates building Nebula Graph with the optimization options but not the debug info. RelWithDebInfo , indicates building Nebula Graph with the optimization options and the debug info. MinSizeRel , indicates building Nebula Graph with the optimization options for controlling the code size but not the debug info.","title":"CMAKE_BUILD_TYPE"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#cmake_c_compilercmake_cxx_compiler","text":"Usually, CMake locates and uses a C/C++ compiler installed in the host automatically. But if your compiler is not installed at the standard path, or if you want to use a different one, run the command as follows to specify the installation path of the target compiler: $ cmake -DCMAKE_C_COMPILER = /path/to/gcc/bin/gcc -DCMAKE_CXX_COMPILER = /path/to/gcc/bin/g++ .. $ cmake -DCMAKE_C_COMPILER = /path/to/clang/bin/clang -DCMAKE_CXX_COMPILER = /path/to/clang/bin/clang++ ..","title":"CMAKE_C_COMPILER/CMAKE_CXX_COMPILER"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_ccache","text":"ENABLE_CCACHE is ON by default and ccache is used to speed up the compiling of Nebula Graph. To disable ccache , set ENABLE_CCACHE to OFF . On some platforms, the ccache installation hooks up or precedes the compiler. In such a case, you have to set an environment variable export CCACHE_DISABLE=true or add a line disable=true in ~/.ccache/ccache.conf as well. For more information, see the ccache official documentation .","title":"ENABLE_CCACHE"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#nebula_thirdparty_root","text":"NEBULA_THIRDPARTY_ROOT specifies the path where the third party software is installed. By default it is /opt/vesoft/third-party .","title":"NEBULA_THIRDPARTY_ROOT"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#what_to_do_next","text":"Start and stop Nebula Graph [TODO] Connect to Nebula Graph Try Nebula Graph CRUD","title":"What to do next"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/1.text-based-index-restrictions/","text":"Full-text index restrictions \u00b6 This document holds the restrictions for full-text indexes. Please read the restrictions very carefully before using the full-text indexes. For now, full-text search has the following limitations: The maximum indexing string length is 256 bytes. To index data that is longer than 256 bytes, store your data in a reverse order. Full-text index can not be applied to more than one property at a time (similar to a composite index). The WHERE clause in full-text search statement LOOKUP does not support logical expressions AND and OR . Full-text index can not be applied to multiple tags search. Ideographic language Chinese does not have word delimiters. Therefore, the built-in full-text parser cannot determine where words begin and end in Chinese. Install the elasticsearch-analysis-ik to parse Chinese. Sorting for the returned results of the full-text search is not supported. Data is returned in the order of data insertion. Full-text index can not search the null properties. Rebuilding or altering Elasticsearch indexes is not supported at this time. Pipe is not supported in the LOOKUP statement, excluding the examples in our document. Full-text search only works on single terms. Full-text indexes are not deleted together with the graph space. Make sure that you start the Elasticsearch cluster and Nebula Graph at the same time. If not, the data writing on the Elasticsearch cluster can be incomplete. Do not contain ' or \\ in the vertex or edge values. If not, a error is caused in the Elasticsearch cluster storage. It may take a while for Elasticsearch to create indexes. If Nebula Graph warns no index is found, wait for the index to take effect.","title":"Full-text restrictions"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/1.text-based-index-restrictions/#full-text_index_restrictions","text":"This document holds the restrictions for full-text indexes. Please read the restrictions very carefully before using the full-text indexes. For now, full-text search has the following limitations: The maximum indexing string length is 256 bytes. To index data that is longer than 256 bytes, store your data in a reverse order. Full-text index can not be applied to more than one property at a time (similar to a composite index). The WHERE clause in full-text search statement LOOKUP does not support logical expressions AND and OR . Full-text index can not be applied to multiple tags search. Ideographic language Chinese does not have word delimiters. Therefore, the built-in full-text parser cannot determine where words begin and end in Chinese. Install the elasticsearch-analysis-ik to parse Chinese. Sorting for the returned results of the full-text search is not supported. Data is returned in the order of data insertion. Full-text index can not search the null properties. Rebuilding or altering Elasticsearch indexes is not supported at this time. Pipe is not supported in the LOOKUP statement, excluding the examples in our document. Full-text search only works on single terms. Full-text indexes are not deleted together with the graph space. Make sure that you start the Elasticsearch cluster and Nebula Graph at the same time. If not, the data writing on the Elasticsearch cluster can be incomplete. Do not contain ' or \\ in the vertex or edge values. If not, a error is caused in the Elasticsearch cluster storage. It may take a while for Elasticsearch to create indexes. If Nebula Graph warns no index is found, wait for the index to take effect.","title":"Full-text index restrictions"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy/","text":"Deploy full-text index \u00b6 Nebula Graph full-text indexes are powered by Elasticsearch . This means that you can use Elasticsearch full-text query language to retrieve what you want. Full-text indexes are managed through built-in procedures. They can be created only for variable STRING and FIXED_STRING properties when the listener cluster and the Elasticsearch cluster are deployed. Deploy Elasticsearch cluster \u00b6 To deploy an Elasticsearch cluster, see the Elasticsearch documentation . When the Elasticsearch cluster is started, add the template file for the Nebula Graph full-text index. Take the following sample template for example: { \"template\" : \"nebula*\" , \"settings\" : { \"index\" : { \"number_of_shards\" : 3 , \"number_of_replicas\" : 1 } }, \"mappings\" : { \"properties\" : { \"tag_id\" : { \"type\" : \"long\" }, \"column_id\" : { \"type\" : \"text\" }, \"value\" :{ \"type\" : \"keyword\" } } } } Make sure that you specify the following fields in strict accordance with the preceding template format: \"template\" : \"nebula*\" \"tag_id\" : { \"type\" : \"long\" }, \"column_id\" : { \"type\" : \"text\" }, \"value\" :{ \"type\" : \"keyword\" } You can configure the Elasticsearch to meet your business needs. To customize the Elasticsearch, see Elasticserch Document . Deploy full-text cluster (Nebula Storage Service Raft Listener cluster) \u00b6 Full-text index data is written to the Elasticsearch cluster asynchronously. To use the full-text index search, you must run one or more nebula-storaged process as the Raft Listener (short for Listener). The Listener writes the data into the Elasticsearch cluster. Configure the following parameters for the Listener. For example: ########## basics ########## # The file to host the process id --pid_file=pids_listener/nebula-storaged.pid # The directory to host logging files, which must already exists --log_dir=logs_listener ########## networking ########## # Meta server address --meta_server_addrs=192.168.8.5:68833 # Local ip --local_ip=192.168.8.5 # Storage daemon listening port --port=66780 # HTTP service ip --ws_ip=192.168.8.5 # HTTP service port --ws_http_port=65219 # HTTP2 service port --ws_h2_port=65211 Use the real IP in the configuration file. Copy the nebula-graphd.conf configuration file (the directory is /usr/local/nebula/etc/ by default) and rename it as nebula-storaged-listener.conf . Add the preceding configurations to the nebula-storaged-listener.conf configuration file. Run the following command to start the Listener: ./bin/nebula-storaged --flagfile /path/to/your/listener/nebula-storaged-listener.conf Sign in to the text search clients \u00b6 SIGN IN TEXT SERVICE [(<elastic_ip:port> [,<username>, <password>]), (<elastic_ip:port>), ...] When the Elasticsearch cluster is deployed, use the SIGN IN | OUT statement to sign in or sign out to the Elasticsearch clients. Multiple elastic_ip:port pairs are separated with commas. You must use the actual IPs and the port number in the configuration file for the Elasticsearch. For example: nebula> SIGN IN TEXT SERVICE (127.0.0.1:9200); Elasticsearch does not have username or password by default. If you configured a username and password, you need to specify in the SIGN IN statement. Show text search clients \u00b6 SHOW TEXT SEARCH CLIENTS Use the SHOW TEXT SEARCH CLIENTS statement to list the text search clients. For example: nebula> SHOW TEXT SEARCH CLIENTS; +-------------+------+ | Host | Port | +-------------+------+ | \"127.0.0.1\" | 9200 | +-------------+------+ | \"127.0.0.1\" | 9200 | +-------------+------+ | \"127.0.0.1\" | 9200 | +-------------+------+ Sign out to the text search clients \u00b6 SIGN OUT TEXT SERVICE Use the SIGN OUT TEXT SERVICE to sign out all the text search clients. For example: nebula> SIGN OUT TEXT SERVICE; Add full-text Listeners \u00b6 ADD LISTENER ELASTICSEARCH <listener_ip:port> [,<listener_ip:port>, ...] When Listeners are started, use the ADD LISTENER ELASTICSEARCH statement to add the Listeners for a graph space. Multiple listener_ip:port pairs are separated with commas. You must use the real IPs. For example: nebula> ADD LISTENER ELASTICSEARCH 192.168.8.5:46780; NOTE: Listeners are bound to the partitions. You must add all the Listeners in one sentence or you receive an error. Show full-text Listeners \u00b6 SHOW LISTENER Use the SHOW LISTENER statement to list the Listeners. For example: nebula> SHOW LISTENER; +--------+-----------------+-----------------------+----------+ | PartId | Type | Host | Status | +--------+-----------------+-----------------------+----------+ | 1 | \"ELASTICSEARCH\" | \"[192.168.8.5:46780]\" | \"ONLINE\" | +--------+-----------------+-----------------------+----------+ | 2 | \"ELASTICSEARCH\" | \"[192.168.8.5:46780]\" | \"ONLINE\" | +--------+-----------------+-----------------------+----------+ | 3 | \"ELASTICSEARCH\" | \"[192.168.8.5:46780]\" | \"ONLINE\" | +--------+-----------------+-----------------------+----------+ Remove full-text Listeners \u00b6 REMOVE LISTENER ELASTICSEARCH Use the REMOVE LISTENER ELASTICSEARCH statement to remove all the Elasticsearch Listeners for a graph space. For example: nebula> REMOVE LISTENER ELASTICSEARCH; When you are done with the deployment of the Elasticsearch cluster and the Listener, full-text indexes are created automatically on the Elasticsearch. You can do full-text search now. For more information, see Full-text search .","title":"Deploy full-text index"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy/#deploy_full-text_index","text":"Nebula Graph full-text indexes are powered by Elasticsearch . This means that you can use Elasticsearch full-text query language to retrieve what you want. Full-text indexes are managed through built-in procedures. They can be created only for variable STRING and FIXED_STRING properties when the listener cluster and the Elasticsearch cluster are deployed.","title":"Deploy full-text index"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy/#deploy_elasticsearch_cluster","text":"To deploy an Elasticsearch cluster, see the Elasticsearch documentation . When the Elasticsearch cluster is started, add the template file for the Nebula Graph full-text index. Take the following sample template for example: { \"template\" : \"nebula*\" , \"settings\" : { \"index\" : { \"number_of_shards\" : 3 , \"number_of_replicas\" : 1 } }, \"mappings\" : { \"properties\" : { \"tag_id\" : { \"type\" : \"long\" }, \"column_id\" : { \"type\" : \"text\" }, \"value\" :{ \"type\" : \"keyword\" } } } } Make sure that you specify the following fields in strict accordance with the preceding template format: \"template\" : \"nebula*\" \"tag_id\" : { \"type\" : \"long\" }, \"column_id\" : { \"type\" : \"text\" }, \"value\" :{ \"type\" : \"keyword\" } You can configure the Elasticsearch to meet your business needs. To customize the Elasticsearch, see Elasticserch Document .","title":"Deploy Elasticsearch cluster"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy/#deploy_full-text_cluster_nebula_storage_service_raft_listener_cluster","text":"Full-text index data is written to the Elasticsearch cluster asynchronously. To use the full-text index search, you must run one or more nebula-storaged process as the Raft Listener (short for Listener). The Listener writes the data into the Elasticsearch cluster. Configure the following parameters for the Listener. For example: ########## basics ########## # The file to host the process id --pid_file=pids_listener/nebula-storaged.pid # The directory to host logging files, which must already exists --log_dir=logs_listener ########## networking ########## # Meta server address --meta_server_addrs=192.168.8.5:68833 # Local ip --local_ip=192.168.8.5 # Storage daemon listening port --port=66780 # HTTP service ip --ws_ip=192.168.8.5 # HTTP service port --ws_http_port=65219 # HTTP2 service port --ws_h2_port=65211 Use the real IP in the configuration file. Copy the nebula-graphd.conf configuration file (the directory is /usr/local/nebula/etc/ by default) and rename it as nebula-storaged-listener.conf . Add the preceding configurations to the nebula-storaged-listener.conf configuration file. Run the following command to start the Listener: ./bin/nebula-storaged --flagfile /path/to/your/listener/nebula-storaged-listener.conf","title":"Deploy full-text cluster (Nebula Storage Service Raft Listener cluster)"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy/#sign_in_to_the_text_search_clients","text":"SIGN IN TEXT SERVICE [(<elastic_ip:port> [,<username>, <password>]), (<elastic_ip:port>), ...] When the Elasticsearch cluster is deployed, use the SIGN IN | OUT statement to sign in or sign out to the Elasticsearch clients. Multiple elastic_ip:port pairs are separated with commas. You must use the actual IPs and the port number in the configuration file for the Elasticsearch. For example: nebula> SIGN IN TEXT SERVICE (127.0.0.1:9200); Elasticsearch does not have username or password by default. If you configured a username and password, you need to specify in the SIGN IN statement.","title":"Sign in to the text search clients"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy/#show_text_search_clients","text":"SHOW TEXT SEARCH CLIENTS Use the SHOW TEXT SEARCH CLIENTS statement to list the text search clients. For example: nebula> SHOW TEXT SEARCH CLIENTS; +-------------+------+ | Host | Port | +-------------+------+ | \"127.0.0.1\" | 9200 | +-------------+------+ | \"127.0.0.1\" | 9200 | +-------------+------+ | \"127.0.0.1\" | 9200 | +-------------+------+","title":"Show text search clients"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy/#sign_out_to_the_text_search_clients","text":"SIGN OUT TEXT SERVICE Use the SIGN OUT TEXT SERVICE to sign out all the text search clients. For example: nebula> SIGN OUT TEXT SERVICE;","title":"Sign out to the text search clients"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy/#add_full-text_listeners","text":"ADD LISTENER ELASTICSEARCH <listener_ip:port> [,<listener_ip:port>, ...] When Listeners are started, use the ADD LISTENER ELASTICSEARCH statement to add the Listeners for a graph space. Multiple listener_ip:port pairs are separated with commas. You must use the real IPs. For example: nebula> ADD LISTENER ELASTICSEARCH 192.168.8.5:46780; NOTE: Listeners are bound to the partitions. You must add all the Listeners in one sentence or you receive an error.","title":"Add full-text Listeners"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy/#show_full-text_listeners","text":"SHOW LISTENER Use the SHOW LISTENER statement to list the Listeners. For example: nebula> SHOW LISTENER; +--------+-----------------+-----------------------+----------+ | PartId | Type | Host | Status | +--------+-----------------+-----------------------+----------+ | 1 | \"ELASTICSEARCH\" | \"[192.168.8.5:46780]\" | \"ONLINE\" | +--------+-----------------+-----------------------+----------+ | 2 | \"ELASTICSEARCH\" | \"[192.168.8.5:46780]\" | \"ONLINE\" | +--------+-----------------+-----------------------+----------+ | 3 | \"ELASTICSEARCH\" | \"[192.168.8.5:46780]\" | \"ONLINE\" | +--------+-----------------+-----------------------+----------+","title":"Show full-text Listeners"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy/#remove_full-text_listeners","text":"REMOVE LISTENER ELASTICSEARCH Use the REMOVE LISTENER ELASTICSEARCH statement to remove all the Elasticsearch Listeners for a graph space. For example: nebula> REMOVE LISTENER ELASTICSEARCH; When you are done with the deployment of the Elasticsearch cluster and the Listener, full-text indexes are created automatically on the Elasticsearch. You can do full-text search now. For more information, see Full-text search .","title":"Remove full-text Listeners"}]}