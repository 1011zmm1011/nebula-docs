{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Nebula Graph 2.0 Documentation \u00b6 Nebula Graph is a distributed, scalable, and lightning-fast graph database. It is the optimal solution in the world capable of hosting graphs with dozens of billions of vertices (nodes) and trillions of edges with millisecond latency. Tutorial Video \u00b6 YouTube bilibili Preface \u00b6 Manual Change Log Introduction \u00b6 What is Nebula Graph Quick start (for beginners) \u00b6 Quick start workflow Deploy Nebula Graph with Docker Compose Connect to Nebula Graph Nebula Graph CRUD nGQL guide (for all users) \u00b6 Operators Comparison Pipe Property reference Set String Precedence Functions and expressions Math String Date and time Schema Case expressions General query statements Match Space statements Create space Use space Show spaces Describe space Drop space Vertex statements Insert vertex Update vertex Upsert vertex Delete vertex Subgraph and path Get subgraph Query tuning statements Explain and profile Deployment and installation (for Developers and DBA) \u00b6 Resource preparations Compile and install Nebula Graph Install Nebula Graph by compiling the source code","title":"Welcome to Nebula Graph 2.0 Documentation"},{"location":"#welcome_to_nebula_graph_20_documentation","text":"Nebula Graph is a distributed, scalable, and lightning-fast graph database. It is the optimal solution in the world capable of hosting graphs with dozens of billions of vertices (nodes) and trillions of edges with millisecond latency.","title":"Welcome to Nebula Graph 2.0 Documentation"},{"location":"#tutorial_video","text":"YouTube bilibili","title":"Tutorial Video"},{"location":"#preface","text":"Manual Change Log","title":"Preface"},{"location":"#introduction","text":"What is Nebula Graph","title":"Introduction"},{"location":"#quick_start_for_beginners","text":"Quick start workflow Deploy Nebula Graph with Docker Compose Connect to Nebula Graph Nebula Graph CRUD","title":"Quick start (for beginners)"},{"location":"#ngql_guide_for_all_users","text":"Operators Comparison Pipe Property reference Set String Precedence Functions and expressions Math String Date and time Schema Case expressions General query statements Match Space statements Create space Use space Show spaces Describe space Drop space Vertex statements Insert vertex Update vertex Upsert vertex Delete vertex Subgraph and path Get subgraph Query tuning statements Explain and profile","title":"nGQL guide (for all users)"},{"location":"#deployment_and_installation_for_developers_and_dba","text":"Resource preparations Compile and install Nebula Graph Install Nebula Graph by compiling the source code","title":"Deployment and installation (for Developers and DBA)"},{"location":"CHANGELOG/","text":"Manual Changes \u00b6 0.1.1 - Initial release Nebula Graph alpha","title":"Manual Changes"},{"location":"CHANGELOG/#manual_changes","text":"0.1.1 - Initial release Nebula Graph alpha","title":"Manual Changes"},{"location":"1.introduction/1.what-is-nebula-graph/","text":"What is Nebula Graph \u00b6 Nebula Graph is an open-source, distributed, easily scalable, and native graph database. It is capable of hosting graphs with billions of vertices and trillions of edges, and serving queries with millisecond-latency. What is a graph database \u00b6 A graph database, such as Nebula Graph, is a database that specializes in storing vast graph networks and retrieving information from them. It efficiently stores data as vertices (nodes) and edges (relationships) in labeled property graphs. Properties can be attached to both vertices and edges. Each vertex can have one or multiple tags (labels). Graph databases are well suited for storing most kinds of data models abstracted from reality. Things are connected in almost all fields in the world. Modeling systems like relational databases extract the relationships between entities and squeeze them into table columns alone, with their types and properties stored in other columns or even other tables. This makes the data management time-consuming and cost-ineffective. Nebula Graph, as a typical native graph database, allows you to store the rich relationships as edges with edge types and properties directly attached to them. Benefits of Nebula Graph \u00b6 Open-source \u00b6 Nebula Graph is open under the Apache 2.0 and the Commons Clause 1.0 licenses. More and more people such as database developers, data scientists, security experts, and algorithm engineers are participating in the designing and development of Nebula Graph. To join the opening of source code and ideas, surf the Nebula Graph GitHub page . Outstanding performance \u00b6 Written in C++ and born for graph, Nebula Graph handles graph queries in milliseconds. Among most databases, Nebula Graph shows superior performance in providing graph data services. The larger the data size, the greater the superiority of Nebula Graph. For more information, see Nebula Graph benchmarking . Developer friendly \u00b6 Nebula Graph supports clients in popular programming languages like Java, Python, C++, and Go, and more are being developed. For more information, see Nebula Graph clients [TODO]. Diversified ecosystem \u00b6 More and more native tools of Nebula Graph have been released, such as Nebula Graph Studio , nebula-console , and Nebula Graph Exchange . Besides, Nebula Graph has the ability to be integrated with many cutting-edge technologies, such as Spark, Flink, and HBase, for the purpose of mutual strengthening in a world of increasing challenges and chances. For more information, see Ecosystem development [TODO]. OpenCypher-compatible query language \u00b6 The native Nebula Graph Query Language, also known as nGQL, is a declarative, openCypher-compatible textual query language. It is easy to understand and easy to use. For more information, see nGQL guide . Easy data modeling and high flexibility \u00b6 You can easily model the connected data into Nebula Graph for your business without forcing them into a structure such as a relational table, and properties can be added, updated, and deleted freely. For more information, see Data modeling [TODO]. Reliable access control \u00b6 Nebula Graph supports strict role-based access control and external authentication servers such as LDAP (Lightweight Directory Access Protocol) servers to enhance data security. For more information, see Authentication and authorization [TODO]. High scalability \u00b6 Nebula Graph is designed in a shared-nothing architecture and supports scaling in and out without interrupting the database service. High popularity \u00b6 Nebula Graph is being used by tech leaders such as Tencent, Vivo, Meituan, and JD Digits. For more information, visit the Nebula Graph official website . Use cases \u00b6 Nebula Graph can be used to support various graph-based scenarios. To spare the time spent on pushing the kinds of data mentioned in this section into relational databases and on bothering with join queries, use Nebula Graph. Fraud detection \u00b6 Financial institutions have to traverse countless transactions to piece together potential crimes and understand how combinations of transactions and devices might be related to a single fraud scheme. This kind of scenario can be modeled in graphs, and with the help of Nebula Graph, fraud rings and other sophisticated scams can be easily detected. Real-time recommendation \u00b6 Nebula Graph offers the ability to instantly process the real-time information produced by a visitor and make accurate recommendations on articles, videos, products, and services. Intelligent question-answer system \u00b6 Natural languages can be transformed into knowledge graphs and stored in Nebula Graph. A question organized in a natural language can be resolved by a semantic parser in an intelligent question-answer system and re-organized. Then, possible answers to the question can be retrieved from the knowledge graph and provided to the one who asked the question. Social networking \u00b6 Information on people and their relationships are typical graph data. Nebula Graph can easily handle the social networking information of billions of people and trillions of relationships, and provide lightning-fast queries for friend recommendations and job promotions in the case of massive concurrency.","title":"What is Nebula Graph"},{"location":"1.introduction/1.what-is-nebula-graph/#what_is_nebula_graph","text":"Nebula Graph is an open-source, distributed, easily scalable, and native graph database. It is capable of hosting graphs with billions of vertices and trillions of edges, and serving queries with millisecond-latency.","title":"What is Nebula Graph"},{"location":"1.introduction/1.what-is-nebula-graph/#what_is_a_graph_database","text":"A graph database, such as Nebula Graph, is a database that specializes in storing vast graph networks and retrieving information from them. It efficiently stores data as vertices (nodes) and edges (relationships) in labeled property graphs. Properties can be attached to both vertices and edges. Each vertex can have one or multiple tags (labels). Graph databases are well suited for storing most kinds of data models abstracted from reality. Things are connected in almost all fields in the world. Modeling systems like relational databases extract the relationships between entities and squeeze them into table columns alone, with their types and properties stored in other columns or even other tables. This makes the data management time-consuming and cost-ineffective. Nebula Graph, as a typical native graph database, allows you to store the rich relationships as edges with edge types and properties directly attached to them.","title":"What is a graph database"},{"location":"1.introduction/1.what-is-nebula-graph/#benefits_of_nebula_graph","text":"","title":"Benefits of Nebula Graph"},{"location":"1.introduction/1.what-is-nebula-graph/#open-source","text":"Nebula Graph is open under the Apache 2.0 and the Commons Clause 1.0 licenses. More and more people such as database developers, data scientists, security experts, and algorithm engineers are participating in the designing and development of Nebula Graph. To join the opening of source code and ideas, surf the Nebula Graph GitHub page .","title":"Open-source"},{"location":"1.introduction/1.what-is-nebula-graph/#outstanding_performance","text":"Written in C++ and born for graph, Nebula Graph handles graph queries in milliseconds. Among most databases, Nebula Graph shows superior performance in providing graph data services. The larger the data size, the greater the superiority of Nebula Graph. For more information, see Nebula Graph benchmarking .","title":"Outstanding performance"},{"location":"1.introduction/1.what-is-nebula-graph/#developer_friendly","text":"Nebula Graph supports clients in popular programming languages like Java, Python, C++, and Go, and more are being developed. For more information, see Nebula Graph clients [TODO].","title":"Developer friendly"},{"location":"1.introduction/1.what-is-nebula-graph/#diversified_ecosystem","text":"More and more native tools of Nebula Graph have been released, such as Nebula Graph Studio , nebula-console , and Nebula Graph Exchange . Besides, Nebula Graph has the ability to be integrated with many cutting-edge technologies, such as Spark, Flink, and HBase, for the purpose of mutual strengthening in a world of increasing challenges and chances. For more information, see Ecosystem development [TODO].","title":"Diversified ecosystem"},{"location":"1.introduction/1.what-is-nebula-graph/#opencypher-compatible_query_language","text":"The native Nebula Graph Query Language, also known as nGQL, is a declarative, openCypher-compatible textual query language. It is easy to understand and easy to use. For more information, see nGQL guide .","title":"OpenCypher-compatible query language"},{"location":"1.introduction/1.what-is-nebula-graph/#easy_data_modeling_and_high_flexibility","text":"You can easily model the connected data into Nebula Graph for your business without forcing them into a structure such as a relational table, and properties can be added, updated, and deleted freely. For more information, see Data modeling [TODO].","title":"Easy data modeling and high flexibility"},{"location":"1.introduction/1.what-is-nebula-graph/#reliable_access_control","text":"Nebula Graph supports strict role-based access control and external authentication servers such as LDAP (Lightweight Directory Access Protocol) servers to enhance data security. For more information, see Authentication and authorization [TODO].","title":"Reliable access control"},{"location":"1.introduction/1.what-is-nebula-graph/#high_scalability","text":"Nebula Graph is designed in a shared-nothing architecture and supports scaling in and out without interrupting the database service.","title":"High scalability"},{"location":"1.introduction/1.what-is-nebula-graph/#high_popularity","text":"Nebula Graph is being used by tech leaders such as Tencent, Vivo, Meituan, and JD Digits. For more information, visit the Nebula Graph official website .","title":"High popularity"},{"location":"1.introduction/1.what-is-nebula-graph/#use_cases","text":"Nebula Graph can be used to support various graph-based scenarios. To spare the time spent on pushing the kinds of data mentioned in this section into relational databases and on bothering with join queries, use Nebula Graph.","title":"Use cases"},{"location":"1.introduction/1.what-is-nebula-graph/#fraud_detection","text":"Financial institutions have to traverse countless transactions to piece together potential crimes and understand how combinations of transactions and devices might be related to a single fraud scheme. This kind of scenario can be modeled in graphs, and with the help of Nebula Graph, fraud rings and other sophisticated scams can be easily detected.","title":"Fraud detection"},{"location":"1.introduction/1.what-is-nebula-graph/#real-time_recommendation","text":"Nebula Graph offers the ability to instantly process the real-time information produced by a visitor and make accurate recommendations on articles, videos, products, and services.","title":"Real-time recommendation"},{"location":"1.introduction/1.what-is-nebula-graph/#intelligent_question-answer_system","text":"Natural languages can be transformed into knowledge graphs and stored in Nebula Graph. A question organized in a natural language can be resolved by a semantic parser in an intelligent question-answer system and re-organized. Then, possible answers to the question can be retrieved from the knowledge graph and provided to the one who asked the question.","title":"Intelligent question-answer system"},{"location":"1.introduction/1.what-is-nebula-graph/#social_networking","text":"Information on people and their relationships are typical graph data. Nebula Graph can easily handle the social networking information of billions of people and trillions of relationships, and provide lightning-fast queries for friend recommendations and job promotions in the case of massive concurrency.","title":"Social networking"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/","text":"Architecture overview \u00b6 Nebula Graph consists of three services: the Graph Service, the Storage Service, and the Meta Service. Each service has its executable binaries and processes launched from the binaries. You can deploy a Nebula Graph cluster on a single machine or multiple machines using these binaries. The following figure shows the architecture of a typical Nebula Graph cluster. The Meta Service \u00b6 The Meta Service in the Nebula Graph architecture is run by the nebula-metad processes. It is responsible for metadata management, such as schema operations, cluster administration, and user privilege management. For details on the Meta Service, see Meta Service . The Graph Service and the Storage Service \u00b6 Nebula Graph applies a disaggregated storage and compute architecture. The Graph Service is responsible for querying. The Storage Service is responsible for storage. And they run on different processes, i.e., nebula-graphd and nebula-storaged. The benefits of disaggregated storage and compute are as follows: Great scalability. A disaggregated structure makes both the Graph Service and the Storage Service flexible and easy to scale in or out. High availability. If part of the Graph Service fails, the data stored by the Storage Service suffers no loss. And if the rest part of the Graph Service is still able to serve the clients, service recovery can be performed quickly, or even unfelt by the users. Cost-effective. The separation of computing and storage provides a higher resource utilization rate, and it enables you to manage the cost flexibly according to business demands. The cost savings can be more significant if you use the Nebula Graph Cloud service. Open to more possibilities. With the ability to run separately, the Graph Service may work with multiple types of storage engines, and the Storage Service may serve more types of computing engines. For details on the Graph Service and the Storage Service, see Graph Service (TODO) and Storage Service (TODO).","title":"Architecture overview"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/#architecture_overview","text":"Nebula Graph consists of three services: the Graph Service, the Storage Service, and the Meta Service. Each service has its executable binaries and processes launched from the binaries. You can deploy a Nebula Graph cluster on a single machine or multiple machines using these binaries. The following figure shows the architecture of a typical Nebula Graph cluster.","title":"Architecture overview"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/#the_meta_service","text":"The Meta Service in the Nebula Graph architecture is run by the nebula-metad processes. It is responsible for metadata management, such as schema operations, cluster administration, and user privilege management. For details on the Meta Service, see Meta Service .","title":"The Meta Service"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/#the_graph_service_and_the_storage_service","text":"Nebula Graph applies a disaggregated storage and compute architecture. The Graph Service is responsible for querying. The Storage Service is responsible for storage. And they run on different processes, i.e., nebula-graphd and nebula-storaged. The benefits of disaggregated storage and compute are as follows: Great scalability. A disaggregated structure makes both the Graph Service and the Storage Service flexible and easy to scale in or out. High availability. If part of the Graph Service fails, the data stored by the Storage Service suffers no loss. And if the rest part of the Graph Service is still able to serve the clients, service recovery can be performed quickly, or even unfelt by the users. Cost-effective. The separation of computing and storage provides a higher resource utilization rate, and it enables you to manage the cost flexibly according to business demands. The cost savings can be more significant if you use the Nebula Graph Cloud service. Open to more possibilities. With the ability to run separately, the Graph Service may work with multiple types of storage engines, and the Storage Service may serve more types of computing engines. For details on the Graph Service and the Storage Service, see Graph Service (TODO) and Storage Service (TODO).","title":"The Graph Service and the Storage Service"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/","text":"Meta Service \u00b6 This topic describes the architecture and functions of the Meta Service. The architecture of the Meta Service \u00b6 The architecture of the Meta Service is as follows. The Meta Service is run by the nebula-metad processes. You can deploy nebula-metad processes according to the scenario: In a test environment, you can deploy one or three nebula-metad processes on different machines or a single machine. In a production environment, we recommend that you deploy three processes on different machines for high availability. All the nebula-metad processes form a Raft-based cluster, with one process as the leader and the others as the followers. The leader is elected by quorum, and only the leader can provide service to the clients and other components of Nebula Graph. The followers run in a standby way and each has a data replication of the leader. Once the leader fails, one of the followers will be elected as the new leader. Functions of the Meta Service \u00b6 Manages user accounts \u00b6 The Meta Service stores the information of user accounts and the privileges granted to the accounts. When the clients send queries to the Graph Service through an account, the Graph Service checks the account information and whether the account has the right privileges to execute the queries or not. For more information on Nebula Graph access control, see Authentication and authorization (TODO). Manages partitions \u00b6 The Meta Service stores and manages the locations of the storage partitions and helps balance the partitions. Manages graph spaces \u00b6 Nebula Graph supports multiple graph spaces. Data stored in different graph spaces are securely isolated. The Meta Service stores the metadata of all graph spaces and tracks the changes of them, such as adding or dropping a graph space. Manages schema information \u00b6 Nebula Graph is a strong-typed graph database. Its schema contains tags (i.e., the vertex types), edge types, tag properties, and edge type properties. The Meta Service stores the schema information. Besides, it performs the addition, modification, and deletion of the schema, and logs the versions of them. For more information on Nebula Graph schema, see Nebula Graph schema and data modeling (TODO). Manages TTL-based data eviction \u00b6 The Meta Service provides automatic data eviction and space reclamation based on TTL (time to live) options for Nebula Graph. For more information on TTL, see TTL options (TODO). Manages jobs \u00b6 The Job Manager module in the Meta Service is responsible for the creation, queuing, querying and deletion of jobs.","title":"Meta Service"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#meta_service","text":"This topic describes the architecture and functions of the Meta Service.","title":"Meta Service"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#the_architecture_of_the_meta_service","text":"The architecture of the Meta Service is as follows. The Meta Service is run by the nebula-metad processes. You can deploy nebula-metad processes according to the scenario: In a test environment, you can deploy one or three nebula-metad processes on different machines or a single machine. In a production environment, we recommend that you deploy three processes on different machines for high availability. All the nebula-metad processes form a Raft-based cluster, with one process as the leader and the others as the followers. The leader is elected by quorum, and only the leader can provide service to the clients and other components of Nebula Graph. The followers run in a standby way and each has a data replication of the leader. Once the leader fails, one of the followers will be elected as the new leader.","title":"The architecture of the Meta Service"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#functions_of_the_meta_service","text":"","title":"Functions of the Meta Service"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_user_accounts","text":"The Meta Service stores the information of user accounts and the privileges granted to the accounts. When the clients send queries to the Graph Service through an account, the Graph Service checks the account information and whether the account has the right privileges to execute the queries or not. For more information on Nebula Graph access control, see Authentication and authorization (TODO).","title":"Manages user accounts"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_partitions","text":"The Meta Service stores and manages the locations of the storage partitions and helps balance the partitions.","title":"Manages partitions"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_graph_spaces","text":"Nebula Graph supports multiple graph spaces. Data stored in different graph spaces are securely isolated. The Meta Service stores the metadata of all graph spaces and tracks the changes of them, such as adding or dropping a graph space.","title":"Manages graph spaces"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_schema_information","text":"Nebula Graph is a strong-typed graph database. Its schema contains tags (i.e., the vertex types), edge types, tag properties, and edge type properties. The Meta Service stores the schema information. Besides, it performs the addition, modification, and deletion of the schema, and logs the versions of them. For more information on Nebula Graph schema, see Nebula Graph schema and data modeling (TODO).","title":"Manages schema information"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_ttl-based_data_eviction","text":"The Meta Service provides automatic data eviction and space reclamation based on TTL (time to live) options for Nebula Graph. For more information on TTL, see TTL options (TODO).","title":"Manages TTL-based data eviction"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_jobs","text":"The Job Manager module in the Meta Service is responsible for the creation, queuing, querying and deletion of jobs.","title":"Manages jobs"},{"location":"2.quick-start/1.quick-start-workflow/","text":"Quick start workflow \u00b6 The quick start introduces the simplest workflow to using Nebula Graph, including deploying Nebula Graph, connecting to Nebula Graph, and doing basic CRUD. Deploy Nebula Graph with Docker Compose Connect to Nebula Graph CRUD in Nebula Graph Other frequently read topics are recommended as follows. They are not in the quick start, but you may need them as soon as you pass the quick start phase. Deploy a Nebula Graph cluster [TODO] Compaction and job management [TODO]","title":"Quick start workflow"},{"location":"2.quick-start/1.quick-start-workflow/#quick_start_workflow","text":"The quick start introduces the simplest workflow to using Nebula Graph, including deploying Nebula Graph, connecting to Nebula Graph, and doing basic CRUD. Deploy Nebula Graph with Docker Compose Connect to Nebula Graph CRUD in Nebula Graph Other frequently read topics are recommended as follows. They are not in the quick start, but you may need them as soon as you pass the quick start phase. Deploy a Nebula Graph cluster [TODO] Compaction and job management [TODO]","title":"Quick start workflow"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/","text":"Deploy Nebula Graph with Docker Compose \u00b6 There are multiple ways to deploy Nebula Graph, but using Docker Compose is usually considered to be a fast starter. Reading guide \u00b6 If you are reading this topic with the questions listed below, click them to jump to their answers. What do I need to do before deploying Nebula Graph? How to fast deploy Nebula Graph with Docker Compose? How to check the status and ports of the Nebula Graph services? How to check the data and logs of the Nebula Graph services? How to stop the Nebula Graph services? What are the other ways to install Nebula Graph? Prerequisites \u00b6 You have installed the following applications on your host. Application Recommended version Official installation reference Docker Latest Install Docker Engine Docker Compose Latest Install Docker Compose Git Latest Download Git If you are deploying Nebula Graph as a non-root user, grant the user with Docker-related privileges. For a detailed instruction, see Docker docs: Manage Docker as a non-root user . You have started the Docker service on your host. If you have already deployed another version of Nebula Graph with Docker Compose on your host, to avoid compatibility issues\uff0cback up the service data if you need, and delete the nebula-docker-compose/data directory. How to deploy \u00b6 Clone the v2-preview branch of the nebula-docker-compose repository to your host with Git. [TODO: Update the branch name on the release on 2.0.0-alpha.] DON'T : The v2-preview branch stores the Docker Compose solution for the latest Nebula Graph development release, the 2.0.0-alpha. DON'T use this release for production. $ git clone --branch v2-preview https://github.com/vesoft-inc/nebula-docker-compose.git Go to the nebula-docker-compose directory. $ cd nebula-docker-compose/ Run the following command to start all the Nebula Graph services. $ docker-compose up -d The following information indicates the services have started: Creating network \"nebula-docker-compose_nebula-net\" with the default driver Creating nebula-docker-compose_metad1_1 ... done Creating nebula-docker-compose_metad2_1 ... done Creating nebula-docker-compose_metad0_1 ... done Creating nebula-docker-compose_storaged2_1 ... done Creating nebula-docker-compose_graphd2_1 ... done Creating nebula-docker-compose_storaged1_1 ... done Creating nebula-docker-compose_graphd_1 ... done Creating nebula-docker-compose_graphd1_1 ... done Creating nebula-docker-compose_storaged0_1 ... done NOTE : For more information of the preceding services, see Design and Architecture of Nebula Graph . Use nebula-console to connect to Nebula Graph. Nebula-console is the native CLI client of Nebula Graph. In this step, Docker pulls the nebula-console images automatically from Docker Hub according to the path you set in the following commands and uses it to connect to the Graph Service of Nebula Graph. $ docker run --rm -ti --network nebula-docker-compose_nebula-net vesoft/nebula-console:v2-preview-nightly --address = graphd --port = 3699 -u <username> -p <password> [TODO: Update the docker image tag on the release of 2.0 alpha.] NOTE : By default, the authentication is disabled. You can use any username or password to connect to Nebula Graph. When the authentication is enabled, use the default username root and its password nebula . The following information indicates that you have connected to the Nebula Graph services: Welcome to Nebula Graph v2.0.0-alpha! ( user@nebula ) [( none )] > Check the Nebula Graph service status and port \u00b6 Run docker-compose ps to list all the services of Nebula Graph and their status and ports. $ docker-compose ps Name Command State Ports --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- nebula-docker-compose_graphd1_1 ./bin/nebula-graphd --flag ... Up ( healthy ) 0 .0.0.0:32776->13000/tcp, 0 .0.0.0:32772->13002/tcp, 0 .0.0.0:32780->3699/tcp nebula-docker-compose_graphd2_1 ./bin/nebula-graphd --flag ... Up ( healthy ) 0 .0.0.0:32769->13000/tcp, 0 .0.0.0:32768->13002/tcp, 0 .0.0.0:32773->3699/tcp nebula-docker-compose_graphd_1 ./bin/nebula-graphd --flag ... Up ( healthy ) 0 .0.0.0:32791->13000/tcp, 0 .0.0.0:32788->13002/tcp, 0 .0.0.0:32794->3699/tcp nebula-docker-compose_metad0_1 ./bin/nebula-metad --flagf ... Up ( healthy ) 0 .0.0.0:32793->11000/tcp, 0 .0.0.0:32790->11002/tcp, 0 .0.0.0:32787->45500/tcp, 45501 /tcp nebula-docker-compose_metad1_1 ./bin/nebula-metad --flagf ... Up ( healthy ) 0 .0.0.0:32792->11000/tcp, 0 .0.0.0:32789->11002/tcp, 0 .0.0.0:32786->45500/tcp, 45501 /tcp nebula-docker-compose_metad2_1 ./bin/nebula-metad --flagf ... Up ( healthy ) 0 .0.0.0:32785->11000/tcp, 0 .0.0.0:32784->11002/tcp, 0 .0.0.0:32782->45500/tcp, 45501 /tcp nebula-docker-compose_storaged0_1 ./bin/nebula-storaged --fl ... Up ( healthy ) 0 .0.0.0:32777->12000/tcp, 0 .0.0.0:32774->12002/tcp, 0 .0.0.0:32770->44500/tcp, 44501 /tcp nebula-docker-compose_storaged1_1 ./bin/nebula-storaged --fl ... Up ( healthy ) 0 .0.0.0:32778->12000/tcp, 0 .0.0.0:32775->12002/tcp, 0 .0.0.0:32771->44500/tcp, 44501 /tcp nebula-docker-compose_storaged2_1 ./bin/nebula-storaged --fl ... Up ( healthy ) 0 .0.0.0:32783->12000/tcp, 0 .0.0.0:32781->12002/tcp, 0 .0.0.0:32779->44500/tcp, 44501 /tcp NOTE : Nebula Graph provides services to the clients through port 3699 by default. You can adjust the port number by modifying the network configurations . To check the machine status and partition distribution, run the SHOW HOSTS statement. Check the service data and logs \u00b6 All the data and logs of Nebula Graph are stored persistently in the nebula-docker-compose/data and nebula-docker-compose/logs directories. The structure of the directories is as follows: nebula-docker-compose/ |-- docker-compose.yaml \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 meta0 \u2502 \u251c\u2500\u2500 meta1 \u2502 \u251c\u2500\u2500 meta2 \u2502 \u251c\u2500\u2500 storage0 \u2502 \u251c\u2500\u2500 storage1 \u2502 \u2514\u2500\u2500 storage2 \u2514\u2500\u2500 logs \u251c\u2500\u2500 graph \u251c\u2500\u2500 graph1 \u251c\u2500\u2500 graph2 \u251c\u2500\u2500 meta0 \u251c\u2500\u2500 meta1 \u251c\u2500\u2500 meta2 \u251c\u2500\u2500 storage0 \u251c\u2500\u2500 storage1 \u2514\u2500\u2500 storage2 Stop the Nebula Graph services \u00b6 You can run the following command to stop the Nebula Graph services: $ docker-compose down The following information indicates you have successfully stopped the Nebula Graph services: Stopping nebula-docker-compose_storaged0_1 ... done Stopping nebula-docker-compose_graphd1_1 ... done Stopping nebula-docker-compose_graphd_1 ... done Stopping nebula-docker-compose_storaged1_1 ... done Stopping nebula-docker-compose_graphd2_1 ... done Stopping nebula-docker-compose_storaged2_1 ... done Stopping nebula-docker-compose_metad0_1 ... done Stopping nebula-docker-compose_metad2_1 ... done Stopping nebula-docker-compose_metad1_1 ... done Removing nebula-docker-compose_storaged0_1 ... done Removing nebula-docker-compose_graphd1_1 ... done Removing nebula-docker-compose_graphd_1 ... done Removing nebula-docker-compose_storaged1_1 ... done Removing nebula-docker-compose_graphd2_1 ... done Removing nebula-docker-compose_storaged2_1 ... done Removing nebula-docker-compose_metad0_1 ... done Removing nebula-docker-compose_metad2_1 ... done Removing nebula-docker-compose_metad1_1 ... done Removing network nebula-docker-compose_nebula-net Other ways to install Nebula Graph \u00b6 Use Source Code (TODO) Use Docker (TODO) Use .rpm or .deb Files (TODO) FAQ \u00b6 Q1: How to update the nebula-console client \u00b6 To update the nebula-console client, use the docker pull command in the nebula-docker-compose directory on your host. docker pull vesoft/nebula-console:v2-preview-nightly Q2: How to update the docker images of Nebula Graph services \u00b6 To update the images of the Graph Service, Storage Service, and Meta Service, run docker-compose pull in the nebula-docker-compose directory.","title":"Deploy Nebula\u00a0Graph with Docker Compose"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#deploy_nebula_graph_with_docker_compose","text":"There are multiple ways to deploy Nebula Graph, but using Docker Compose is usually considered to be a fast starter.","title":"Deploy Nebula Graph with Docker Compose"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#reading_guide","text":"If you are reading this topic with the questions listed below, click them to jump to their answers. What do I need to do before deploying Nebula Graph? How to fast deploy Nebula Graph with Docker Compose? How to check the status and ports of the Nebula Graph services? How to check the data and logs of the Nebula Graph services? How to stop the Nebula Graph services? What are the other ways to install Nebula Graph?","title":"Reading guide"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#prerequisites","text":"You have installed the following applications on your host. Application Recommended version Official installation reference Docker Latest Install Docker Engine Docker Compose Latest Install Docker Compose Git Latest Download Git If you are deploying Nebula Graph as a non-root user, grant the user with Docker-related privileges. For a detailed instruction, see Docker docs: Manage Docker as a non-root user . You have started the Docker service on your host. If you have already deployed another version of Nebula Graph with Docker Compose on your host, to avoid compatibility issues\uff0cback up the service data if you need, and delete the nebula-docker-compose/data directory.","title":"Prerequisites"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#how_to_deploy","text":"Clone the v2-preview branch of the nebula-docker-compose repository to your host with Git. [TODO: Update the branch name on the release on 2.0.0-alpha.] DON'T : The v2-preview branch stores the Docker Compose solution for the latest Nebula Graph development release, the 2.0.0-alpha. DON'T use this release for production. $ git clone --branch v2-preview https://github.com/vesoft-inc/nebula-docker-compose.git Go to the nebula-docker-compose directory. $ cd nebula-docker-compose/ Run the following command to start all the Nebula Graph services. $ docker-compose up -d The following information indicates the services have started: Creating network \"nebula-docker-compose_nebula-net\" with the default driver Creating nebula-docker-compose_metad1_1 ... done Creating nebula-docker-compose_metad2_1 ... done Creating nebula-docker-compose_metad0_1 ... done Creating nebula-docker-compose_storaged2_1 ... done Creating nebula-docker-compose_graphd2_1 ... done Creating nebula-docker-compose_storaged1_1 ... done Creating nebula-docker-compose_graphd_1 ... done Creating nebula-docker-compose_graphd1_1 ... done Creating nebula-docker-compose_storaged0_1 ... done NOTE : For more information of the preceding services, see Design and Architecture of Nebula Graph . Use nebula-console to connect to Nebula Graph. Nebula-console is the native CLI client of Nebula Graph. In this step, Docker pulls the nebula-console images automatically from Docker Hub according to the path you set in the following commands and uses it to connect to the Graph Service of Nebula Graph. $ docker run --rm -ti --network nebula-docker-compose_nebula-net vesoft/nebula-console:v2-preview-nightly --address = graphd --port = 3699 -u <username> -p <password> [TODO: Update the docker image tag on the release of 2.0 alpha.] NOTE : By default, the authentication is disabled. You can use any username or password to connect to Nebula Graph. When the authentication is enabled, use the default username root and its password nebula . The following information indicates that you have connected to the Nebula Graph services: Welcome to Nebula Graph v2.0.0-alpha! ( user@nebula ) [( none )] >","title":"How to deploy"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#check_the_nebula_graph_service_status_and_port","text":"Run docker-compose ps to list all the services of Nebula Graph and their status and ports. $ docker-compose ps Name Command State Ports --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- nebula-docker-compose_graphd1_1 ./bin/nebula-graphd --flag ... Up ( healthy ) 0 .0.0.0:32776->13000/tcp, 0 .0.0.0:32772->13002/tcp, 0 .0.0.0:32780->3699/tcp nebula-docker-compose_graphd2_1 ./bin/nebula-graphd --flag ... Up ( healthy ) 0 .0.0.0:32769->13000/tcp, 0 .0.0.0:32768->13002/tcp, 0 .0.0.0:32773->3699/tcp nebula-docker-compose_graphd_1 ./bin/nebula-graphd --flag ... Up ( healthy ) 0 .0.0.0:32791->13000/tcp, 0 .0.0.0:32788->13002/tcp, 0 .0.0.0:32794->3699/tcp nebula-docker-compose_metad0_1 ./bin/nebula-metad --flagf ... Up ( healthy ) 0 .0.0.0:32793->11000/tcp, 0 .0.0.0:32790->11002/tcp, 0 .0.0.0:32787->45500/tcp, 45501 /tcp nebula-docker-compose_metad1_1 ./bin/nebula-metad --flagf ... Up ( healthy ) 0 .0.0.0:32792->11000/tcp, 0 .0.0.0:32789->11002/tcp, 0 .0.0.0:32786->45500/tcp, 45501 /tcp nebula-docker-compose_metad2_1 ./bin/nebula-metad --flagf ... Up ( healthy ) 0 .0.0.0:32785->11000/tcp, 0 .0.0.0:32784->11002/tcp, 0 .0.0.0:32782->45500/tcp, 45501 /tcp nebula-docker-compose_storaged0_1 ./bin/nebula-storaged --fl ... Up ( healthy ) 0 .0.0.0:32777->12000/tcp, 0 .0.0.0:32774->12002/tcp, 0 .0.0.0:32770->44500/tcp, 44501 /tcp nebula-docker-compose_storaged1_1 ./bin/nebula-storaged --fl ... Up ( healthy ) 0 .0.0.0:32778->12000/tcp, 0 .0.0.0:32775->12002/tcp, 0 .0.0.0:32771->44500/tcp, 44501 /tcp nebula-docker-compose_storaged2_1 ./bin/nebula-storaged --fl ... Up ( healthy ) 0 .0.0.0:32783->12000/tcp, 0 .0.0.0:32781->12002/tcp, 0 .0.0.0:32779->44500/tcp, 44501 /tcp NOTE : Nebula Graph provides services to the clients through port 3699 by default. You can adjust the port number by modifying the network configurations . To check the machine status and partition distribution, run the SHOW HOSTS statement.","title":"Check the Nebula Graph service status and port"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#check_the_service_data_and_logs","text":"All the data and logs of Nebula Graph are stored persistently in the nebula-docker-compose/data and nebula-docker-compose/logs directories. The structure of the directories is as follows: nebula-docker-compose/ |-- docker-compose.yaml \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 meta0 \u2502 \u251c\u2500\u2500 meta1 \u2502 \u251c\u2500\u2500 meta2 \u2502 \u251c\u2500\u2500 storage0 \u2502 \u251c\u2500\u2500 storage1 \u2502 \u2514\u2500\u2500 storage2 \u2514\u2500\u2500 logs \u251c\u2500\u2500 graph \u251c\u2500\u2500 graph1 \u251c\u2500\u2500 graph2 \u251c\u2500\u2500 meta0 \u251c\u2500\u2500 meta1 \u251c\u2500\u2500 meta2 \u251c\u2500\u2500 storage0 \u251c\u2500\u2500 storage1 \u2514\u2500\u2500 storage2","title":"Check the service data and logs"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#stop_the_nebula_graph_services","text":"You can run the following command to stop the Nebula Graph services: $ docker-compose down The following information indicates you have successfully stopped the Nebula Graph services: Stopping nebula-docker-compose_storaged0_1 ... done Stopping nebula-docker-compose_graphd1_1 ... done Stopping nebula-docker-compose_graphd_1 ... done Stopping nebula-docker-compose_storaged1_1 ... done Stopping nebula-docker-compose_graphd2_1 ... done Stopping nebula-docker-compose_storaged2_1 ... done Stopping nebula-docker-compose_metad0_1 ... done Stopping nebula-docker-compose_metad2_1 ... done Stopping nebula-docker-compose_metad1_1 ... done Removing nebula-docker-compose_storaged0_1 ... done Removing nebula-docker-compose_graphd1_1 ... done Removing nebula-docker-compose_graphd_1 ... done Removing nebula-docker-compose_storaged1_1 ... done Removing nebula-docker-compose_graphd2_1 ... done Removing nebula-docker-compose_storaged2_1 ... done Removing nebula-docker-compose_metad0_1 ... done Removing nebula-docker-compose_metad2_1 ... done Removing nebula-docker-compose_metad1_1 ... done Removing network nebula-docker-compose_nebula-net","title":"Stop the Nebula Graph services"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#other_ways_to_install_nebula_graph","text":"Use Source Code (TODO) Use Docker (TODO) Use .rpm or .deb Files (TODO)","title":"Other ways to install Nebula Graph"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#faq","text":"","title":"FAQ"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#q1_how_to_update_the_nebula-console_client","text":"To update the nebula-console client, use the docker pull command in the nebula-docker-compose directory on your host. docker pull vesoft/nebula-console:v2-preview-nightly","title":"Q1: How to update the nebula-console client"},{"location":"2.quick-start/2.deploy-nebula-graph-with-docker-compose/#q2_how_to_update_the_docker_images_of_nebula_graph_services","text":"To update the images of the Graph Service, Storage Service, and Meta Service, run docker-compose pull in the nebula-docker-compose directory.","title":"Q2: How to update the docker images of Nebula Graph services"},{"location":"2.quick-start/3.connect-to-nebula-graph/","text":"Connect to Nebula Graph \u00b6 Nebula Graph supports multiple types of clients, including a CLI client, a GUI client, and clients developed in popular programming languages. This topic provides an overview of Nebula Graph clients and a basic instruction on how to use the native CLI client, nebula-console. Nebula Graph clients \u00b6 Client Introduction Connection guide nebula-console The native command-line interface of Nebula Graph Connect to Nebula Graph with nebula-console Nebula Graph Studio The official graphical user interface for Nebula Graph Connect to Nebula Graph with Nebula Graph Studio nebula-go The official Golang client of Nebula Graph nebula-go code example nebula-python The official Python client of Nebula Graph How to use nebula-python in your code nebula-java The official Python client of Nebula Graph Graph Client Example If you don't have a Nebula Graph database yet, we recommend that you try the cloud service. Nebula Graph Cloud Service supports on-demand deployment and fast building, and uses Nebula Graph Studio as its default client. Use nebula-console to connect to Nebula Graph \u00b6 Download the nebula-console binary file . Use the binary file to connect to Nebula Graph. $ ./nebula-console -addr <ip> -port <port> -u <username> -p <password> [ -t 120 ] [ -e \"nGQL_statement\" | -f filename.nGQL ] Option Description -h Show the help menu. -addr Sets the IP address of the graphd service. The default address is 127.0.0.1. -port Sets the port number of the graphd service. The default port number is 3699. -u/-user Sets the username of your Nebula Graph account. The default username is root. -p/-password Sets the password of your Nebula Graph account. The default password for the root user is nebula. -t/-timeout Sets an integer-type timeout threshold of the connection. The unit is second. The default value is 120. -e/-eval Sets a string-type nGQL statement. The nGQL statement is executed once the connection succeeds. The connection stops after the result is returned.. -f/-file Sets the path of an nGQL file. The nGQL statements in the file are executed once the connection succeeds. You'll get the return messages and the connection stops then. Nebula-console export mode \u00b6 When the export mode is enabled, nebula-console exports all the query results into a CSV file. When the export mode is disabled, the export stops. The syntax is as follows. NOTE : The following commands are case insensitive. Enable nebula-console export mode: nebula> :SET CSV <your_file.csv>; Disable nebula-console export mode: nebula> :UNSET CSV; Disconnect nebula-console from Nebula Graph \u00b6 You can use :EXIT or :QUIT to disconnect from Nebula Graph. For convenience, nebula-console supports using these commands in lower case without the colon (\":\"), such as quit . nebula> :QUIT Bye root! FAQ \u00b6 TODO [This section should include connection-related FAQs. When users meet a problem on connection, they should first come here for a solution. If the content gets stacked, remove this section to a single topic.]","title":"Connect to Nebula\u00a0Graph"},{"location":"2.quick-start/3.connect-to-nebula-graph/#connect_to_nebula_graph","text":"Nebula Graph supports multiple types of clients, including a CLI client, a GUI client, and clients developed in popular programming languages. This topic provides an overview of Nebula Graph clients and a basic instruction on how to use the native CLI client, nebula-console.","title":"Connect to Nebula Graph"},{"location":"2.quick-start/3.connect-to-nebula-graph/#nebula_graph_clients","text":"Client Introduction Connection guide nebula-console The native command-line interface of Nebula Graph Connect to Nebula Graph with nebula-console Nebula Graph Studio The official graphical user interface for Nebula Graph Connect to Nebula Graph with Nebula Graph Studio nebula-go The official Golang client of Nebula Graph nebula-go code example nebula-python The official Python client of Nebula Graph How to use nebula-python in your code nebula-java The official Python client of Nebula Graph Graph Client Example If you don't have a Nebula Graph database yet, we recommend that you try the cloud service. Nebula Graph Cloud Service supports on-demand deployment and fast building, and uses Nebula Graph Studio as its default client.","title":"Nebula Graph clients"},{"location":"2.quick-start/3.connect-to-nebula-graph/#use_nebula-console_to_connect_to_nebula_graph","text":"Download the nebula-console binary file . Use the binary file to connect to Nebula Graph. $ ./nebula-console -addr <ip> -port <port> -u <username> -p <password> [ -t 120 ] [ -e \"nGQL_statement\" | -f filename.nGQL ] Option Description -h Show the help menu. -addr Sets the IP address of the graphd service. The default address is 127.0.0.1. -port Sets the port number of the graphd service. The default port number is 3699. -u/-user Sets the username of your Nebula Graph account. The default username is root. -p/-password Sets the password of your Nebula Graph account. The default password for the root user is nebula. -t/-timeout Sets an integer-type timeout threshold of the connection. The unit is second. The default value is 120. -e/-eval Sets a string-type nGQL statement. The nGQL statement is executed once the connection succeeds. The connection stops after the result is returned.. -f/-file Sets the path of an nGQL file. The nGQL statements in the file are executed once the connection succeeds. You'll get the return messages and the connection stops then.","title":"Use nebula-console to connect to Nebula Graph"},{"location":"2.quick-start/3.connect-to-nebula-graph/#nebula-console_export_mode","text":"When the export mode is enabled, nebula-console exports all the query results into a CSV file. When the export mode is disabled, the export stops. The syntax is as follows. NOTE : The following commands are case insensitive. Enable nebula-console export mode: nebula> :SET CSV <your_file.csv>; Disable nebula-console export mode: nebula> :UNSET CSV;","title":"Nebula-console export mode"},{"location":"2.quick-start/3.connect-to-nebula-graph/#disconnect_nebula-console_from_nebula_graph","text":"You can use :EXIT or :QUIT to disconnect from Nebula Graph. For convenience, nebula-console supports using these commands in lower case without the colon (\":\"), such as quit . nebula> :QUIT Bye root!","title":"Disconnect nebula-console from Nebula Graph"},{"location":"2.quick-start/3.connect-to-nebula-graph/#faq","text":"TODO [This section should include connection-related FAQs. When users meet a problem on connection, they should first come here for a solution. If the content gets stacked, remove this section to a single topic.]","title":"FAQ"},{"location":"2.quick-start/4.nebula-graph-crud/","text":"Nebula Graph CRUD \u00b6 This topic describes the basic CRUD operations in Nebula Graph. Graph space and Nebula Graph schema \u00b6 A Nebula Graph instance consists of one or more graph spaces. Graph spaces are physically isolated from each other. You can use different graph spaces in the same instance to store different datasets. To insert data into a graph space, define a schema for the graph database. Nebula Graph schema is based on the following components. Schema component Description Vertex Represents an entity in the real world. A vertex can have one or more tags. Tag The type of a vertex. It defines a group of properties that describes a type of vertices. Edge Represents a directed relationship between two vertices. Edge type The type of an edge. It defines a group of properties that describes a type of edges. For more information, see Nebula Graph schema [TODO]. In this topic, we use the following dataset to demonstrate basic CRUD operations. Check the machine status in the Nebula Graph cluster \u00b6 First, we recommend that you check the machine status to make sure that all the Storage services are connected to the Meta Services. Run SHOW HOSTS as follows. (root@nebula) [(none)]> SHOW HOSTS; +-----------+-------+--------+--------------+---------------------+------------------------+ | Host | Port | Status | Leader count | Leader distribution | Partition distribution | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged0 | 44500 | ONLINE | 0 | No valid partition | No valid partition | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged1 | 44500 | ONLINE | 0 | No valid partition | No valid partition | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged2 | 44500 | ONLINE | 0 | No valid partition | No valid partition | +-----------+-------+--------+--------------+---------------------+------------------------+ Got 3 rows (time spent 1775/2334 us) From the Status column of the table in the return message, you can see that all the Storage services are online. Create and use a graph space \u00b6 nGQL syntax \u00b6 Create a graph space: CREATE SPACE <graph_space_name> [(partition_num=<partition number>, replica_factor=<replica number>), vid_type=fixed_string(<string_number>))] Property Description partition_num Specifies the number of partitions in each replica. The suggested number is the number of hard disks in the cluster times 5. For example, if you have 3 hard disks in the cluster, we recommend that you set 15 partitions. replica_factor Specifies the number of replicas in the Nebula Graph cluster. The suggested number is 3 in a production environment and 1 in a test environment. The replica number must always be an odd number for the need of quorum-based voting. vid_type To insert a vertex with a string-typed VID, set the fixed_string length for the maximum VID length. The default fixed_string is 8. Note: fix_string(N) is similar to varchar(N) in SQL. List graph spaces: nebula> SHOW SPACES; Use a graph space: USE <graph_space_name> Examples \u00b6 Use the following statement to create a graph space named nba . nebula> CREATE SPACE nba(partition_num=15, replica_factor=1, vid_type=fixed_string(30)); Execution succeeded (time spent 2817/3280 us) Check the partition distribution with SHOW HOSTS to make sure that the partitions are distributed in a balanced way. nebula> SHOW HOSTS; +-----------+-------+--------+--------------+---------------------+------------------------+ | Host | Port | Status | Leader count | Leader distribution | Partition distribution | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged0 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged1 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged2 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ Got 3 rows (time spent 744/1123 us) If the Leader distribution is uneven, use BALANCE LEADER to redistribute the partitions. For more information, see BALANCE [TODO]. Use the nba graph space. nebula> USE nba; Execution succeeded (time spent 1322/2206 us) You can use SHOW SPACES to check the graph space you created. nebula> SHOW SPACES; +------+ | Name | +------+ | nba | +------+ Got 1 rows (time spent 1235/1934 us) Create tags and edge types \u00b6 nGQL syntax \u00b6 CREATE {TAG | EDGE} {<tag_name> | <edge_type>}(<property_name> <data_type> [, <property_name> <data_type> ...]); Examples \u00b6 Create tags player and team , edge types follow and serve . Component name Type Property player Tag name (string), age (int) team Tag name (string) follow Edge type degree (int) serve Edge type start_year (int), end_year (int) nebula> CREATE TAG player(name string, age int); Execution succeeded (time spent 2694/3116 us) Thu, 15 Oct 2020 06:22:29 UTC nebula> CREATE TAG team(name string); Execution succeeded (time spent 2630/3002 us) Thu, 15 Oct 2020 06:22:37 UTC nebula> CREATE EDGE follow(degree int); Execution succeeded (time spent 3087/3467 us) Thu, 15 Oct 2020 06:22:43 UTC nebula> CREATE EDGE serve(start_year int, end_year int); Execution succeeded (time spent 2645/3123 us) Thu, 15 Oct 2020 06:22:50 UTC Insert vertices and edges \u00b6 You can use the INSERT statement to insert vertices or edges based on existing tags or edge types. nGQL syntax \u00b6 Insert vertices: INSERT VERTEX <tag_name> (<property_name>[, <property_name>...]) [, <tag_name> (<property_name>[, <property_name>...]), ...] {VALUES | VALUE} <vid>: (<property_value>[, <property_value>...]) [, <vid>: (<property_value>[, <property_value>...]; VID is short for vertex ID. A VID must be a unique string value in a graph space. Insert edges: INSERT EDGE <edge_type> (<property_name>[, <property_name>...]) {VALUES | VALUE} <src_vid> -> <dst_vid>[@<rank>] : (<property_value>[, <property_value>...]) [, <src_vid> -> <dst_vid>[@<rank> : (<property_name>[, <property_name>...]), ...] Examples \u00b6 Insert vertices representing NBA players and teams: nebula> INSERT VERTEX player(name, age) VALUES \"player100\":(\"Tim Duncan\", 42); Execution succeeded (time spent 2919/3485 us) Fri, 16 Oct 2020 03:41:00 UTC nebula> INSERT VERTEX player(name, age) VALUES \"player101\":(\"Tony Parker\", 36); Execution succeeded (time spent 3007/3539 us) Fri, 16 Oct 2020 03:41:58 UTC nebula> INSERT VERTEX player(name, age) VALUES \"player102\":(\"LaMarcus Aldridge\", 33); Execution succeeded (time spent 2449/2934 us) Fri, 16 Oct 2020 03:42:16 UTC nebula> INSERT VERTEX team(name) VALUES \"team200\":(\"Warriors\"), \"team201\":(\"Nuggets\"); Execution succeeded (time spent 3514/4331 us) Fri, 16 Oct 2020 03:42:45 UTC Insert edges representing the relations between NBA players and teams: nebula> INSERT EDGE follow(degree) VALUES \"player100\" -> \"player101\":(95); Execution succeeded (time spent 1488/1918 us) Wed, 21 Oct 2020 06:57:32 UTC nebula> INSERT EDGE follow(degree) VALUES \"player100\" -> \"player102\":(90); Execution succeeded (time spent 2483/2890 us) Wed, 21 Oct 2020 07:05:48 UTC nebula> INSERT EDGE follow(degree) VALUES \"player102\" -> \"player101\":(75); Execution succeeded (time spent 1208/1689 us) Wed, 21 Oct 2020 07:07:12 UTC nebula> INSERT EDGE serve(start_year, end_year) VALUES \"player100\" -> \"team200\":(1997, 2016), \"player101\" -> \"team201\":(1999, 2018); Execution succeeded (time spent 2170/2651 us) Wed, 21 Oct 2020 07:08:59 UTC Read data \u00b6 You can use the statements GO [TODO], FETCH [TODO], and LOOKUP [TODO] to retrieve vertex and edge data. GO is the most commonly used read statement. It traverses the database based on specific conditions. A GO traversal starts from one or more vertices, along one or more edges, and return information in a form specified in the YIELD clause. FETCH is used to get properties from vertices or edges. The LOOKUP statement is based on indexes . It is used together with the WHERE clause to search for the data that meet the specific conditions. nGQL syntax \u00b6 GO GO [[<M> TO] <N> STEPS ] FROM <vertex_list> OVER <edge_type_list> [REVERSELY] [BIDIRECT] [WHERE <expression> [AND | OR expression ...])] YIELD [DISTINCT] <return_list> FETCH Fetch properties on tags: FETCH PROP ON {<tag_name> | <tag_name_list> | *} <vid_list> [YIELD [DISTINCT] <return_list>] Fetch properties on edges: FETCH PROP ON <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <src_vid> -> <dst_vid> ...] [YIELD [DISTINCT] <return_list>] LOOKUP LOOKUP ON {<tag_name> | <edge_type>} WHERE <expression> [AND expression ...])] [YIELD <return_list>] Examples \u00b6 Use GO : Find the vertices that VID \"player100\" follows. nebula> GO FROM \"player100\" OVER follow; +-------------+ | follow._dst | +-------------+ | player101 | +-------------+ | player102 | +-------------+ Got 2 rows (time spent 1935/2420 us) Use GO : Search for the players that the player with VID \"player100\" follows. Filter the the players that the player with VID \"player100\" follows whose age is equal to or greater than 35. Rename the columns in the result with Teammate and Age . nebula> GO FROM \"player100\" OVER follow WHERE $$.player.age >= 35 \\ YIELD $$.player.name AS Teammate, $$.player.age AS Age; +-------------+-----+ | Teammate | Age | +-------------+-----+ | Tony Parker | 36 | +-------------+-----+ Got 1 rows (time spent 3871/4349 us) Clause/Sign Description YIELD Specifies what values or results you want to return from the query. $$ Represents the target vertices. \\ A line-breaker. Use GO : Search for the players that the player with VID \"player100\" follows. Then Retrieve the teams of the players that the player with VID \"player100\" follows. To combine the two queries, use a pipe or a temporary variable. With a pipe: nebula> GO FROM \"player100\" OVER follow YIELD follow._dst AS id | \\ GO FROM $-.id OVER serve YIELD $$.team.name AS Team, \\ $^.player.name AS Player; +---------+-------------+ | Team | Player | +---------+-------------+ | Nuggets | Tony Parker | +---------+-------------+ Got 1 rows (time spent 2902/3496 us) Clause/Sign Description $^ Represents the source vertex of the edge. \\ $- Represents the output of the query before the pipe symbol. With a temporary variable: NOTE : Once a compound statement is submitted to the server as a whole, the life cycle of the temporary variables in the statement ends. nebula> $var = GO FROM \"player100\" OVER follow YIELD follow._dst AS id; \\ GO FROM $var.id OVER serve YIELD $$.team.name AS Team, \\ $^.player.name AS Player; +---------+-------------+ | Team | Player | +---------+-------------+ | Nuggets | Tony Parker | +---------+-------------+ Got 1 rows (time spent 3103/3711 us) Use FETCH : Fetch the properties of the player with VID player100. nebula> FETCH PROP ON player \"player100\"; +----------+-------------+------------+ | VertexID | player.name | player.age | +----------+-------------+------------+ | player100 | Tim Duncan | 42 | +----------+-------------+------------+ Got 1 rows (time spent 2006/2406 us) Use LOOKUP : Find the information of the vertex with the tag player and its value of the name property is \"Tony Parker\" . nebula> LOOKUP ON player WHERE player.name == \"Tony Parker\" \\ YIELD player.name, player.age; Update vertices and edges \u00b6 You can use the UPDATE statement or the UPSERT statement to update existing data. UPSERT is the combination of UPDATE and INSERT . If you update a vertex or an edge with UPSERT , it inserts a new vertex or edge if it does not exist. nGQL syntax \u00b6 UPDATE vertices: UPDATE VERTEX <vid> SET <properties to be updated> [WHEN <condition>] [YIELD <columns>] UPDATE edges: UPDATE EDGE <source vid> -> <destination vid> [@rank] OF <edge_type> SET <properties to be updated> [WHEN <condition>] [YIELD <columns to be output>] UPSERT vertices or edges: UPSERT {VERTEX <vid> | EDGE <edge_type>} SET <update_columns> [WHEN <condition>] [YIELD <columns>] Examples \u00b6 UPDATE the name property of the vertex with VID \"player100\" and check the result with the FETCH statement: nebula> UPDATE VERTEX \"player100\" SET player.name = \"Tim\"; Execution succeeded (time spent 3483/3914 us) Wed, 21 Oct 2020 10:53:14 UTC nebula> FETCH PROP ON player \"player100\"; +----------+-------------+------------+ | VertexID | player.name | player.age | +----------+-------------+------------+ | player100 | Tim | 42 | +----------+-------------+------------+ Got 1 rows (time spent 2463/3042 us) UPDATE the degree value of an edge and check the result with the FETCH statement: nebula> UPDATE EDGE \"player100\" -> \"player101\" OF follow SET degree = 96; Execution succeeded (time spent 3932/4432 us) nebula> FETCH PROP ON follow \"player100\" -> \"player101\"; +-------------+-------------+--------------+---------------+ | follow._src | follow._dst | follow._rank | follow.degree | +-------------+-------------+--------------+---------------+ | player100 | player101 | 0 | 96 | +-------------+-------------+--------------+---------------+ Got 1 rows (time spent 2205/2800 us) Insert a vertex with VID \"player111\" and UPSERT it. nebula> INSERT VERTEX player(name, age) VALUES \"player111\":(\"Ben Simmons\", 22); Execution succeeded (time spent 2115/2900 us) Wed, 21 Oct 2020 11:11:50 UTC nebula> UPSERT VERTEX \"player111\" SET player.name = \"Dwight Howard\", player.age = $^.player.age + 11 \\ WHEN $^.player.name == \"Ben Simmons\" AND $^.player.age > 20 \\ YIELD $^.player.name AS Name, $^.player.age AS Age; +---------------+-----+ | Name | Age | +---------------+-----+ | Dwight Howard | 33 | +---------------+-----+ Got 1 rows (time spent 1815/2329 us) Delete vertices and edges \u00b6 nGQL syntax \u00b6 Delete vertices: DELETE VERTEX <vid1>[, <vid2>...] Delete edges: DELETE EDGE <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <src_vid> -> <dst_vid>...] Examples \u00b6 Delete vertices: nebula> DELETE VERTEX \"team1\", \"team2\"; Execution succeeded (time spent 4337/4782 us) Delete edges: nebula> DELETE EDGE follow \"team1\" -> \"team2\"; Execution succeeded (time spent 3700/4101 us) About indexes \u00b6 You can add indexes to tags or edge types with the CREATE INDEX statement. For more information, see Nebula Graph indexes [TODO]. Must-read for using index \u00b6 Applicable use of indexes can speed up queries, but indexes also decrease the write performance. DO NOT use indexes in production environments unless you are fully aware of their influences on your service. Rebuild indexes for pre-existing data. Otherwise, the pre-existing data can't be indexed. For more information, see Rebuild indexes [TODO]. nGQL syntax \u00b6 Create an index: CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] <index_name> ON {<tag_name> | <edge_name>} (prop_name_list); Rebuild an index: REBUILD {TAG | EDGE} INDEX <index_name> Examples \u00b6 Create an index for the name property on all vertices with the tag player . nebula> CREATE TAG INDEX player_index_0 on player(name); nebula> REBUILD TAG INDEX player_index_0; FAQ \u00b6 How is the time spent value at the end of each return message calculated? \u00b6 Take the return message of SHOW SPACES as an example: nebula> SHOW SPACES; +------+ | Name | +------+ | nba | +------+ Got 1 rows (time spent 1235/1934 us) The first number 1235 shows the time spent by the database itself, that is, the time it takes for the query engine to receive a query from the client, fetch the data from the storage server and perform a series of calculation. The second number 1934 shows the time spent from the client's perspective, that is, the time it takes for the client from sending a request, receiving a response, and displaying the result on the screen.","title":"Nebula\u00a0Graph CRUD"},{"location":"2.quick-start/4.nebula-graph-crud/#nebula_graph_crud","text":"This topic describes the basic CRUD operations in Nebula Graph.","title":"Nebula Graph CRUD"},{"location":"2.quick-start/4.nebula-graph-crud/#graph_space_and_nebula_graph_schema","text":"A Nebula Graph instance consists of one or more graph spaces. Graph spaces are physically isolated from each other. You can use different graph spaces in the same instance to store different datasets. To insert data into a graph space, define a schema for the graph database. Nebula Graph schema is based on the following components. Schema component Description Vertex Represents an entity in the real world. A vertex can have one or more tags. Tag The type of a vertex. It defines a group of properties that describes a type of vertices. Edge Represents a directed relationship between two vertices. Edge type The type of an edge. It defines a group of properties that describes a type of edges. For more information, see Nebula Graph schema [TODO]. In this topic, we use the following dataset to demonstrate basic CRUD operations.","title":"Graph space and Nebula Graph schema"},{"location":"2.quick-start/4.nebula-graph-crud/#check_the_machine_status_in_the_nebula_graph_cluster","text":"First, we recommend that you check the machine status to make sure that all the Storage services are connected to the Meta Services. Run SHOW HOSTS as follows. (root@nebula) [(none)]> SHOW HOSTS; +-----------+-------+--------+--------------+---------------------+------------------------+ | Host | Port | Status | Leader count | Leader distribution | Partition distribution | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged0 | 44500 | ONLINE | 0 | No valid partition | No valid partition | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged1 | 44500 | ONLINE | 0 | No valid partition | No valid partition | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged2 | 44500 | ONLINE | 0 | No valid partition | No valid partition | +-----------+-------+--------+--------------+---------------------+------------------------+ Got 3 rows (time spent 1775/2334 us) From the Status column of the table in the return message, you can see that all the Storage services are online.","title":"Check the machine status in the Nebula Graph cluster"},{"location":"2.quick-start/4.nebula-graph-crud/#create_and_use_a_graph_space","text":"","title":"Create and use a graph space"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax","text":"Create a graph space: CREATE SPACE <graph_space_name> [(partition_num=<partition number>, replica_factor=<replica number>), vid_type=fixed_string(<string_number>))] Property Description partition_num Specifies the number of partitions in each replica. The suggested number is the number of hard disks in the cluster times 5. For example, if you have 3 hard disks in the cluster, we recommend that you set 15 partitions. replica_factor Specifies the number of replicas in the Nebula Graph cluster. The suggested number is 3 in a production environment and 1 in a test environment. The replica number must always be an odd number for the need of quorum-based voting. vid_type To insert a vertex with a string-typed VID, set the fixed_string length for the maximum VID length. The default fixed_string is 8. Note: fix_string(N) is similar to varchar(N) in SQL. List graph spaces: nebula> SHOW SPACES; Use a graph space: USE <graph_space_name>","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples","text":"Use the following statement to create a graph space named nba . nebula> CREATE SPACE nba(partition_num=15, replica_factor=1, vid_type=fixed_string(30)); Execution succeeded (time spent 2817/3280 us) Check the partition distribution with SHOW HOSTS to make sure that the partitions are distributed in a balanced way. nebula> SHOW HOSTS; +-----------+-------+--------+--------------+---------------------+------------------------+ | Host | Port | Status | Leader count | Leader distribution | Partition distribution | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged0 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged1 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged2 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ Got 3 rows (time spent 744/1123 us) If the Leader distribution is uneven, use BALANCE LEADER to redistribute the partitions. For more information, see BALANCE [TODO]. Use the nba graph space. nebula> USE nba; Execution succeeded (time spent 1322/2206 us) You can use SHOW SPACES to check the graph space you created. nebula> SHOW SPACES; +------+ | Name | +------+ | nba | +------+ Got 1 rows (time spent 1235/1934 us)","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#create_tags_and_edge_types","text":"","title":"Create tags and edge types"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_1","text":"CREATE {TAG | EDGE} {<tag_name> | <edge_type>}(<property_name> <data_type> [, <property_name> <data_type> ...]);","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_1","text":"Create tags player and team , edge types follow and serve . Component name Type Property player Tag name (string), age (int) team Tag name (string) follow Edge type degree (int) serve Edge type start_year (int), end_year (int) nebula> CREATE TAG player(name string, age int); Execution succeeded (time spent 2694/3116 us) Thu, 15 Oct 2020 06:22:29 UTC nebula> CREATE TAG team(name string); Execution succeeded (time spent 2630/3002 us) Thu, 15 Oct 2020 06:22:37 UTC nebula> CREATE EDGE follow(degree int); Execution succeeded (time spent 3087/3467 us) Thu, 15 Oct 2020 06:22:43 UTC nebula> CREATE EDGE serve(start_year int, end_year int); Execution succeeded (time spent 2645/3123 us) Thu, 15 Oct 2020 06:22:50 UTC","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#insert_vertices_and_edges","text":"You can use the INSERT statement to insert vertices or edges based on existing tags or edge types.","title":"Insert vertices and edges"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_2","text":"Insert vertices: INSERT VERTEX <tag_name> (<property_name>[, <property_name>...]) [, <tag_name> (<property_name>[, <property_name>...]), ...] {VALUES | VALUE} <vid>: (<property_value>[, <property_value>...]) [, <vid>: (<property_value>[, <property_value>...]; VID is short for vertex ID. A VID must be a unique string value in a graph space. Insert edges: INSERT EDGE <edge_type> (<property_name>[, <property_name>...]) {VALUES | VALUE} <src_vid> -> <dst_vid>[@<rank>] : (<property_value>[, <property_value>...]) [, <src_vid> -> <dst_vid>[@<rank> : (<property_name>[, <property_name>...]), ...]","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_2","text":"Insert vertices representing NBA players and teams: nebula> INSERT VERTEX player(name, age) VALUES \"player100\":(\"Tim Duncan\", 42); Execution succeeded (time spent 2919/3485 us) Fri, 16 Oct 2020 03:41:00 UTC nebula> INSERT VERTEX player(name, age) VALUES \"player101\":(\"Tony Parker\", 36); Execution succeeded (time spent 3007/3539 us) Fri, 16 Oct 2020 03:41:58 UTC nebula> INSERT VERTEX player(name, age) VALUES \"player102\":(\"LaMarcus Aldridge\", 33); Execution succeeded (time spent 2449/2934 us) Fri, 16 Oct 2020 03:42:16 UTC nebula> INSERT VERTEX team(name) VALUES \"team200\":(\"Warriors\"), \"team201\":(\"Nuggets\"); Execution succeeded (time spent 3514/4331 us) Fri, 16 Oct 2020 03:42:45 UTC Insert edges representing the relations between NBA players and teams: nebula> INSERT EDGE follow(degree) VALUES \"player100\" -> \"player101\":(95); Execution succeeded (time spent 1488/1918 us) Wed, 21 Oct 2020 06:57:32 UTC nebula> INSERT EDGE follow(degree) VALUES \"player100\" -> \"player102\":(90); Execution succeeded (time spent 2483/2890 us) Wed, 21 Oct 2020 07:05:48 UTC nebula> INSERT EDGE follow(degree) VALUES \"player102\" -> \"player101\":(75); Execution succeeded (time spent 1208/1689 us) Wed, 21 Oct 2020 07:07:12 UTC nebula> INSERT EDGE serve(start_year, end_year) VALUES \"player100\" -> \"team200\":(1997, 2016), \"player101\" -> \"team201\":(1999, 2018); Execution succeeded (time spent 2170/2651 us) Wed, 21 Oct 2020 07:08:59 UTC","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#read_data","text":"You can use the statements GO [TODO], FETCH [TODO], and LOOKUP [TODO] to retrieve vertex and edge data. GO is the most commonly used read statement. It traverses the database based on specific conditions. A GO traversal starts from one or more vertices, along one or more edges, and return information in a form specified in the YIELD clause. FETCH is used to get properties from vertices or edges. The LOOKUP statement is based on indexes . It is used together with the WHERE clause to search for the data that meet the specific conditions.","title":"Read data"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_3","text":"GO GO [[<M> TO] <N> STEPS ] FROM <vertex_list> OVER <edge_type_list> [REVERSELY] [BIDIRECT] [WHERE <expression> [AND | OR expression ...])] YIELD [DISTINCT] <return_list> FETCH Fetch properties on tags: FETCH PROP ON {<tag_name> | <tag_name_list> | *} <vid_list> [YIELD [DISTINCT] <return_list>] Fetch properties on edges: FETCH PROP ON <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <src_vid> -> <dst_vid> ...] [YIELD [DISTINCT] <return_list>] LOOKUP LOOKUP ON {<tag_name> | <edge_type>} WHERE <expression> [AND expression ...])] [YIELD <return_list>]","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_3","text":"Use GO : Find the vertices that VID \"player100\" follows. nebula> GO FROM \"player100\" OVER follow; +-------------+ | follow._dst | +-------------+ | player101 | +-------------+ | player102 | +-------------+ Got 2 rows (time spent 1935/2420 us) Use GO : Search for the players that the player with VID \"player100\" follows. Filter the the players that the player with VID \"player100\" follows whose age is equal to or greater than 35. Rename the columns in the result with Teammate and Age . nebula> GO FROM \"player100\" OVER follow WHERE $$.player.age >= 35 \\ YIELD $$.player.name AS Teammate, $$.player.age AS Age; +-------------+-----+ | Teammate | Age | +-------------+-----+ | Tony Parker | 36 | +-------------+-----+ Got 1 rows (time spent 3871/4349 us) Clause/Sign Description YIELD Specifies what values or results you want to return from the query. $$ Represents the target vertices. \\ A line-breaker. Use GO : Search for the players that the player with VID \"player100\" follows. Then Retrieve the teams of the players that the player with VID \"player100\" follows. To combine the two queries, use a pipe or a temporary variable. With a pipe: nebula> GO FROM \"player100\" OVER follow YIELD follow._dst AS id | \\ GO FROM $-.id OVER serve YIELD $$.team.name AS Team, \\ $^.player.name AS Player; +---------+-------------+ | Team | Player | +---------+-------------+ | Nuggets | Tony Parker | +---------+-------------+ Got 1 rows (time spent 2902/3496 us) Clause/Sign Description $^ Represents the source vertex of the edge. \\ $- Represents the output of the query before the pipe symbol. With a temporary variable: NOTE : Once a compound statement is submitted to the server as a whole, the life cycle of the temporary variables in the statement ends. nebula> $var = GO FROM \"player100\" OVER follow YIELD follow._dst AS id; \\ GO FROM $var.id OVER serve YIELD $$.team.name AS Team, \\ $^.player.name AS Player; +---------+-------------+ | Team | Player | +---------+-------------+ | Nuggets | Tony Parker | +---------+-------------+ Got 1 rows (time spent 3103/3711 us) Use FETCH : Fetch the properties of the player with VID player100. nebula> FETCH PROP ON player \"player100\"; +----------+-------------+------------+ | VertexID | player.name | player.age | +----------+-------------+------------+ | player100 | Tim Duncan | 42 | +----------+-------------+------------+ Got 1 rows (time spent 2006/2406 us) Use LOOKUP : Find the information of the vertex with the tag player and its value of the name property is \"Tony Parker\" . nebula> LOOKUP ON player WHERE player.name == \"Tony Parker\" \\ YIELD player.name, player.age;","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#update_vertices_and_edges","text":"You can use the UPDATE statement or the UPSERT statement to update existing data. UPSERT is the combination of UPDATE and INSERT . If you update a vertex or an edge with UPSERT , it inserts a new vertex or edge if it does not exist.","title":"Update vertices and edges"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_4","text":"UPDATE vertices: UPDATE VERTEX <vid> SET <properties to be updated> [WHEN <condition>] [YIELD <columns>] UPDATE edges: UPDATE EDGE <source vid> -> <destination vid> [@rank] OF <edge_type> SET <properties to be updated> [WHEN <condition>] [YIELD <columns to be output>] UPSERT vertices or edges: UPSERT {VERTEX <vid> | EDGE <edge_type>} SET <update_columns> [WHEN <condition>] [YIELD <columns>]","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_4","text":"UPDATE the name property of the vertex with VID \"player100\" and check the result with the FETCH statement: nebula> UPDATE VERTEX \"player100\" SET player.name = \"Tim\"; Execution succeeded (time spent 3483/3914 us) Wed, 21 Oct 2020 10:53:14 UTC nebula> FETCH PROP ON player \"player100\"; +----------+-------------+------------+ | VertexID | player.name | player.age | +----------+-------------+------------+ | player100 | Tim | 42 | +----------+-------------+------------+ Got 1 rows (time spent 2463/3042 us) UPDATE the degree value of an edge and check the result with the FETCH statement: nebula> UPDATE EDGE \"player100\" -> \"player101\" OF follow SET degree = 96; Execution succeeded (time spent 3932/4432 us) nebula> FETCH PROP ON follow \"player100\" -> \"player101\"; +-------------+-------------+--------------+---------------+ | follow._src | follow._dst | follow._rank | follow.degree | +-------------+-------------+--------------+---------------+ | player100 | player101 | 0 | 96 | +-------------+-------------+--------------+---------------+ Got 1 rows (time spent 2205/2800 us) Insert a vertex with VID \"player111\" and UPSERT it. nebula> INSERT VERTEX player(name, age) VALUES \"player111\":(\"Ben Simmons\", 22); Execution succeeded (time spent 2115/2900 us) Wed, 21 Oct 2020 11:11:50 UTC nebula> UPSERT VERTEX \"player111\" SET player.name = \"Dwight Howard\", player.age = $^.player.age + 11 \\ WHEN $^.player.name == \"Ben Simmons\" AND $^.player.age > 20 \\ YIELD $^.player.name AS Name, $^.player.age AS Age; +---------------+-----+ | Name | Age | +---------------+-----+ | Dwight Howard | 33 | +---------------+-----+ Got 1 rows (time spent 1815/2329 us)","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#delete_vertices_and_edges","text":"","title":"Delete vertices and edges"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_5","text":"Delete vertices: DELETE VERTEX <vid1>[, <vid2>...] Delete edges: DELETE EDGE <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <src_vid> -> <dst_vid>...]","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_5","text":"Delete vertices: nebula> DELETE VERTEX \"team1\", \"team2\"; Execution succeeded (time spent 4337/4782 us) Delete edges: nebula> DELETE EDGE follow \"team1\" -> \"team2\"; Execution succeeded (time spent 3700/4101 us)","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#about_indexes","text":"You can add indexes to tags or edge types with the CREATE INDEX statement. For more information, see Nebula Graph indexes [TODO].","title":"About indexes"},{"location":"2.quick-start/4.nebula-graph-crud/#must-read_for_using_index","text":"Applicable use of indexes can speed up queries, but indexes also decrease the write performance. DO NOT use indexes in production environments unless you are fully aware of their influences on your service. Rebuild indexes for pre-existing data. Otherwise, the pre-existing data can't be indexed. For more information, see Rebuild indexes [TODO].","title":"Must-read for using index"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_6","text":"Create an index: CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] <index_name> ON {<tag_name> | <edge_name>} (prop_name_list); Rebuild an index: REBUILD {TAG | EDGE} INDEX <index_name>","title":"nGQL syntax"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_6","text":"Create an index for the name property on all vertices with the tag player . nebula> CREATE TAG INDEX player_index_0 on player(name); nebula> REBUILD TAG INDEX player_index_0;","title":"Examples"},{"location":"2.quick-start/4.nebula-graph-crud/#faq","text":"","title":"FAQ"},{"location":"2.quick-start/4.nebula-graph-crud/#how_is_the_time_spent_value_at_the_end_of_each_return_message_calculated","text":"Take the return message of SHOW SPACES as an example: nebula> SHOW SPACES; +------+ | Name | +------+ | nba | +------+ Got 1 rows (time spent 1235/1934 us) The first number 1235 shows the time spent by the database itself, that is, the time it takes for the query engine to receive a query from the client, fetch the data from the storage server and perform a series of calculation. The second number 1934 shows the time spent from the client's perspective, that is, the time it takes for the client from sending a request, receiving a response, and displaying the result on the screen.","title":"How is the time spent value at the end of each return message calculated?"},{"location":"3.ngql-guide/11.edge-statements/1.insert-edge/","text":"INSERT EDGE \u00b6 INSERT EDGE <edge_type> ( <prop_name_list> ) {VALUES | VALUE} <src_vid> -> <dst_vid>[@<rank>] : ( <prop_value_list> ) [, <src_vid> -> <dst_vid>[@<rank>] : ( <prop_value_list> ), ...] <prop_name_list> ::= [ <prop_name> [, <prop_name> ] ...] <prop_value_list> ::= [ <prop_value> [, <prop_value> ] ...] The INSERT EDGE statement inserts an edge from a source vertex (given by src_vid) to a destination vertex (given by dst_vid). <edge_type> denotes the edge type, which must be created before INSERT EDGE . Only one edge type can be specified in this statement. <prop_name_list> is the property name list in the given <edge_type> . <prop_value_list> must provide the value list according to <prop_name_list> . If the property values do not match the data type in the edge type, an error is returned. When the NOT NULL constraint is set for a given property, an error is returned if no property is given. When the default value for a property is NULL , you can omit to specify the property value. (TODO: create edge doc) rank is optional. It specifies the edge rank of the same edge type. If not specified, the default value is 0. You can insert many edges with the same edge type for two vertices by using different rank values. Examples \u00b6 nebula> CREATE EDGE e1(); -- create edge type t1 with empty property nebula> INSERT EDGE e1 () VALUES \"10\"->\"11\":(); -- insert an edge from vertex \"10\" to vertex \"11\" with empty property nebula> INSERT EDGE e1 () VALUES \"10\"->\"11\"@1:(); -- insert an edge from vertex \"10\" to vertex \"11\" with empty property, the edge rank is 1 nebula> CREATE EDGE e2 (name string, age int); -- create edge type e2 with two properties nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 1); -- insert edge from \"11\" to \"13\" with two properties nebula> INSERT EDGE e2 (name, age) VALUES \\ \"12\"->\"13\":(\"n1\", 1), \"13\"->\"14\":(\"n2\", 2); -- insert two edges nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", \"a13\"); -- ERROR. \"a13\" is not int An edge can be inserted/written multiple times. Only the last written values can be read. -- insert edge with the new values. nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 12); nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 13); nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 14); nebula> FETCH PROP ON e2 \"11\"->\"13\"; +---------+---------+----------+---------+--------+ | e2._src | e2._dst | e2._rank | e2.name | e2.age | +---------+---------+----------+---------+--------+ | \"11\" | \"13\" | 0 | \"n1\" | 14 | +---------+---------+----------+---------+--------+ -- Only the last write can be read","title":"INSERT EDGE"},{"location":"3.ngql-guide/11.edge-statements/1.insert-edge/#insert_edge","text":"INSERT EDGE <edge_type> ( <prop_name_list> ) {VALUES | VALUE} <src_vid> -> <dst_vid>[@<rank>] : ( <prop_value_list> ) [, <src_vid> -> <dst_vid>[@<rank>] : ( <prop_value_list> ), ...] <prop_name_list> ::= [ <prop_name> [, <prop_name> ] ...] <prop_value_list> ::= [ <prop_value> [, <prop_value> ] ...] The INSERT EDGE statement inserts an edge from a source vertex (given by src_vid) to a destination vertex (given by dst_vid). <edge_type> denotes the edge type, which must be created before INSERT EDGE . Only one edge type can be specified in this statement. <prop_name_list> is the property name list in the given <edge_type> . <prop_value_list> must provide the value list according to <prop_name_list> . If the property values do not match the data type in the edge type, an error is returned. When the NOT NULL constraint is set for a given property, an error is returned if no property is given. When the default value for a property is NULL , you can omit to specify the property value. (TODO: create edge doc) rank is optional. It specifies the edge rank of the same edge type. If not specified, the default value is 0. You can insert many edges with the same edge type for two vertices by using different rank values.","title":"INSERT EDGE"},{"location":"3.ngql-guide/11.edge-statements/1.insert-edge/#examples","text":"nebula> CREATE EDGE e1(); -- create edge type t1 with empty property nebula> INSERT EDGE e1 () VALUES \"10\"->\"11\":(); -- insert an edge from vertex \"10\" to vertex \"11\" with empty property nebula> INSERT EDGE e1 () VALUES \"10\"->\"11\"@1:(); -- insert an edge from vertex \"10\" to vertex \"11\" with empty property, the edge rank is 1 nebula> CREATE EDGE e2 (name string, age int); -- create edge type e2 with two properties nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 1); -- insert edge from \"11\" to \"13\" with two properties nebula> INSERT EDGE e2 (name, age) VALUES \\ \"12\"->\"13\":(\"n1\", 1), \"13\"->\"14\":(\"n2\", 2); -- insert two edges nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", \"a13\"); -- ERROR. \"a13\" is not int An edge can be inserted/written multiple times. Only the last written values can be read. -- insert edge with the new values. nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 12); nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 13); nebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 14); nebula> FETCH PROP ON e2 \"11\"->\"13\"; +---------+---------+----------+---------+--------+ | e2._src | e2._dst | e2._rank | e2.name | e2.age | +---------+---------+----------+---------+--------+ | \"11\" | \"13\" | 0 | \"n1\" | 14 | +---------+---------+----------+---------+--------+ -- Only the last write can be read","title":"Examples"},{"location":"3.ngql-guide/11.edge-statements/2.update-edge/","text":"UPDATE EDGE \u00b6 UPDATE EDGE <src_vid> -> <dest_vid> [@rank] OF <edge_type> SET <update_properties> [WHEN <condition>] [YIELD <properties>] Use UPDATE EDGE to update properties on an edge. The UPDATE EDGE statement only updates one edge at a time. Nebula Graph supports compare-and-set (CAS). NOTE: WHEN and YIELD are optional. update_properties is the properties of the edge to be updated. For example, e1.col1 = $^.e1.col2 + 1 means to update e1.col1 to e1.col2+1 . NOTE: $^ indicates the edge to be updated. condition is some constraints. Only when the condition is met, UPDATE is executed successfully. condition supports expression operations. properties is the properties to be returned, YIELD returns the latest updated values. Consider the following example: nebula> UPDATE EDGE \"100\" -> \"200\"@0 OF serve SET start_year = serve.start_year + 1;","title":"UPDATE EDGE"},{"location":"3.ngql-guide/11.edge-statements/2.update-edge/#update_edge","text":"UPDATE EDGE <src_vid> -> <dest_vid> [@rank] OF <edge_type> SET <update_properties> [WHEN <condition>] [YIELD <properties>] Use UPDATE EDGE to update properties on an edge. The UPDATE EDGE statement only updates one edge at a time. Nebula Graph supports compare-and-set (CAS). NOTE: WHEN and YIELD are optional. update_properties is the properties of the edge to be updated. For example, e1.col1 = $^.e1.col2 + 1 means to update e1.col1 to e1.col2+1 . NOTE: $^ indicates the edge to be updated. condition is some constraints. Only when the condition is met, UPDATE is executed successfully. condition supports expression operations. properties is the properties to be returned, YIELD returns the latest updated values. Consider the following example: nebula> UPDATE EDGE \"100\" -> \"200\"@0 OF serve SET start_year = serve.start_year + 1;","title":"UPDATE EDGE"},{"location":"3.ngql-guide/11.edge-statements/3.upsert-edge/","text":"UPSERT EDGE \u00b6 UPSERT EDGE <src_vid> -> <dst_vid> [@rank] OF <edge_type> SET <update_properties> [WHEN <condition>] [YIELD <properties>] update_properties is the properties of the edge to be updated. For example, e1.col1 = $^.e1.col2 + 1 means to update e1.col1 to e1.col2+1 . NOTE: $^ indicates the edge to be updated. condition is some constraints. Only when the condition is met, UPSERT is executed successfully. condition supports expression operations. properties specifies the properties to be returned, YIELD returns the latest updated values. UPSERT is a combination of UPDATE and INSERT . Use UPSERT EDGE to update properties on an edge if it exists or insert a new edge if it does not exist. The UPDATE EDGE statement updates only one edge at a time. The performance of UPSERT is much lower than that of INSERT , because UPSERT is a read-modify-write serialization operation at the partition level. DON'T: DO NOT use UPSERT for scenarios with highly concurrent writes. If the edge does not exist, a new edge is created no matter whether the condition in the WHEN clause is met or not. The properties not specified by the SET statement use the default property values. If there are no default values, an error is returned. If the edge exists and the WHEN condition is met, the edge is updated. If the edge exists and the WHEN condition is not met, Nebula Graph does nothing. Consider the following example: nebula> INSERT EDGE serve(start_year, end_year) VALUES \"player100\" -> \"team200\":(1997, 2016); -- Insert a new edge. nebula> UPSERT EDGE \"player100\" -> \"team200\" OF serve SET start_year = serve.start_year + 2 WHEN serve.end_year == 2016 YIELD serve.start_year AS Start, serve.end_year AS End; +-------+------+ | Start | End | +-------+------+ | 1999 | 2016 | +-------+------+ nebula> FETCH PROP ON serve \"player100\" -> \"team200\"; +-------------+------------+-------------+------------------+----------------+ | serve._src | serve._dst | serve._rank | serve.start_year | serve.end_year | +-------------+------------+-------------+------------------+----------------+ | \"player100\" | \"team200\" | 0 | 1999 | 2016 | +-------------+------------+-------------+------------------+----------------+","title":"UPSERT EDGE"},{"location":"3.ngql-guide/11.edge-statements/3.upsert-edge/#upsert_edge","text":"UPSERT EDGE <src_vid> -> <dst_vid> [@rank] OF <edge_type> SET <update_properties> [WHEN <condition>] [YIELD <properties>] update_properties is the properties of the edge to be updated. For example, e1.col1 = $^.e1.col2 + 1 means to update e1.col1 to e1.col2+1 . NOTE: $^ indicates the edge to be updated. condition is some constraints. Only when the condition is met, UPSERT is executed successfully. condition supports expression operations. properties specifies the properties to be returned, YIELD returns the latest updated values. UPSERT is a combination of UPDATE and INSERT . Use UPSERT EDGE to update properties on an edge if it exists or insert a new edge if it does not exist. The UPDATE EDGE statement updates only one edge at a time. The performance of UPSERT is much lower than that of INSERT , because UPSERT is a read-modify-write serialization operation at the partition level. DON'T: DO NOT use UPSERT for scenarios with highly concurrent writes. If the edge does not exist, a new edge is created no matter whether the condition in the WHEN clause is met or not. The properties not specified by the SET statement use the default property values. If there are no default values, an error is returned. If the edge exists and the WHEN condition is met, the edge is updated. If the edge exists and the WHEN condition is not met, Nebula Graph does nothing. Consider the following example: nebula> INSERT EDGE serve(start_year, end_year) VALUES \"player100\" -> \"team200\":(1997, 2016); -- Insert a new edge. nebula> UPSERT EDGE \"player100\" -> \"team200\" OF serve SET start_year = serve.start_year + 2 WHEN serve.end_year == 2016 YIELD serve.start_year AS Start, serve.end_year AS End; +-------+------+ | Start | End | +-------+------+ | 1999 | 2016 | +-------+------+ nebula> FETCH PROP ON serve \"player100\" -> \"team200\"; +-------------+------------+-------------+------------------+----------------+ | serve._src | serve._dst | serve._rank | serve.start_year | serve.end_year | +-------------+------------+-------------+------------------+----------------+ | \"player100\" | \"team200\" | 0 | 1999 | 2016 | +-------------+------------+-------------+------------------+----------------+","title":"UPSERT EDGE"},{"location":"3.ngql-guide/11.edge-statements/4.delete-edge/","text":"DELETE EDGE \u00b6 DELETE EDGE <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <edge_type> <src_vid> -> <dst_vid>[@<rank>] ...] Use DELETE EDGE to delete edges. The DELETE EDGE statement deletes one edge or multiple edges at a time. You can use DELETE EDGE together with pipe. For more information about pipe, see Pipe operator . Examples \u00b6 nebula> DELETE EDGE serve \"player100\" -> \"team200\"@0; This query deletes the serve edge from \"player100\" to \"team200\" , of which the rank value is 0. nebula> GO FROM \"player100\" OVER follow WHERE follow._dst == \"team200\" YIELD follow._src AS src, follow._dst AS dst, follow._rank AS rank | \\ DELETE EDGE follow $-.src->$-.dst @ $-.rank; This query shows that you can use DELETE EDGE together with pipe. This query first traverses all the follow edges with different rank values from \"player100\" to \"team200\" then deletes them. To delete all the outgoing edges for a vertex, delete the vertex. For more information, see DELETE VERTEX . NOTE: Atomic operation is not guaranteed during the entire process for now, so please retry when a failure occurs.","title":"DELETE EDGE"},{"location":"3.ngql-guide/11.edge-statements/4.delete-edge/#delete_edge","text":"DELETE EDGE <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <edge_type> <src_vid> -> <dst_vid>[@<rank>] ...] Use DELETE EDGE to delete edges. The DELETE EDGE statement deletes one edge or multiple edges at a time. You can use DELETE EDGE together with pipe. For more information about pipe, see Pipe operator .","title":"DELETE EDGE"},{"location":"3.ngql-guide/11.edge-statements/4.delete-edge/#examples","text":"nebula> DELETE EDGE serve \"player100\" -> \"team200\"@0; This query deletes the serve edge from \"player100\" to \"team200\" , of which the rank value is 0. nebula> GO FROM \"player100\" OVER follow WHERE follow._dst == \"team200\" YIELD follow._src AS src, follow._dst AS dst, follow._rank AS rank | \\ DELETE EDGE follow $-.src->$-.dst @ $-.rank; This query shows that you can use DELETE EDGE together with pipe. This query first traverses all the follow edges with different rank values from \"player100\" to \"team200\" then deletes them. To delete all the outgoing edges for a vertex, delete the vertex. For more information, see DELETE VERTEX . NOTE: Atomic operation is not guaranteed during the entire process for now, so please retry when a failure occurs.","title":"Examples"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/","text":"INSERT VERTEX \u00b6 INSERT VERTEX <tag_name> (<prop_name_list>) [, <tag_name> (<prop_name_list>), ...] {VALUES | VALUE} VID: (<prop_value_list>[, <prop_value_list>]) prop_name_list: [prop_name [, prop_name] ...] prop_value_list: [prop_value [, prop_value] ...] The INSERT VERTEX statement inserts one or more vertices into a graph space in a Nebula Graph instance. tag_name denotes the tag (vertex type), which must be created before INSERT VERTEX . prop_name_list contains the names of the properties on the tag. VID is the vertex ID. In Nebula Graph 2.0.0-alpha, only string type VID is supported. The maximum VID length is set when a graph space is created. For detail information on the maximum VID length, see CREATE SPACE . prop_value_list must provide the property values according to the prop_name_list . If the property values do not match the data type in the tag, an error is returned. When the NOT NULL constraint is set for a given property, an error is returned if no property is given. When the default value for a property is NULL , you can omit to specify the property value. (TODO: create tag doc) Examples \u00b6 nebula> CREATE TAG t1(); -- Create tag t1 with no property nebula> INSERT VERTEX t1() VALUE \"10\":(); -- Insert vertex \"10\" with no property nebula> CREATE TAG t2 (name string, age int); -- Create tag t2 with two properties nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n1\", 12); -- Insert vertex \"11\" with two properties nebula> INSERT VERTEX t2 (name, age) VALUES \"12\":(\"n1\", \"a13\"); -- Failed. \"a13\" is not int nebula> INSERT VERTEX t2 (name, age) VALUES \"13\":(\"n3\", 12), \"14\":(\"n4\", 8); -- Insert two vertices nebula> CREATE TAG t3(p1 int); nebula> CREATE TAG t4(p2 string); nebula> INSERT VERTEX t3 (p1), t4(p2) VALUES \"21\": (321, \"hello\"); -- Insert vertex \"21\" with two tags. A vertex can be inserted/written multiple times. Only the last written values can be read. -- insert vertex \"11\" with the new values. nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n2\", 13); nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n3\", 14); nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n4\", 15); nebula> FETCH PROP ON t2 \"11\"; +----------+---------+--------+ | VertexID | t2.name | t2.age | +----------+---------+--------+ | \"11\" | \"n4\" | 15 | -- Only the last version can be read +----------+---------+--------+ nebula> CREATE TAG t5(p1 fixed_string(5) NOT NULL, p2 int, p3 int DEFAULT NULL); nebula> INSERT VERTEX t5(p1, p2, p3) VALUES \"001\":(\"Abe\", 2, 3); nebula> INSERT VERTEX t5(p1, p2, p3) VALUES \"002\":(NULL, 4, 5); [ERROR (-8)]: Storage Error: The not null field cannot be null. nebula> INSERT VERTEX t5(p1, p2) VALUES \"003\":(\"cd\", 5); nebula> FETCH PROP ON t5 \"003\"; +----------+-------+-------+-------+ | VertexID | t5.p1 | t5.p2 | t5.p3 | +----------+-------+-------+-------+ | \"003\" | \"cd\" | 5 | NULL | -- The value for p3 is the default NULL. +----------+-------+-------+-------+ nebula> INSERT VERTEX t5(p1, p2) VALUES \"004\":(\"shalalalala\", 4); nebula> FETCH PROP on t5 \"004\"; +----------+---------+-------+-------+ | VertexID | t5.p1 | t5.p2 | t5.p3 | +----------+---------+-------+-------+ | \"004\" | \"shala\" | 4 | NULL | -- The allowed maximum length for property p1 is 5. +----------+---------+-------+-------+","title":"INSERT VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/#insert_vertex","text":"INSERT VERTEX <tag_name> (<prop_name_list>) [, <tag_name> (<prop_name_list>), ...] {VALUES | VALUE} VID: (<prop_value_list>[, <prop_value_list>]) prop_name_list: [prop_name [, prop_name] ...] prop_value_list: [prop_value [, prop_value] ...] The INSERT VERTEX statement inserts one or more vertices into a graph space in a Nebula Graph instance. tag_name denotes the tag (vertex type), which must be created before INSERT VERTEX . prop_name_list contains the names of the properties on the tag. VID is the vertex ID. In Nebula Graph 2.0.0-alpha, only string type VID is supported. The maximum VID length is set when a graph space is created. For detail information on the maximum VID length, see CREATE SPACE . prop_value_list must provide the property values according to the prop_name_list . If the property values do not match the data type in the tag, an error is returned. When the NOT NULL constraint is set for a given property, an error is returned if no property is given. When the default value for a property is NULL , you can omit to specify the property value. (TODO: create tag doc)","title":"INSERT VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/#examples","text":"nebula> CREATE TAG t1(); -- Create tag t1 with no property nebula> INSERT VERTEX t1() VALUE \"10\":(); -- Insert vertex \"10\" with no property nebula> CREATE TAG t2 (name string, age int); -- Create tag t2 with two properties nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n1\", 12); -- Insert vertex \"11\" with two properties nebula> INSERT VERTEX t2 (name, age) VALUES \"12\":(\"n1\", \"a13\"); -- Failed. \"a13\" is not int nebula> INSERT VERTEX t2 (name, age) VALUES \"13\":(\"n3\", 12), \"14\":(\"n4\", 8); -- Insert two vertices nebula> CREATE TAG t3(p1 int); nebula> CREATE TAG t4(p2 string); nebula> INSERT VERTEX t3 (p1), t4(p2) VALUES \"21\": (321, \"hello\"); -- Insert vertex \"21\" with two tags. A vertex can be inserted/written multiple times. Only the last written values can be read. -- insert vertex \"11\" with the new values. nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n2\", 13); nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n3\", 14); nebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n4\", 15); nebula> FETCH PROP ON t2 \"11\"; +----------+---------+--------+ | VertexID | t2.name | t2.age | +----------+---------+--------+ | \"11\" | \"n4\" | 15 | -- Only the last version can be read +----------+---------+--------+ nebula> CREATE TAG t5(p1 fixed_string(5) NOT NULL, p2 int, p3 int DEFAULT NULL); nebula> INSERT VERTEX t5(p1, p2, p3) VALUES \"001\":(\"Abe\", 2, 3); nebula> INSERT VERTEX t5(p1, p2, p3) VALUES \"002\":(NULL, 4, 5); [ERROR (-8)]: Storage Error: The not null field cannot be null. nebula> INSERT VERTEX t5(p1, p2) VALUES \"003\":(\"cd\", 5); nebula> FETCH PROP ON t5 \"003\"; +----------+-------+-------+-------+ | VertexID | t5.p1 | t5.p2 | t5.p3 | +----------+-------+-------+-------+ | \"003\" | \"cd\" | 5 | NULL | -- The value for p3 is the default NULL. +----------+-------+-------+-------+ nebula> INSERT VERTEX t5(p1, p2) VALUES \"004\":(\"shalalalala\", 4); nebula> FETCH PROP on t5 \"004\"; +----------+---------+-------+-------+ | VertexID | t5.p1 | t5.p2 | t5.p3 | +----------+---------+-------+-------+ | \"004\" | \"shala\" | 4 | NULL | -- The allowed maximum length for property p1 is 5. +----------+---------+-------+-------+","title":"Examples"},{"location":"3.ngql-guide/12.vertex-statements/2.update-vertex/","text":"UPDATE VERTEX \u00b6 UPDATE VERTEX <vid> SET <update_columns> [WHEN <condition>] [YIELD <columns>] Use UPDATE VERTEX to update properties on a vertex. The UPDATE VERTEX statement only updates one tag of a vertex at a time. Nebula Graph supports compare-and-set (CAS) operation. NOTE: WHEN and YIELD are optional. vid is the ID of the vertex to be updated. update_columns is the properties of the vertex to be updated. For example, tag1.col1 = $^.tag2.col2 + 1 means to update tag1.col1 to tag2.col2+1 . NOTE: $^ indicates the vertex to be updated. condition is some constraints. Only when the constraints are met, UPDATE is executed successfully. condition supports expression operations. columns is the columns to be returned. YIELD returns the latest updated values. Consider the following example: nebula> UPDATE VERTEX \"player100\" SET player.age = $^.player.age + 1 \\ WHEN $^.player.name == \"Tony Parker\" \\ YIELD $^.player.name AS name, $^.player.age AS age; +-------+-----+ | name | age | +-------+-----+ | \"Tim\" | 42 | +-------+-----+ There is one tag in vertex \"player100\", namely player. nebula> UPDATE VERTEX \"team200\" SET player.name = 'Cory Joseph' WHEN $^.team.name == 'Rocket'; [ERROR (-8)]: Storage Error: Invalid Update col or yield col. UPDATE VERTEX does not support multiple tags, so an error occurs here.","title":"UPDATE VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/2.update-vertex/#update_vertex","text":"UPDATE VERTEX <vid> SET <update_columns> [WHEN <condition>] [YIELD <columns>] Use UPDATE VERTEX to update properties on a vertex. The UPDATE VERTEX statement only updates one tag of a vertex at a time. Nebula Graph supports compare-and-set (CAS) operation. NOTE: WHEN and YIELD are optional. vid is the ID of the vertex to be updated. update_columns is the properties of the vertex to be updated. For example, tag1.col1 = $^.tag2.col2 + 1 means to update tag1.col1 to tag2.col2+1 . NOTE: $^ indicates the vertex to be updated. condition is some constraints. Only when the constraints are met, UPDATE is executed successfully. condition supports expression operations. columns is the columns to be returned. YIELD returns the latest updated values. Consider the following example: nebula> UPDATE VERTEX \"player100\" SET player.age = $^.player.age + 1 \\ WHEN $^.player.name == \"Tony Parker\" \\ YIELD $^.player.name AS name, $^.player.age AS age; +-------+-----+ | name | age | +-------+-----+ | \"Tim\" | 42 | +-------+-----+ There is one tag in vertex \"player100\", namely player. nebula> UPDATE VERTEX \"team200\" SET player.name = 'Cory Joseph' WHEN $^.team.name == 'Rocket'; [ERROR (-8)]: Storage Error: Invalid Update col or yield col. UPDATE VERTEX does not support multiple tags, so an error occurs here.","title":"UPDATE VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/3.upsert-vertex/","text":"UPSERT VERTEX \u00b6 UPSERT VERTEX <vid> SET <update_columns> [WHEN <condition>] [YIELD <columns>] vid is the ID of the vertex to be updated. update_columns is the properties of the vertex to be updated. For example, tag1.col1 = $^.tag2.col2 + 1 means to update tag1.col1 to tag2.col2+1 . NOTE: $^ indicates the vertex to be updated. condition is some constraints. Only when the conditions are met, UPSERT is executed successfully. condition supports expression operations. columns is the columns to be returned, YIELD returns the latest updated values. UPSERT is a combination of UPDATE and INSERT . Use UPSERT VERTEX to update properties on a vertex if it exists or insert a new vertex if it does not exist. The UPDATE VERTEX statement only updates one tag of a vertex at a time. The performance of UPSERT is much lower than that of INSERT , because UPSERT is a read-modify-write serialization operation at the partition level. DON'T: DO NOT use UPSERT for scenarios with highly concurrent writes. If the vertex does not exist, a new vertex is created no matter whether the condition in the WHEN clause is met or not. The property columns not specified by the SET statement use the default values of the columns. If there are no default values, an error is returned. If the vertex exists and the WHEN condition is met, the vertex is updated. If the vertex exists and the WHEN condition is not met, Nebula Graph does nothing. Consider the following example: nebula> INSERT VERTEX player(name, age) VALUES \"player111\":(\"Ben Simmons\", 22); -- Insert a new vertex. nebula> UPSERT VERTEX \"player111\" SET player.name = \"Dwight Howard\", player.age = $^.player.age + 11 WHEN $^.player.name == \"Ben Simmons\" AND $^.player.age > 20 YIELD $^.player.name AS Name, $^.player.age AS Age; -- Do an upsert operation on the vertex. +-----------------+-----+ | Name | Age | +-----------------+-----+ | \"Dwight Howard\" | 33 | +-----------------+-----+ nebula> FETCH PROP ON * \"player123\"; -- An empty set is returned, indicating vertex \"player123\" does not exist. Empty set (Time spent: 3.069/4.382 ms) nebula> UPSERT VERTEX \"player123\" SET player.age = $^.player.age + 1; If the vertex \"player123\" does not exist and the default value of age is NULL , the player.age of vertex \"player123\" is NULL . If player.age has a default value, the player.age of vertex \"player123\" is the default value plus one. nebula> CREATE TAG person(followers int, age int DEFAULT 0); -- Create example tag person nebula> UPSERT VERTEX \"300\" SET person.followers = $^.person.age + 1, person.age = 8; -- the number of followers is 1, age is 8 nebula> UPSERT VERTEX \"300\" SET person.age = 8, person.followers = $^.person.age + 1; -- the number of followers is 9, age is 8","title":"UPSERT VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/3.upsert-vertex/#upsert_vertex","text":"UPSERT VERTEX <vid> SET <update_columns> [WHEN <condition>] [YIELD <columns>] vid is the ID of the vertex to be updated. update_columns is the properties of the vertex to be updated. For example, tag1.col1 = $^.tag2.col2 + 1 means to update tag1.col1 to tag2.col2+1 . NOTE: $^ indicates the vertex to be updated. condition is some constraints. Only when the conditions are met, UPSERT is executed successfully. condition supports expression operations. columns is the columns to be returned, YIELD returns the latest updated values. UPSERT is a combination of UPDATE and INSERT . Use UPSERT VERTEX to update properties on a vertex if it exists or insert a new vertex if it does not exist. The UPDATE VERTEX statement only updates one tag of a vertex at a time. The performance of UPSERT is much lower than that of INSERT , because UPSERT is a read-modify-write serialization operation at the partition level. DON'T: DO NOT use UPSERT for scenarios with highly concurrent writes. If the vertex does not exist, a new vertex is created no matter whether the condition in the WHEN clause is met or not. The property columns not specified by the SET statement use the default values of the columns. If there are no default values, an error is returned. If the vertex exists and the WHEN condition is met, the vertex is updated. If the vertex exists and the WHEN condition is not met, Nebula Graph does nothing. Consider the following example: nebula> INSERT VERTEX player(name, age) VALUES \"player111\":(\"Ben Simmons\", 22); -- Insert a new vertex. nebula> UPSERT VERTEX \"player111\" SET player.name = \"Dwight Howard\", player.age = $^.player.age + 11 WHEN $^.player.name == \"Ben Simmons\" AND $^.player.age > 20 YIELD $^.player.name AS Name, $^.player.age AS Age; -- Do an upsert operation on the vertex. +-----------------+-----+ | Name | Age | +-----------------+-----+ | \"Dwight Howard\" | 33 | +-----------------+-----+ nebula> FETCH PROP ON * \"player123\"; -- An empty set is returned, indicating vertex \"player123\" does not exist. Empty set (Time spent: 3.069/4.382 ms) nebula> UPSERT VERTEX \"player123\" SET player.age = $^.player.age + 1; If the vertex \"player123\" does not exist and the default value of age is NULL , the player.age of vertex \"player123\" is NULL . If player.age has a default value, the player.age of vertex \"player123\" is the default value plus one. nebula> CREATE TAG person(followers int, age int DEFAULT 0); -- Create example tag person nebula> UPSERT VERTEX \"300\" SET person.followers = $^.person.age + 1, person.age = 8; -- the number of followers is 1, age is 8 nebula> UPSERT VERTEX \"300\" SET person.age = 8, person.followers = $^.person.age + 1; -- the number of followers is 9, age is 8","title":"UPSERT VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/","text":"DELETE VERTEX \u00b6 DELETE VERTEX <vid> [, <vid> ...] Use DELETE VERTEX to delete vertices and the related incoming and outgoing edges of the vertices. The DELETE VERTEX statement deletes one vertex or multiple vertices at a time. You can use DELETE VERTEX together with pipe. For more information about pipe, see Pipe operator . Examples \u00b6 nebula> DELETE VERTEX \"team1\"; This query deletes the vertex whose ID is \"team1\". nebula> GO FROM \"player100\" OVER serve YIELD serve._dst AS id | DELETE VERTEX $-.id; This query shows that you can use DELETE VERTEX together with pipe. Nebula Graph traverses the incoming and outgoing edges related to the vertices and deletes them all. Then Nebula Graph deletes information related to the vertices. NOTE: Atomic operation is not guaranteed during the entire process for now, so please retry when a failure occurs.","title":"DELETE VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/#delete_vertex","text":"DELETE VERTEX <vid> [, <vid> ...] Use DELETE VERTEX to delete vertices and the related incoming and outgoing edges of the vertices. The DELETE VERTEX statement deletes one vertex or multiple vertices at a time. You can use DELETE VERTEX together with pipe. For more information about pipe, see Pipe operator .","title":"DELETE VERTEX"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/#examples","text":"nebula> DELETE VERTEX \"team1\"; This query deletes the vertex whose ID is \"team1\". nebula> GO FROM \"player100\" OVER serve YIELD serve._dst AS id | DELETE VERTEX $-.id; This query shows that you can use DELETE VERTEX together with pipe. Nebula Graph traverses the incoming and outgoing edges related to the vertices and deletes them all. Then Nebula Graph deletes information related to the vertices. NOTE: Atomic operation is not guaranteed during the entire process for now, so please retry when a failure occurs.","title":"Examples"},{"location":"3.ngql-guide/14.index-statements/1.create-index/","text":"","title":"1.create index"},{"location":"3.ngql-guide/14.index-statements/2.show-indexes/","text":"","title":"2.show indexes"},{"location":"3.ngql-guide/14.index-statements/3.describe-index/","text":"","title":"3.describe index"},{"location":"3.ngql-guide/14.index-statements/4.rebuild-index/","text":"","title":"4.rebuild index"},{"location":"3.ngql-guide/14.index-statements/5.show-index-status/","text":"","title":"5.show index status"},{"location":"3.ngql-guide/14.index-statements/6.drop-index/","text":"DROP INDEX \u00b6 DROP {TAG | EDGE} INDEX [IF EXISTS] <index_name> The DROP INDEX statement drops an existing index from the current graph space. Dropping a nonexistent index results in an error. You can use the IF EXISTS option to conditionally drop the index and avoid the error. To run this statement you need some privilege. For information about the built-in roles in Nebula Graph, see Built-in roles (TODO). Example \u00b6 nebula> DROP TAG INDEX player_index_0; This query drops a tag index names player_index_0 .","title":"DROP INDEX"},{"location":"3.ngql-guide/14.index-statements/6.drop-index/#drop_index","text":"DROP {TAG | EDGE} INDEX [IF EXISTS] <index_name> The DROP INDEX statement drops an existing index from the current graph space. Dropping a nonexistent index results in an error. You can use the IF EXISTS option to conditionally drop the index and avoid the error. To run this statement you need some privilege. For information about the built-in roles in Nebula Graph, see Built-in roles (TODO).","title":"DROP INDEX"},{"location":"3.ngql-guide/14.index-statements/6.drop-index/#example","text":"nebula> DROP TAG INDEX player_index_0; This query drops a tag index names player_index_0 .","title":"Example"},{"location":"3.ngql-guide/15.subgraph-and-path/1.get-subgraph/","text":"GET SUBGRAPH \u00b6 The GET SUBGRAPH statement retrieves information of vertices and edges reachable from the start vertices over the specified types of edges. Syntax \u00b6 GET SUBGRAPH [<step_count> STEPS] FROM {<vid>, <vid>...} [IN <edge_type>, <edge_type>...] [OUT <edge_type>, <edge_type>...] [BOTH <edge_type>, <edge_type>...] Clause Description STEPS Specifies the steps to go from the start vertices. A step_count must be a non-negative integer. Its default value is 1. When <step_count> is specified to N , the Nebula Graph returns zero to N steps subgraph. FROM Specifies the start vertices. IN Gets the subgraphs from the start vertices over the specified incoming edges (edges pointing to the start vertices). OUT Gets the subgraphs from the start vertices over the specified outgoing edges (edges pointing out from the start vertices). BOTH Gets the subgraphs from the start vertices over the specified types of edges, both incoming and outgoing. When the traversal direction is not specified, both the incoming and outgoing edges are returned. Examples \u00b6 The following graph is used as the sample. Go one step from the vertex with VID \"player100\" over all types of edges and get the subgraph. nebula> GET SUBGRAPH 1 STEPS FROM \"player100\"; +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | _vertices | _edges | +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | [(player100) player.name:Tim,player.age:42] | [player100-[follow]->player101@0 degree:96,player100-[follow]->player102@0 degree:90,player100-[serve]->team200@0 end_year:2016,start_year:1997] | +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | [(player101) player.age:36,player.name:Tony Parker,(player102) player.age:33,player.name:LaMarcus Aldridge,(team200) team.name:Warriors] | [player102-[follow]->player101@0 degree:75] | +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ Got 2 rows (time spent 6289/7423 us) The returned subgraph is as follows. Go one step from the vertex with VID \"player100\" over incoming follow edges and get the subgraph. nebula> GET SUBGRAPH 1 STEPS FROM \"player100\" IN follow; +-----------+--------+ | _vertices | _edges | +-----------+--------+ | [] | [] | +-----------+--------+ | [] | [] | +-----------+--------+ Got 2 rows (time spent 2292/3091 us) There is no incoming follow edge to \"player100\", so no vertex or edge is returned. Go one step from the vertex \"player100\" over outgoing serve edges and get the subgraph. nebula> GET SUBGRAPH 1 STEPS FROM \"player100\" OUT serve; +---------------------------------------------+--------------------------------------------------------------+ | _vertices | _edges | +---------------------------------------------+--------------------------------------------------------------+ | [(player100) player.age:42,player.name:Tim] | [player100-[serve]->team200@0 start_year:1997,end_year:2016] | +---------------------------------------------+--------------------------------------------------------------+ | [(team200) team.name:Warriors] | [] | +---------------------------------------------+--------------------------------------------------------------+ Got 2 rows (time spent 2107/2547 us) The returned subgraph is as follows.","title":"GET SUBGRAPH"},{"location":"3.ngql-guide/15.subgraph-and-path/1.get-subgraph/#get_subgraph","text":"The GET SUBGRAPH statement retrieves information of vertices and edges reachable from the start vertices over the specified types of edges.","title":"GET SUBGRAPH"},{"location":"3.ngql-guide/15.subgraph-and-path/1.get-subgraph/#syntax","text":"GET SUBGRAPH [<step_count> STEPS] FROM {<vid>, <vid>...} [IN <edge_type>, <edge_type>...] [OUT <edge_type>, <edge_type>...] [BOTH <edge_type>, <edge_type>...] Clause Description STEPS Specifies the steps to go from the start vertices. A step_count must be a non-negative integer. Its default value is 1. When <step_count> is specified to N , the Nebula Graph returns zero to N steps subgraph. FROM Specifies the start vertices. IN Gets the subgraphs from the start vertices over the specified incoming edges (edges pointing to the start vertices). OUT Gets the subgraphs from the start vertices over the specified outgoing edges (edges pointing out from the start vertices). BOTH Gets the subgraphs from the start vertices over the specified types of edges, both incoming and outgoing. When the traversal direction is not specified, both the incoming and outgoing edges are returned.","title":"Syntax"},{"location":"3.ngql-guide/15.subgraph-and-path/1.get-subgraph/#examples","text":"The following graph is used as the sample. Go one step from the vertex with VID \"player100\" over all types of edges and get the subgraph. nebula> GET SUBGRAPH 1 STEPS FROM \"player100\"; +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | _vertices | _edges | +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | [(player100) player.name:Tim,player.age:42] | [player100-[follow]->player101@0 degree:96,player100-[follow]->player102@0 degree:90,player100-[serve]->team200@0 end_year:2016,start_year:1997] | +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ | [(player101) player.age:36,player.name:Tony Parker,(player102) player.age:33,player.name:LaMarcus Aldridge,(team200) team.name:Warriors] | [player102-[follow]->player101@0 degree:75] | +--------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+ Got 2 rows (time spent 6289/7423 us) The returned subgraph is as follows. Go one step from the vertex with VID \"player100\" over incoming follow edges and get the subgraph. nebula> GET SUBGRAPH 1 STEPS FROM \"player100\" IN follow; +-----------+--------+ | _vertices | _edges | +-----------+--------+ | [] | [] | +-----------+--------+ | [] | [] | +-----------+--------+ Got 2 rows (time spent 2292/3091 us) There is no incoming follow edge to \"player100\", so no vertex or edge is returned. Go one step from the vertex \"player100\" over outgoing serve edges and get the subgraph. nebula> GET SUBGRAPH 1 STEPS FROM \"player100\" OUT serve; +---------------------------------------------+--------------------------------------------------------------+ | _vertices | _edges | +---------------------------------------------+--------------------------------------------------------------+ | [(player100) player.age:42,player.name:Tim] | [player100-[serve]->team200@0 start_year:1997,end_year:2016] | +---------------------------------------------+--------------------------------------------------------------+ | [(team200) team.name:Warriors] | [] | +---------------------------------------------+--------------------------------------------------------------+ Got 2 rows (time spent 2107/2547 us) The returned subgraph is as follows.","title":"Examples"},{"location":"3.ngql-guide/16.query-tuning-statements/1.explain-and-profile/","text":"EXPLAIN and PROFILE \u00b6 EXPLAIN helps output the execution plan of an nGQL statement without executing the statement. PROFILE executes the statement, then outputs the execution plan as well as the execution profile. You can optimize the queries for better performance with the execution plan and profile. Execution Plan \u00b6 The execution plan is determined by the execution planner in the Nebula Graph query engine. The execution planner processes the parsed nGQL statements into actions. An action is the smallest unit that can be executed. A typical action fetches all neighbors of a given vertex, gets the properties of an edge, or filters vertices or edges based on the given conditions. Each action is assigned to an operator that performs the action. For example, a SHOW TAGS statement is processed into two actions and assigned to a Start operator and a ShowTags operator, while a more complex GO statement may be processed into more than 10 actions and assigned to 10 operators. Syntax \u00b6 EXPLAIN EXPLAIN [format=\"row\" | \"dot\"] <your_nGQL_statement> PROFILE PROFILE [format=\"row\" | \"dot\"] <your_nGQL_statement> Output formats \u00b6 The output of an EXPLAIN or a PROFILE statement has two formats, the default \"row\" format and the \"dot\" format. You can use the format option to modify the output format. Omitting the format option indicates using the default \"row\" format. Format \"row\" \u00b6 The \"row\" format outputs the return message in a table as follows. EXPLAIN : nebula> EXPLAIN format=\"row\" SHOW TAGS; Execution succeeded (time spent 104/705 us) Execution Plan +----+----------+--------------+----------------+-----------------------------------------------------------------------+ | id | name | dependencies | profiling data | operator info | +----+----------+--------------+----------------+-----------------------------------------------------------------------+ | 0 | ShowTags | 2 | | outputVar: [ {\"colNames\":[],\"name\":\"__ShowTags_0\",\"type\":\"DATASET\"}] | | | | | | inputVar: | +----+----------+--------------+----------------+-----------------------------------------------------------------------+ | 2 | Start | | | outputVar: [ {\"colNames\":[],\"name\":\"__Start_2\",\"type\":\"DATASET\"}] | +----+----------+--------------+----------------+-----------------------------------------------------------------------+ PROFILE : nebula> PROFILE format=\"row\" SHOW TAGS; +--------+ | Name | +--------+ | player | +--------+ | team | +--------+ Got 2 rows (time spent 2038/2728 us) Execution Plan +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ | id | name | dependencies | profiling data | operator info | +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ | 0 | ShowTags | 2 | ver: 0, rows: 1, execTime: 79us, totalTime: 1692us | outputVar: [{\"colNames\":[],\"name\":\"__ShowTags_0\",\"type\":\"DATASET\"}] | | | | | | inputVar: | +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ | 2 | Start | | ver: 0, rows: 0, execTime: 1us, totalTime: 57us | outputVar: [{\"colNames\":[],\"name\":\"__Start_2\",\"type\":\"DATASET\"}] | +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ The descriptions of the columns are as follows: Column Description id Indicates the ID of the operator. name Indicates the name of the operator. dependencies Shows the ID of the operator that the current operator depends on. profiling data Shows the execution profile. ver is the version of the operator, which you can use to identify loops; rows shows the number of rows to be output by the operator; execTime shows the execution time only; totalTime contains the execution time and the system scheduling and queueing time. operator info Shows the detailed information of the operator. Format \"dot\" \u00b6 You can use the format=\"dot\" option to output the return message in the DOT language, and then use Graphviz to generate a graph of the plan. NOTE : Graphviz is open source graph visualization software. Graphviz provides an online tool for previewing DOT language files and exporting them to other formats such as SVG or JSON. For more information, see Graphviz Online . nebula> EXPLAIN format=\"dot\" SHOW TAGS; Execution succeeded (time spent 161/665 us) Execution Plan --------------------------------------------------------------------------------------------------------------------------------------------- ------------- plan --------------------------------------------------------------------------------------------------------------------------------------------- ------------- digraph exec_plan { rankdir=LR; \"ShowTags_0\"[label=\"ShowTags_0|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__ShowTags_0\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar:\\l\", shape=Mrecord]; \"Start_2\"->\"ShowTags_0\"; \"Start_2\"[label=\"Start_2|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__Start_2\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar: \\l\", shape=Mrecord]; } --------------------------------------------------------------------------------------------------------------------------------------------- ------------- Transformed into a Graphviz graph, it is as follows:","title":"EXPLAIN and PROFILE"},{"location":"3.ngql-guide/16.query-tuning-statements/1.explain-and-profile/#explain_and_profile","text":"EXPLAIN helps output the execution plan of an nGQL statement without executing the statement. PROFILE executes the statement, then outputs the execution plan as well as the execution profile. You can optimize the queries for better performance with the execution plan and profile.","title":"EXPLAIN and PROFILE"},{"location":"3.ngql-guide/16.query-tuning-statements/1.explain-and-profile/#execution_plan","text":"The execution plan is determined by the execution planner in the Nebula Graph query engine. The execution planner processes the parsed nGQL statements into actions. An action is the smallest unit that can be executed. A typical action fetches all neighbors of a given vertex, gets the properties of an edge, or filters vertices or edges based on the given conditions. Each action is assigned to an operator that performs the action. For example, a SHOW TAGS statement is processed into two actions and assigned to a Start operator and a ShowTags operator, while a more complex GO statement may be processed into more than 10 actions and assigned to 10 operators.","title":"Execution Plan"},{"location":"3.ngql-guide/16.query-tuning-statements/1.explain-and-profile/#syntax","text":"EXPLAIN EXPLAIN [format=\"row\" | \"dot\"] <your_nGQL_statement> PROFILE PROFILE [format=\"row\" | \"dot\"] <your_nGQL_statement>","title":"Syntax"},{"location":"3.ngql-guide/16.query-tuning-statements/1.explain-and-profile/#output_formats","text":"The output of an EXPLAIN or a PROFILE statement has two formats, the default \"row\" format and the \"dot\" format. You can use the format option to modify the output format. Omitting the format option indicates using the default \"row\" format.","title":"Output formats"},{"location":"3.ngql-guide/16.query-tuning-statements/1.explain-and-profile/#format_row","text":"The \"row\" format outputs the return message in a table as follows. EXPLAIN : nebula> EXPLAIN format=\"row\" SHOW TAGS; Execution succeeded (time spent 104/705 us) Execution Plan +----+----------+--------------+----------------+-----------------------------------------------------------------------+ | id | name | dependencies | profiling data | operator info | +----+----------+--------------+----------------+-----------------------------------------------------------------------+ | 0 | ShowTags | 2 | | outputVar: [ {\"colNames\":[],\"name\":\"__ShowTags_0\",\"type\":\"DATASET\"}] | | | | | | inputVar: | +----+----------+--------------+----------------+-----------------------------------------------------------------------+ | 2 | Start | | | outputVar: [ {\"colNames\":[],\"name\":\"__Start_2\",\"type\":\"DATASET\"}] | +----+----------+--------------+----------------+-----------------------------------------------------------------------+ PROFILE : nebula> PROFILE format=\"row\" SHOW TAGS; +--------+ | Name | +--------+ | player | +--------+ | team | +--------+ Got 2 rows (time spent 2038/2728 us) Execution Plan +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ | id | name | dependencies | profiling data | operator info | +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ | 0 | ShowTags | 2 | ver: 0, rows: 1, execTime: 79us, totalTime: 1692us | outputVar: [{\"colNames\":[],\"name\":\"__ShowTags_0\",\"type\":\"DATASET\"}] | | | | | | inputVar: | +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ | 2 | Start | | ver: 0, rows: 0, execTime: 1us, totalTime: 57us | outputVar: [{\"colNames\":[],\"name\":\"__Start_2\",\"type\":\"DATASET\"}] | +----+----------+--------------+----------------------------------------------------+---------------------------------------------------------------------+ The descriptions of the columns are as follows: Column Description id Indicates the ID of the operator. name Indicates the name of the operator. dependencies Shows the ID of the operator that the current operator depends on. profiling data Shows the execution profile. ver is the version of the operator, which you can use to identify loops; rows shows the number of rows to be output by the operator; execTime shows the execution time only; totalTime contains the execution time and the system scheduling and queueing time. operator info Shows the detailed information of the operator.","title":"Format \"row\""},{"location":"3.ngql-guide/16.query-tuning-statements/1.explain-and-profile/#format_dot","text":"You can use the format=\"dot\" option to output the return message in the DOT language, and then use Graphviz to generate a graph of the plan. NOTE : Graphviz is open source graph visualization software. Graphviz provides an online tool for previewing DOT language files and exporting them to other formats such as SVG or JSON. For more information, see Graphviz Online . nebula> EXPLAIN format=\"dot\" SHOW TAGS; Execution succeeded (time spent 161/665 us) Execution Plan --------------------------------------------------------------------------------------------------------------------------------------------- ------------- plan --------------------------------------------------------------------------------------------------------------------------------------------- ------------- digraph exec_plan { rankdir=LR; \"ShowTags_0\"[label=\"ShowTags_0|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__ShowTags_0\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar:\\l\", shape=Mrecord]; \"Start_2\"->\"ShowTags_0\"; \"Start_2\"[label=\"Start_2|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__Start_2\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar: \\l\", shape=Mrecord]; } --------------------------------------------------------------------------------------------------------------------------------------------- ------------- Transformed into a Graphviz graph, it is as follows:","title":"Format \"dot\""},{"location":"3.ngql-guide/3.data-types/1.numeric/","text":"Numeric types \u00b6 Integer \u00b6 An integer is declared with keyword int , which is 64-bit signed . The supported range is [-9223372036854775808, 9223372036854775807]. Integer constants support multiple formats: Decimal, for example 123456 Hexadecimal, for example 0xdeadbeaf Octal, for example 01234567 Double floating point \u00b6 Double floating point data type is used for storing double precision floating point values. The keyword used for double floating point data type is double . There are no upper bounds and lower bounds.","title":"Numeric"},{"location":"3.ngql-guide/3.data-types/1.numeric/#numeric_types","text":"","title":"Numeric types"},{"location":"3.ngql-guide/3.data-types/1.numeric/#integer","text":"An integer is declared with keyword int , which is 64-bit signed . The supported range is [-9223372036854775808, 9223372036854775807]. Integer constants support multiple formats: Decimal, for example 123456 Hexadecimal, for example 0xdeadbeaf Octal, for example 01234567","title":"Integer"},{"location":"3.ngql-guide/3.data-types/1.numeric/#double_floating_point","text":"Double floating point data type is used for storing double precision floating point values. The keyword used for double floating point data type is double . There are no upper bounds and lower bounds.","title":"Double floating point"},{"location":"3.ngql-guide/3.data-types/2.boolean/","text":"Boolean \u00b6 A boolean data type is declared with the bool keyword and can only take the values true or false .","title":"Boolean"},{"location":"3.ngql-guide/3.data-types/2.boolean/#boolean","text":"A boolean data type is declared with the bool keyword and can only take the values true or false .","title":"Boolean"},{"location":"3.ngql-guide/3.data-types/3.string/","text":"String \u00b6 The string type is used to store a sequence of characters (text). The literal constant is a sequence of characters of any length surrounded by double or single quotes. For example \"Shaquille O'Neal\" or '\"This is a double-quoted literal string\"' . Line breaks are not allowed in a string. Embedded escape sequences are supported within strings, for example: \"\\n\\t\\r\\b\\f\" \"\\110ello world\"","title":"String"},{"location":"3.ngql-guide/3.data-types/3.string/#string","text":"The string type is used to store a sequence of characters (text). The literal constant is a sequence of characters of any length surrounded by double or single quotes. For example \"Shaquille O'Neal\" or '\"This is a double-quoted literal string\"' . Line breaks are not allowed in a string. Embedded escape sequences are supported within strings, for example: \"\\n\\t\\r\\b\\f\" \"\\110ello world\"","title":"String"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/","text":"Date and time types \u00b6 This document describes the DATE , TIME , DATETIME , and TIMESTAMP types. Nebula Graph converts the DATE , TIME , DATETIME , and TIMESTAMP values from the current time zone to UTC for storage. Nebula Graph converts back from UTC to the current time zone for retrieval. Combined with YIELD , functions date() , time() , datetime() all accept empty parameters to return the current date, time and datetime. DATE \u00b6 The DATE type is used for values with a date part but no time part. Nebula Graph retrieves and displays DATE values in the YYYY-MM-DD format. The supported range is -32768-01-01 to 32767-12-31 . TIME \u00b6 The TIME type is used for values with a time part but no date part. Nebula Graph retrieves and displays TIME values in hh:mm:ss:usus format. The supported range is 0:0:0:0 to 23:59:59:999999 . DATETIME \u00b6 The DATETIME type is used for values that contain both date and time parts. Nebula Graph retrieves and displays DATETIME values in YYYY-MM-DD hh:mm:ss:usus format. The supported range is -32768-01-01 00:00:00:00 to 32767-12-31 23:59:59:999999 . TIMESTAMP \u00b6 The TIMESTAMP data type is used for values that contain both date and time parts. TIMESTAMP has a range of 1970-01-01 00:00:01 UTC to 2262-04-11 23:47:16 UTC. Timestamp is measured in units of seconds. Supported TIMESTAMP inserting methods: Call the now() function. Input TIMESTAMP by using a string. For example: 2019-10-01 10:00:00 . Input TIMESTAMP directly, namely the number of seconds from 1970-01-01 00:00:00 . The underlying storage data type is: int64 . Examples \u00b6 Create a tag named date. nebula> CREATE TAG date(p1 date, p2 time, p3 datetime); Insert a vertex named Date1. nebula> INSERT VERTEX date(p1, p2, p3) VALUES \"Date1\":(date(\"2017-03-04\"), time(\"23:01:00\"), datetime(\"2017-03-04T22:30:40\")); Create a tag named school. nebula> CREATE TAG school(name string , create_time timestamp); Insert a vertex named \"stanford\" with the foundation date \"1885-10-01 08:00:00\" . nebula> INSERT VERTEX school(name, create_time) VALUES \"Stanford\":(\"Stanford\", \"1985-10-01 08:00:00\"); Insert a vertex named \"dut\" with the foundation date now. nebula> INSERT VERTEX school(name, create_time) VALUES \"dut\":(\"dut\", now());","title":"Date and time"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#date_and_time_types","text":"This document describes the DATE , TIME , DATETIME , and TIMESTAMP types. Nebula Graph converts the DATE , TIME , DATETIME , and TIMESTAMP values from the current time zone to UTC for storage. Nebula Graph converts back from UTC to the current time zone for retrieval. Combined with YIELD , functions date() , time() , datetime() all accept empty parameters to return the current date, time and datetime.","title":"Date and time types"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#date","text":"The DATE type is used for values with a date part but no time part. Nebula Graph retrieves and displays DATE values in the YYYY-MM-DD format. The supported range is -32768-01-01 to 32767-12-31 .","title":"DATE"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#time","text":"The TIME type is used for values with a time part but no date part. Nebula Graph retrieves and displays TIME values in hh:mm:ss:usus format. The supported range is 0:0:0:0 to 23:59:59:999999 .","title":"TIME"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#datetime","text":"The DATETIME type is used for values that contain both date and time parts. Nebula Graph retrieves and displays DATETIME values in YYYY-MM-DD hh:mm:ss:usus format. The supported range is -32768-01-01 00:00:00:00 to 32767-12-31 23:59:59:999999 .","title":"DATETIME"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#timestamp","text":"The TIMESTAMP data type is used for values that contain both date and time parts. TIMESTAMP has a range of 1970-01-01 00:00:01 UTC to 2262-04-11 23:47:16 UTC. Timestamp is measured in units of seconds. Supported TIMESTAMP inserting methods: Call the now() function. Input TIMESTAMP by using a string. For example: 2019-10-01 10:00:00 . Input TIMESTAMP directly, namely the number of seconds from 1970-01-01 00:00:00 . The underlying storage data type is: int64 .","title":"TIMESTAMP"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#examples","text":"Create a tag named date. nebula> CREATE TAG date(p1 date, p2 time, p3 datetime); Insert a vertex named Date1. nebula> INSERT VERTEX date(p1, p2, p3) VALUES \"Date1\":(date(\"2017-03-04\"), time(\"23:01:00\"), datetime(\"2017-03-04T22:30:40\")); Create a tag named school. nebula> CREATE TAG school(name string , create_time timestamp); Insert a vertex named \"stanford\" with the foundation date \"1885-10-01 08:00:00\" . nebula> INSERT VERTEX school(name, create_time) VALUES \"Stanford\":(\"Stanford\", \"1985-10-01 08:00:00\"); Insert a vertex named \"dut\" with the foundation date now. nebula> INSERT VERTEX school(name, create_time) VALUES \"dut\":(\"dut\", now());","title":"Examples"},{"location":"3.ngql-guide/3.data-types/5.null/","text":"NULL \u00b6 You can set the properties for vertices or edges to NULL . Also, you can set NOT NULL constraint to make sure that the property values are NOT NULL . If not specified, the property is set to NULL by default. Examples \u00b6 Create a tag named player. Specify the property name with NOT NULL . Skip the property age constraint. nebula> CREATE TAG player(name string NOT NULL, age int); Execution succeeded (time spent 5001/5980 us) The property name is NOT NULL . The property age is NULL by default. nebula> SHOW CREATE TAG player; +-----------+-----------------------------------+ | Tag | Create Tag | +-----------+-----------------------------------+ | \"student\" | \"CREATE TAG `player` ( | | | `name` string NOT NULL, | | | `age` int64 NULL | | | ) ttl_duration = 0, ttl_col = \"\"\" | +-----------+-----------------------------------+ nebula> INSERT VERTEX player(name, age) VALUES \"Kobe\":(\"Kobe\",null); Execution succeeded (time spent 6367/7357 us)","title":"NULL"},{"location":"3.ngql-guide/3.data-types/5.null/#null","text":"You can set the properties for vertices or edges to NULL . Also, you can set NOT NULL constraint to make sure that the property values are NOT NULL . If not specified, the property is set to NULL by default.","title":"NULL"},{"location":"3.ngql-guide/3.data-types/5.null/#examples","text":"Create a tag named player. Specify the property name with NOT NULL . Skip the property age constraint. nebula> CREATE TAG player(name string NOT NULL, age int); Execution succeeded (time spent 5001/5980 us) The property name is NOT NULL . The property age is NULL by default. nebula> SHOW CREATE TAG player; +-----------+-----------------------------------+ | Tag | Create Tag | +-----------+-----------------------------------+ | \"student\" | \"CREATE TAG `player` ( | | | `name` string NOT NULL, | | | `age` int64 NULL | | | ) ttl_duration = 0, ttl_col = \"\"\" | +-----------+-----------------------------------+ nebula> INSERT VERTEX player(name, age) VALUES \"Kobe\":(\"Kobe\",null); Execution succeeded (time spent 6367/7357 us)","title":"Examples"},{"location":"3.ngql-guide/3.data-types/6.list/","text":"List \u00b6 List is a composite data type. A composite data type cannot be stored as properties. List is a sequence of values. Individual list elements can be accessed by their positions. A list starts with a left square bracket [ and ends with a right square bracket ] . A list contains zero, one, or more expressions. List elements are separated from each other with a comma , . Whitespace around elements is ignored in list, thus line breaks, tab stops, and blanks can be used for formatting. CAUTION: A composite data type (i.e. set, map, and list) cannot be stored as properties. Examples \u00b6 [] [1, 2, 3]","title":"List"},{"location":"3.ngql-guide/3.data-types/6.list/#list","text":"List is a composite data type. A composite data type cannot be stored as properties. List is a sequence of values. Individual list elements can be accessed by their positions. A list starts with a left square bracket [ and ends with a right square bracket ] . A list contains zero, one, or more expressions. List elements are separated from each other with a comma , . Whitespace around elements is ignored in list, thus line breaks, tab stops, and blanks can be used for formatting. CAUTION: A composite data type (i.e. set, map, and list) cannot be stored as properties.","title":"List"},{"location":"3.ngql-guide/3.data-types/6.list/#examples","text":"[] [1, 2, 3]","title":"Examples"},{"location":"3.ngql-guide/3.data-types/7.set/","text":"Set \u00b6 Set is a composite data type. A composite data type cannot be stored as properties. Set is a string object that can have zero or more unique values. Individual set elements must be chosen from the list of values 'value1', 'value2', ... CAUTION: A composite data type (i.e. set, map, and list) cannot be stored as properties.","title":"Set"},{"location":"3.ngql-guide/3.data-types/7.set/#set","text":"Set is a composite data type. A composite data type cannot be stored as properties. Set is a string object that can have zero or more unique values. Individual set elements must be chosen from the list of values 'value1', 'value2', ... CAUTION: A composite data type (i.e. set, map, and list) cannot be stored as properties.","title":"Set"},{"location":"3.ngql-guide/3.data-types/8.map/","text":"Map \u00b6 Map is a composite data type. A composite data type cannot be stored as properties. Maps are unordered collections of key-value pairs. In maps, the key is a string. The value can have any data type. You can get the map element by using map['key'] .","title":"Map"},{"location":"3.ngql-guide/3.data-types/8.map/#map","text":"Map is a composite data type. A composite data type cannot be stored as properties. Maps are unordered collections of key-value pairs. In maps, the key is a string. The value can have any data type. You can get the map element by using map['key'] .","title":"Map"},{"location":"3.ngql-guide/3.data-types/9.type-conversion/","text":"Type Conversion \u00b6 Converting an expression of a given type to another type is known as type conversion. In nGQL, type conversion is divided into explicit conversion. Explicit type conversion \u00b6 In addition to implicit type conversion, explicit type conversion is also supported in case of semantics compliance. The syntax is similar to the C language: (type_name)expression . For example, the results of YIELD length((string)(123)), (int)\"123\" + 1 are 3, 124 respectively. The results of YIELD (int)(TRUE) is 1 . And YIELD (int)(\"12ab3\") fails in conversion.","title":"Type conversion"},{"location":"3.ngql-guide/3.data-types/9.type-conversion/#type_conversion","text":"Converting an expression of a given type to another type is known as type conversion. In nGQL, type conversion is divided into explicit conversion.","title":"Type Conversion"},{"location":"3.ngql-guide/3.data-types/9.type-conversion/#explicit_type_conversion","text":"In addition to implicit type conversion, explicit type conversion is also supported in case of semantics compliance. The syntax is similar to the C language: (type_name)expression . For example, the results of YIELD length((string)(123)), (int)\"123\" + 1 are 3, 124 respectively. The results of YIELD (int)(TRUE) is 1 . And YIELD (int)(\"12ab3\") fails in conversion.","title":"Explicit type conversion"},{"location":"3.ngql-guide/5.operators/1.comparison/","text":"Comparison operators \u00b6 Name Description = Assign a value / Division operator == Equal operator != Not equal operator < Less than operator <= Less than or equal operator - Minus operator % Modulo operator + Addition operator * Multiplication operator - Change the sign of the argument IS NULL NULL test IS NOT NULL not NULL test Comparison operations result in a value of true and false . == Equal. String comparisons are case-sensitive. Values of different types are not equal. NOTE: The equality operator is == in nGQL and is = in openCypher. nebula> YIELD 'A' == 'a'; +--------+ | (A==a) | +--------+ | false | +--------+ nebula> YIELD '2' == 2; +--------+ | (2==2) | +--------+ | false | +--------+ > Greater than: nebula> YIELD 3 > 2; +-------+ | (3>2) | +-------+ | true | +-------+ >= Greater than or equal to: nebula> YIELD 2 >= \"2\"; +--------+ | (2>=2) | +--------+ | false | +--------+ nebula> YIELD 2 >= 2; +--------+ | (2>=2) | +--------+ | true | +--------+ < Less than: nebula> YIELD 2.0 < 1.9; +---------+ | (2<1.9) | +---------+ | false | +---------+ <= Less than or equal to: nebula> YIELD 0.11 <= 0.11; +--------------+ | (0.11<=0.11) | +--------------+ | true | +--------------+ != Not equal: nebula> YIELD 1 != '1'; +--------+ | (1!=1) | +--------+ | true | +--------+ NULL nebula> TODO","title":"Comparison"},{"location":"3.ngql-guide/5.operators/1.comparison/#comparison_operators","text":"Name Description = Assign a value / Division operator == Equal operator != Not equal operator < Less than operator <= Less than or equal operator - Minus operator % Modulo operator + Addition operator * Multiplication operator - Change the sign of the argument IS NULL NULL test IS NOT NULL not NULL test Comparison operations result in a value of true and false . == Equal. String comparisons are case-sensitive. Values of different types are not equal. NOTE: The equality operator is == in nGQL and is = in openCypher. nebula> YIELD 'A' == 'a'; +--------+ | (A==a) | +--------+ | false | +--------+ nebula> YIELD '2' == 2; +--------+ | (2==2) | +--------+ | false | +--------+ > Greater than: nebula> YIELD 3 > 2; +-------+ | (3>2) | +-------+ | true | +-------+ >= Greater than or equal to: nebula> YIELD 2 >= \"2\"; +--------+ | (2>=2) | +--------+ | false | +--------+ nebula> YIELD 2 >= 2; +--------+ | (2>=2) | +--------+ | true | +--------+ < Less than: nebula> YIELD 2.0 < 1.9; +---------+ | (2<1.9) | +---------+ | false | +---------+ <= Less than or equal to: nebula> YIELD 0.11 <= 0.11; +--------------+ | (0.11<=0.11) | +--------------+ | true | +--------------+ != Not equal: nebula> YIELD 1 != '1'; +--------+ | (1!=1) | +--------+ | true | +--------+ NULL nebula> TODO","title":"Comparison operators"},{"location":"3.ngql-guide/5.operators/4.pipe/","text":"Pipe operator \u00b6 One major difference between nGQL and SQL is how sub-queries are composed. In SQL, to form a statement, sub-queries are nested (embedded). In nGQL the shell style PIPE (|) is introduced. Examples \u00b6 nebula> GO FROM \"player100\" OVER follow \\ YIELD follow._dst AS dstid, $$.player.name AS Name \\ | GO FROM $-.dstid OVER follow; +-------------+ | follow._dst | +-------------+ | \"player101\" | +-------------+ If no YIELD is used, the destination vertex ID is returned by default. If YIELD is declared explicitly, (the default value) id are not returned. To use pipe, always define alias names in the YIELD statement for the placeholder $-. . For example, the alias names are dstid and Name here.","title":"Pipe"},{"location":"3.ngql-guide/5.operators/4.pipe/#pipe_operator","text":"One major difference between nGQL and SQL is how sub-queries are composed. In SQL, to form a statement, sub-queries are nested (embedded). In nGQL the shell style PIPE (|) is introduced.","title":"Pipe operator"},{"location":"3.ngql-guide/5.operators/4.pipe/#examples","text":"nebula> GO FROM \"player100\" OVER follow \\ YIELD follow._dst AS dstid, $$.player.name AS Name \\ | GO FROM $-.dstid OVER follow; +-------------+ | follow._dst | +-------------+ | \"player101\" | +-------------+ If no YIELD is used, the destination vertex ID is returned by default. If YIELD is declared explicitly, (the default value) id are not returned. To use pipe, always define alias names in the YIELD statement for the placeholder $-. . For example, the alias names are dstid and Name here.","title":"Examples"},{"location":"3.ngql-guide/5.operators/5.property-reference/","text":"Property reference operator \u00b6 You can refer properties in WHERE or YIELD syntax. Reference from vertex \u00b6 For source vertex \u00b6 $^.<tag_name>.<prop_name> The symbol $^ is used to get the property of the source vertex, <tag_name> indicates the tag of the source vertex, and <prop_name> specifies the property name. For destination vertex \u00b6 $$.<tag_name>.<prop_name> The symbol $$ indicates the destination vertex, <tag_name> and <prop_name> are the tag and property of the destination vertex. Reference from edge \u00b6 For property \u00b6 To get properties of an edge, use the following syntax. <edge_type>.<edge_prop> The <edge_type> is the type of the edg. The <edge_prop> is the property of the edge. For Built-in Properties \u00b6 There are four built-in properties in the edge: _src: source vertex ID of the edge _dst: destination ID of the edge _type: edge type _rank: the edge's rank You can use _src and _dst to get the starting and ending vertices' ID, and they are very commonly used to show a graph path. Examples \u00b6 nebula> GO FROM \"player100\" OVER follow YIELD $^.player.name AS startName, $$.player.age AS endAge; +-----------+--------+ | startName | endAge | +-----------+--------+ | \"Tim\" | 36 | +-----------+--------+ | \"Tim\" | 33 | +-----------+--------+ Use the above query to get the name property of the source vertex and the age property of the destination vertex. nebula> GO FROM \"player100\" OVER follow YIELD follow.degree; +---------------+ | follow.degree | +---------------+ | 96 | +---------------+ | 90 | +---------------+ nebula> GO FROM \"player100\" OVER follow YIELD follow._src, follow._dst, follow._type, follow._rank; +-------------+-------------+--------------+--------------+ | follow._src | follow._dst | follow._type | follow._rank | +-------------+-------------+--------------+--------------+ | \"player100\" | \"player101\" | 11 | 0 | +-------------+-------------+--------------+--------------+ | \"player100\" | \"player102\" | 11 | 0 | +-------------+-------------+--------------+--------------+ This statement returns all the neighbors of vertex player100 over edge type follow , by referencing follow._src as the starting vertex ID (which, of course, is player100 ) and follow._dst as the ending vertex ID.","title":"Property reference"},{"location":"3.ngql-guide/5.operators/5.property-reference/#property_reference_operator","text":"You can refer properties in WHERE or YIELD syntax.","title":"Property reference operator"},{"location":"3.ngql-guide/5.operators/5.property-reference/#reference_from_vertex","text":"","title":"Reference from vertex"},{"location":"3.ngql-guide/5.operators/5.property-reference/#for_source_vertex","text":"$^.<tag_name>.<prop_name> The symbol $^ is used to get the property of the source vertex, <tag_name> indicates the tag of the source vertex, and <prop_name> specifies the property name.","title":"For source vertex"},{"location":"3.ngql-guide/5.operators/5.property-reference/#for_destination_vertex","text":"$$.<tag_name>.<prop_name> The symbol $$ indicates the destination vertex, <tag_name> and <prop_name> are the tag and property of the destination vertex.","title":"For destination vertex"},{"location":"3.ngql-guide/5.operators/5.property-reference/#reference_from_edge","text":"","title":"Reference from edge"},{"location":"3.ngql-guide/5.operators/5.property-reference/#for_property","text":"To get properties of an edge, use the following syntax. <edge_type>.<edge_prop> The <edge_type> is the type of the edg. The <edge_prop> is the property of the edge.","title":"For property"},{"location":"3.ngql-guide/5.operators/5.property-reference/#for_built-in_properties","text":"There are four built-in properties in the edge: _src: source vertex ID of the edge _dst: destination ID of the edge _type: edge type _rank: the edge's rank You can use _src and _dst to get the starting and ending vertices' ID, and they are very commonly used to show a graph path.","title":"For Built-in Properties"},{"location":"3.ngql-guide/5.operators/5.property-reference/#examples","text":"nebula> GO FROM \"player100\" OVER follow YIELD $^.player.name AS startName, $$.player.age AS endAge; +-----------+--------+ | startName | endAge | +-----------+--------+ | \"Tim\" | 36 | +-----------+--------+ | \"Tim\" | 33 | +-----------+--------+ Use the above query to get the name property of the source vertex and the age property of the destination vertex. nebula> GO FROM \"player100\" OVER follow YIELD follow.degree; +---------------+ | follow.degree | +---------------+ | 96 | +---------------+ | 90 | +---------------+ nebula> GO FROM \"player100\" OVER follow YIELD follow._src, follow._dst, follow._type, follow._rank; +-------------+-------------+--------------+--------------+ | follow._src | follow._dst | follow._type | follow._rank | +-------------+-------------+--------------+--------------+ | \"player100\" | \"player101\" | 11 | 0 | +-------------+-------------+--------------+--------------+ | \"player100\" | \"player102\" | 11 | 0 | +-------------+-------------+--------------+--------------+ This statement returns all the neighbors of vertex player100 over edge type follow , by referencing follow._src as the starting vertex ID (which, of course, is player100 ) and follow._dst as the ending vertex ID.","title":"Examples"},{"location":"3.ngql-guide/5.operators/6.set/","text":"Set operations \u00b6 This document descriptions the set operations, including UNION , UNION ALL , INTERSECT , and MINUS . To combine multiple queries, use the set operators. All set operators have equal precedence. If a nGQL statement contains multiple set operators, Nebula Graph evaluates them from the left to right unless parentheses explicitly specify another order. To use the set operators, always match the return results of the GO clause with the same number and data type. UNION, UNION DISTINCT, and UNION ALL \u00b6 <left> UNION [DISTINCT | ALL] <right> [ UNION [DISTINCT | ALL] <right> ...] Operator UNION DISTINCT (or by short UNION ) returns the union of two sets A and B without the duplicate elements. Operator UNION ALL returns the union of two sets A and B with duplicated elements. The <left> and <right> must have the same number of columns and data types. Different data types are converted according to the Type Conversion . Example \u00b6 The following statement nebula> GO FROM \"player102\" OVER follow \\ UNION \\ GO FROM \"player100\" OVER follow; +-------------+ | follow._dst | +-------------+ | \"player101\" | +-------------+ | \"player102\" | +-------------+ returns the neighbors' id of vertex \"player102\" and \"player100 (along with edge follow ) without duplication. While nebula> GO FROM \"player102\" OVER follow \\ UNION ALL \\ GO FROM \"player100\" OVER follow; +-------------+ | follow._dst | +-------------+ | \"player101\" | +-------------+ | \"player101\" | +-------------+ | \"player102\" | +-------------+ returns all the neighbors of vertex \"player102\" and \"player100 , with all possible duplications. UNION can also work with the YIELD statement. For example, let's suppose the results of the following two queries. nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; -- query 1 +-------------+--------+-----+ | id | Degree | Age | +-------------+--------+-----+ | \"player101\" | 75 | 36 | -- line 1 +-------------+--------+-----+ nebula> GO FROM \"player100\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; -- query 2 +-------------+--------+-----+ | id | Degree | Age | +-------------+--------+-----+ | \"player101\" | 96 | 36 | -- line 2 +-------------+--------+-----+ | \"player102\" | 90 | 33 | -- line 3 +-------------+--------+-----+ And the following statement nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age \\ UNION /* DISTINCT */ \\ GO FROM \"player100\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; returns the follows: +-------------+--------+-----+ | id | Degree | Age | +-------------+--------+-----+ | \"player101\" | 75 | 36 | -- line 1 +-------------+--------+-----+ | \"player101\" | 96 | 36 | -- line 2 +-------------+--------+-----+ | \"player102\" | 90 | 33 | -- line 3 +-------------+--------+-----+ The DISTINCT check duplication by all the columns for every line. So line 1 and line 2 are different. INTERSECT \u00b6 <left> INTERSECT <right> Operator INTERSECT returns the intersection of two sets A and B (denoted by A \u22c2 B). Similar to UNION , the <left> and <right> must have the same number of columns and data types. Only the INTERSECT columns of <left> and <right> are returned. For example, the following query nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age \\ INTERSECT \\ GO FROM \"player100\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; returns Empty set (time spent 5194/6264 us) MINUS \u00b6 <left> MINUS <right> Operator MINUS returns the subtraction (or difference) of two sets A and B (denoted by A - B). Always pay attention to the order of the <left> and <right> . The set A - B consists of elements that are in A but not in B. For example, the following query nebula> GO FROM \"player100\" OVER follow \\ MINUS \\ GO FROM \"player102\" OVER follow; returns +-------------+ | follow._dst | +-------------+ | \"player102\" | +-------------+ If you reverse the MINUS order, the query nebula> GO FROM \"player102\" OVER follow \\ MINUS \\ GO FROM \"player100\" OVER follow; returns Empty set (time spent 2243/3259 us) Precedence of the SET Operations and Pipe \u00b6 Please note that when a query contains pipe | and set operations, pipe takes precedence. Refer to the Pipe Doc for details. Query GO FROM 1 UNION GO FROM 2 | GO FROM 3 is the same as query GO FROM 1 UNION (GO FROM 2 | GO FROM 3) . For example: nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS play_dst \\ UNION \\ GO FROM \"team200\" OVER serve REVERSELY YIELD serve._dst AS play_dst \\ | GO FROM $-.play_dst OVER follow YIELD follow._dst AS play_dst; +-------------+ | play_dst | +-------------+ | \"player101\" | +-------------+ | \"player102\" | +-------------+ The statements in the red bar are executed first. And then the statement in the green box is executed. nebula> (GO FROM \"player102\" OVER follow YIELD follow._dst AS play_dst \\ UNION \\ GO FROM \"team200\" OVER serve REVERSELY YIELD serve._dst AS play_dst) \\ | GO FROM $-.play_dst OVER follow YIELD follow._dst AS play_dst; In the above query, the parentheses change the execution priority, and the statements within the parentheses take the precedence.","title":"Set"},{"location":"3.ngql-guide/5.operators/6.set/#set_operations","text":"This document descriptions the set operations, including UNION , UNION ALL , INTERSECT , and MINUS . To combine multiple queries, use the set operators. All set operators have equal precedence. If a nGQL statement contains multiple set operators, Nebula Graph evaluates them from the left to right unless parentheses explicitly specify another order. To use the set operators, always match the return results of the GO clause with the same number and data type.","title":"Set operations"},{"location":"3.ngql-guide/5.operators/6.set/#union_union_distinct_and_union_all","text":"<left> UNION [DISTINCT | ALL] <right> [ UNION [DISTINCT | ALL] <right> ...] Operator UNION DISTINCT (or by short UNION ) returns the union of two sets A and B without the duplicate elements. Operator UNION ALL returns the union of two sets A and B with duplicated elements. The <left> and <right> must have the same number of columns and data types. Different data types are converted according to the Type Conversion .","title":"UNION, UNION DISTINCT, and UNION ALL"},{"location":"3.ngql-guide/5.operators/6.set/#example","text":"The following statement nebula> GO FROM \"player102\" OVER follow \\ UNION \\ GO FROM \"player100\" OVER follow; +-------------+ | follow._dst | +-------------+ | \"player101\" | +-------------+ | \"player102\" | +-------------+ returns the neighbors' id of vertex \"player102\" and \"player100 (along with edge follow ) without duplication. While nebula> GO FROM \"player102\" OVER follow \\ UNION ALL \\ GO FROM \"player100\" OVER follow; +-------------+ | follow._dst | +-------------+ | \"player101\" | +-------------+ | \"player101\" | +-------------+ | \"player102\" | +-------------+ returns all the neighbors of vertex \"player102\" and \"player100 , with all possible duplications. UNION can also work with the YIELD statement. For example, let's suppose the results of the following two queries. nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; -- query 1 +-------------+--------+-----+ | id | Degree | Age | +-------------+--------+-----+ | \"player101\" | 75 | 36 | -- line 1 +-------------+--------+-----+ nebula> GO FROM \"player100\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; -- query 2 +-------------+--------+-----+ | id | Degree | Age | +-------------+--------+-----+ | \"player101\" | 96 | 36 | -- line 2 +-------------+--------+-----+ | \"player102\" | 90 | 33 | -- line 3 +-------------+--------+-----+ And the following statement nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age \\ UNION /* DISTINCT */ \\ GO FROM \"player100\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; returns the follows: +-------------+--------+-----+ | id | Degree | Age | +-------------+--------+-----+ | \"player101\" | 75 | 36 | -- line 1 +-------------+--------+-----+ | \"player101\" | 96 | 36 | -- line 2 +-------------+--------+-----+ | \"player102\" | 90 | 33 | -- line 3 +-------------+--------+-----+ The DISTINCT check duplication by all the columns for every line. So line 1 and line 2 are different.","title":"Example"},{"location":"3.ngql-guide/5.operators/6.set/#intersect","text":"<left> INTERSECT <right> Operator INTERSECT returns the intersection of two sets A and B (denoted by A \u22c2 B). Similar to UNION , the <left> and <right> must have the same number of columns and data types. Only the INTERSECT columns of <left> and <right> are returned. For example, the following query nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age \\ INTERSECT \\ GO FROM \"player100\" OVER follow YIELD follow._dst AS id, follow.degree AS Degree, $$.player.age AS Age; returns Empty set (time spent 5194/6264 us)","title":"INTERSECT"},{"location":"3.ngql-guide/5.operators/6.set/#minus","text":"<left> MINUS <right> Operator MINUS returns the subtraction (or difference) of two sets A and B (denoted by A - B). Always pay attention to the order of the <left> and <right> . The set A - B consists of elements that are in A but not in B. For example, the following query nebula> GO FROM \"player100\" OVER follow \\ MINUS \\ GO FROM \"player102\" OVER follow; returns +-------------+ | follow._dst | +-------------+ | \"player102\" | +-------------+ If you reverse the MINUS order, the query nebula> GO FROM \"player102\" OVER follow \\ MINUS \\ GO FROM \"player100\" OVER follow; returns Empty set (time spent 2243/3259 us)","title":"MINUS"},{"location":"3.ngql-guide/5.operators/6.set/#precedence_of_the_set_operations_and_pipe","text":"Please note that when a query contains pipe | and set operations, pipe takes precedence. Refer to the Pipe Doc for details. Query GO FROM 1 UNION GO FROM 2 | GO FROM 3 is the same as query GO FROM 1 UNION (GO FROM 2 | GO FROM 3) . For example: nebula> GO FROM \"player102\" OVER follow YIELD follow._dst AS play_dst \\ UNION \\ GO FROM \"team200\" OVER serve REVERSELY YIELD serve._dst AS play_dst \\ | GO FROM $-.play_dst OVER follow YIELD follow._dst AS play_dst; +-------------+ | play_dst | +-------------+ | \"player101\" | +-------------+ | \"player102\" | +-------------+ The statements in the red bar are executed first. And then the statement in the green box is executed. nebula> (GO FROM \"player102\" OVER follow YIELD follow._dst AS play_dst \\ UNION \\ GO FROM \"team200\" OVER serve REVERSELY YIELD serve._dst AS play_dst) \\ | GO FROM $-.play_dst OVER follow YIELD follow._dst AS play_dst; In the above query, the parentheses change the execution priority, and the statements within the parentheses take the precedence.","title":"Precedence of the SET Operations and Pipe"},{"location":"3.ngql-guide/5.operators/7.string/","text":"String operators \u00b6 Name Description CONTAINS Perform case-sensitive inclusion searching in strings IN Whether a value is within a set of values (NOT) STARTS WITH Perform case-sensitive matching on the beginning of a string (NOT) ENDS WITH Perform case-sensitive matching on the ending of a string NOTE: All the string matchings are case-sensitive. Examples \u00b6 CONTAINS The CONTAINS operator requires string type in both left and right side. nebula> GO FROM \"player101\" OVER serve WHERE $$.team.name CONTAINS \"ets\" \\ YIELD $^.player.name, serve.start_year, serve.end_year, $$.team.name; +----------------+------------------+----------------+--------------+ | $^.player.name | serve.start_year | serve.end_year | $$.team.name | +----------------+------------------+----------------+--------------+ | \"Tony Parker\" | 1999 | 2018 | \"Nuggets\" | +----------------+------------------+----------------+--------------+ nebula> GO FROM \"player101\" OVER serve WHERE (STRING)serve.start_year CONTAINS \"19\" AND \\ $^.player.name CONTAINS \"ny\" \\ YIELD $^.player.name, serve.start_year, serve.end_year, $$.team.name; +----------------+------------------+----------------+--------------+ | $^.player.name | serve.start_year | serve.end_year | $$.team.name | +----------------+------------------+----------------+--------------+ | \"Tony Parker\" | 1999 | 2018 | \"Nuggets\" | +----------------+------------------+----------------+--------------+ nebula> GO FROM \"player101\" OVER serve WHERE !($$.team.name CONTAINS \"ets\") \\ YIELD $^.player.name, serve.start_year, serve.end_year, $$.team.name; Empty set (time spent 13040/14021 us) IN nebula> YIELD 1 IN [1,2,3]; +----------------+ | (1 IN [1,2,3]) | +----------------+ | true | +----------------+ nebula> YIELD \"Yao\" IN [\"Yi\", \"Tim\", \"Kobe\"]; +------------------------+ | (Yao IN [Yi,Tim,Kobe]) | +------------------------+ | false | +------------------------+ nebula> YIELD NULL in [\"Yi\", \"Tim\", \"Kobe\"]; +-----------------------------+ | (__NULL__ IN [Yi,Tim,Kobe]) | +-----------------------------+ | NULL | +-----------------------------+ (NOT) STARTS WITH nebula> YIELD 'apple' STARTS WITH 'app'; +-------------------------+ | (apple STARTS WITH app) | +-------------------------+ | true | +-------------------------+ nebula> YIELD 'apple' STARTS WITH 'a'; +-----------------------+ | (apple STARTS WITH a) | +-----------------------+ | true | +-----------------------+ nebula> YIELD 'apple' STARTS WITH 'A'; +-----------------------+ | (apple STARTS WITH A) | +-----------------------+ | false | +-----------------------+ nebula> YIELD 'apple' STARTS WITH 'b'; +-----------------------+ | (apple STARTS WITH b) | +-----------------------+ | false | +-----------------------+ nebula> YIELD 'apple' NOT STARTS WITH 'app'; +-----------------------------+ | (apple NOT STARTS WITH app) | +-----------------------------+ | false | +-----------------------------+ (NOT) ENDS WITH nebula> YIELD 'apple' ENDS WITH 'app'; +-----------------------+ | (apple ENDS WITH app) | +-----------------------+ | false | +-----------------------+ nebula> YIELD 'apple' ENDS WITH 'e'; +---------------------+ | (apple ENDS WITH e) | +---------------------+ | true | +---------------------+ nebula> YIELD 'apple' ENDS WITH 'E'; +---------------------+ | (apple ENDS WITH E) | +---------------------+ | false | +---------------------+ nebula> YIELD 'apple' ENDS WITH 'b'; +---------------------+ | (apple ENDS WITH b) | +---------------------+ | false | +---------------------+","title":"String"},{"location":"3.ngql-guide/5.operators/7.string/#string_operators","text":"Name Description CONTAINS Perform case-sensitive inclusion searching in strings IN Whether a value is within a set of values (NOT) STARTS WITH Perform case-sensitive matching on the beginning of a string (NOT) ENDS WITH Perform case-sensitive matching on the ending of a string NOTE: All the string matchings are case-sensitive.","title":"String operators"},{"location":"3.ngql-guide/5.operators/7.string/#examples","text":"CONTAINS The CONTAINS operator requires string type in both left and right side. nebula> GO FROM \"player101\" OVER serve WHERE $$.team.name CONTAINS \"ets\" \\ YIELD $^.player.name, serve.start_year, serve.end_year, $$.team.name; +----------------+------------------+----------------+--------------+ | $^.player.name | serve.start_year | serve.end_year | $$.team.name | +----------------+------------------+----------------+--------------+ | \"Tony Parker\" | 1999 | 2018 | \"Nuggets\" | +----------------+------------------+----------------+--------------+ nebula> GO FROM \"player101\" OVER serve WHERE (STRING)serve.start_year CONTAINS \"19\" AND \\ $^.player.name CONTAINS \"ny\" \\ YIELD $^.player.name, serve.start_year, serve.end_year, $$.team.name; +----------------+------------------+----------------+--------------+ | $^.player.name | serve.start_year | serve.end_year | $$.team.name | +----------------+------------------+----------------+--------------+ | \"Tony Parker\" | 1999 | 2018 | \"Nuggets\" | +----------------+------------------+----------------+--------------+ nebula> GO FROM \"player101\" OVER serve WHERE !($$.team.name CONTAINS \"ets\") \\ YIELD $^.player.name, serve.start_year, serve.end_year, $$.team.name; Empty set (time spent 13040/14021 us) IN nebula> YIELD 1 IN [1,2,3]; +----------------+ | (1 IN [1,2,3]) | +----------------+ | true | +----------------+ nebula> YIELD \"Yao\" IN [\"Yi\", \"Tim\", \"Kobe\"]; +------------------------+ | (Yao IN [Yi,Tim,Kobe]) | +------------------------+ | false | +------------------------+ nebula> YIELD NULL in [\"Yi\", \"Tim\", \"Kobe\"]; +-----------------------------+ | (__NULL__ IN [Yi,Tim,Kobe]) | +-----------------------------+ | NULL | +-----------------------------+ (NOT) STARTS WITH nebula> YIELD 'apple' STARTS WITH 'app'; +-------------------------+ | (apple STARTS WITH app) | +-------------------------+ | true | +-------------------------+ nebula> YIELD 'apple' STARTS WITH 'a'; +-----------------------+ | (apple STARTS WITH a) | +-----------------------+ | true | +-----------------------+ nebula> YIELD 'apple' STARTS WITH 'A'; +-----------------------+ | (apple STARTS WITH A) | +-----------------------+ | false | +-----------------------+ nebula> YIELD 'apple' STARTS WITH 'b'; +-----------------------+ | (apple STARTS WITH b) | +-----------------------+ | false | +-----------------------+ nebula> YIELD 'apple' NOT STARTS WITH 'app'; +-----------------------------+ | (apple NOT STARTS WITH app) | +-----------------------------+ | false | +-----------------------------+ (NOT) ENDS WITH nebula> YIELD 'apple' ENDS WITH 'app'; +-----------------------+ | (apple ENDS WITH app) | +-----------------------+ | false | +-----------------------+ nebula> YIELD 'apple' ENDS WITH 'e'; +---------------------+ | (apple ENDS WITH e) | +---------------------+ | true | +---------------------+ nebula> YIELD 'apple' ENDS WITH 'E'; +---------------------+ | (apple ENDS WITH E) | +---------------------+ | false | +---------------------+ nebula> YIELD 'apple' ENDS WITH 'b'; +---------------------+ | (apple ENDS WITH b) | +---------------------+ | false | +---------------------+","title":"Examples"},{"location":"3.ngql-guide/5.operators/9.precedence/","text":"Operator precedence \u00b6 The following list shows the precedence of nGQL operators in descending order. Operators that are shown together on a line have the same precedence. - (negative number) ! *, /, % -, + == , >=, >, <=, <, <>, != AND OR = (assignment) For operators that occur at the same precedence level within an expression, evaluation proceeds left to right, with the exception that assignments evaluate right to left. The precedence of operators determines the order of evaluation of terms in an expression. To override this order and group terms explicitly, use parentheses. Examples \u00b6 nebula> YIELD 2+3*5; +-----------+ | (2+(3*5)) | +-----------+ | 17 | +-----------+ nebula> YIELD (2+3)*5; +-----------+ | ((2+3)*5) | +-----------+ | 25 | +-----------+","title":"Precedence"},{"location":"3.ngql-guide/5.operators/9.precedence/#operator_precedence","text":"The following list shows the precedence of nGQL operators in descending order. Operators that are shown together on a line have the same precedence. - (negative number) ! *, /, % -, + == , >=, >, <=, <, <>, != AND OR = (assignment) For operators that occur at the same precedence level within an expression, evaluation proceeds left to right, with the exception that assignments evaluate right to left. The precedence of operators determines the order of evaluation of terms in an expression. To override this order and group terms explicitly, use parentheses.","title":"Operator precedence"},{"location":"3.ngql-guide/5.operators/9.precedence/#examples","text":"nebula> YIELD 2+3*5; +-----------+ | (2+(3*5)) | +-----------+ | 17 | +-----------+ nebula> YIELD (2+3)*5; +-----------+ | ((2+3)*5) | +-----------+ | 25 | +-----------+","title":"Examples"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/","text":"Built-in math functions \u00b6 Nebula Graph supports the following built-in math functions: Function Description double abs(double x) Return absolute value of the argument. double floor(double x) Return the largest integer value smaller than or equal to the argument. (Rounds down) double ceil(double x) Return the smallest integer greater than or equal to the argument. (Rounds up) double round(double x) Return integral value nearest to the argument, returns a number farther away from 0 if the parameter is in the middle. double sqrt(double x) Return the square root of the argument. double cbrt(double x) Return the cubic root of the argument. double hypot(double x, double y) Return the hypotenuse of a right-angled triangle. double pow(double x, double y) Compute the power of the argument. double exp(double x) Return the value of e raised to the x power. double exp2(double x) Return 2 raised to the argument. double log(double x) Return natural logarithm of the argument. double log2(double x) Return the base-2 logarithm of the argument. double log10(double x) Return the base-10 logarithm of the argument. double sin(double x) Return sine of the argument. double asin(double x) Return inverse sine of the argument. double cos(double x) Return cosine of the argument. double acos(double x) Return inverse cosine of the argument. double tan(double x) Return tangent of the argument. double atan(double x) Return inverse tangent the argument. int rand32() Return a random 32 bit integer. int rand32(int max) Return a random 32 bit integer in [0, max). int rand32(int min, int max) Return a random 32 bit integer in [min, max). int rand64() Return a random 64 bit integer. int rand64(int max) Return a random 64 bit integer in [0, max). int rand64(int min, int max) Return a random 64 bit integer in [min, max). collect() Put all the collected values to a list. collect_set() Put all the collected values to a set. int size() Return the number of elements in a list. map(fun, iter) Return a map object after applying the given function to each item of a given iterable.","title":"Math"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#built-in_math_functions","text":"Nebula Graph supports the following built-in math functions: Function Description double abs(double x) Return absolute value of the argument. double floor(double x) Return the largest integer value smaller than or equal to the argument. (Rounds down) double ceil(double x) Return the smallest integer greater than or equal to the argument. (Rounds up) double round(double x) Return integral value nearest to the argument, returns a number farther away from 0 if the parameter is in the middle. double sqrt(double x) Return the square root of the argument. double cbrt(double x) Return the cubic root of the argument. double hypot(double x, double y) Return the hypotenuse of a right-angled triangle. double pow(double x, double y) Compute the power of the argument. double exp(double x) Return the value of e raised to the x power. double exp2(double x) Return 2 raised to the argument. double log(double x) Return natural logarithm of the argument. double log2(double x) Return the base-2 logarithm of the argument. double log10(double x) Return the base-10 logarithm of the argument. double sin(double x) Return sine of the argument. double asin(double x) Return inverse sine of the argument. double cos(double x) Return cosine of the argument. double acos(double x) Return inverse cosine of the argument. double tan(double x) Return tangent of the argument. double atan(double x) Return inverse tangent the argument. int rand32() Return a random 32 bit integer. int rand32(int max) Return a random 32 bit integer in [0, max). int rand32(int min, int max) Return a random 32 bit integer in [min, max). int rand64() Return a random 64 bit integer. int rand64(int max) Return a random 64 bit integer in [0, max). int rand64(int min, int max) Return a random 64 bit integer in [min, max). collect() Put all the collected values to a list. collect_set() Put all the collected values to a set. int size() Return the number of elements in a list. map(fun, iter) Return a map object after applying the given function to each item of a given iterable.","title":"Built-in math functions"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/","text":"Built-in string functions \u00b6 Nebula Graph supports the following built-in string functions: NOTE: Like SQL, the character index (location) for nGQL starts from 1 . However, the character index (i.e. location in a list) for the C language starts from 0 . Function Description int strcasecmp(string a, string b) Compare strings without case sensitivity, when a = b, return 0, when a > b returned value is greater than 0, otherwise less than 0. string lower(string a) Return the argument in lowercase. string upper(string a) Return the argument in uppercase. int length(string a) Return the length (int) of given string in bytes. string trim(string a) Remove leading and trailing spaces. string ltrim(string a) Remove leading spaces. string rtrim(string a) Remove trailing spaces. string left(string a, int count) Return the substring in [1, count], if length a is less than count, return a. string right(string a, int count) Return the substring in [size - count + 1, size], if length a is less than count, return a. string lpad(string a, int size, string letters) Left-pads a string with another string to a certain length. string rpad(string a, int size, string letters) Reft-pads a string with another string to a certain length. string substr(string a, int pos, int count) Extract a substring from a string, starting at the specified position, extract the specified length characters. int hash(string a) Encode the data into an integer value. Explanations on the returns of function substr : If pos is 0, return an empty string. If the absolute value of pos is greater than the string, return an empty string. If pos is greater than 0, return substring in [pos, pos + count). If pos is less than 0, and set position N as length(a) + pos + 1, return substring in [N, N + count). If count is greater than length(a), return the whole string.","title":"String"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#built-in_string_functions","text":"Nebula Graph supports the following built-in string functions: NOTE: Like SQL, the character index (location) for nGQL starts from 1 . However, the character index (i.e. location in a list) for the C language starts from 0 . Function Description int strcasecmp(string a, string b) Compare strings without case sensitivity, when a = b, return 0, when a > b returned value is greater than 0, otherwise less than 0. string lower(string a) Return the argument in lowercase. string upper(string a) Return the argument in uppercase. int length(string a) Return the length (int) of given string in bytes. string trim(string a) Remove leading and trailing spaces. string ltrim(string a) Remove leading spaces. string rtrim(string a) Remove trailing spaces. string left(string a, int count) Return the substring in [1, count], if length a is less than count, return a. string right(string a, int count) Return the substring in [size - count + 1, size], if length a is less than count, return a. string lpad(string a, int size, string letters) Left-pads a string with another string to a certain length. string rpad(string a, int size, string letters) Reft-pads a string with another string to a certain length. string substr(string a, int pos, int count) Extract a substring from a string, starting at the specified position, extract the specified length characters. int hash(string a) Encode the data into an integer value. Explanations on the returns of function substr : If pos is 0, return an empty string. If the absolute value of pos is greater than the string, return an empty string. If pos is greater than 0, return substring in [pos, pos + count). If pos is less than 0, and set position N as length(a) + pos + 1, return substring in [N, N + count). If count is greater than length(a), return the whole string.","title":"Built-in string functions"},{"location":"3.ngql-guide/6.functions-and-expressions/3.date-and-time/","text":"Built-in date and time functions \u00b6 Nebula Graph supports the following built-in date and time functions: Function Description int now() Return the current date and time. date date() Return the current date based on the current system. time time() Return the current calendar time of the current time zone. datetime datetime() Return the current datetime based on the current time. The date(), time(), and datetime() functions accept three kind of parameters, namely empty, string, and map.","title":"Date and time"},{"location":"3.ngql-guide/6.functions-and-expressions/3.date-and-time/#built-in_date_and_time_functions","text":"Nebula Graph supports the following built-in date and time functions: Function Description int now() Return the current date and time. date date() Return the current date based on the current system. time time() Return the current calendar time of the current time zone. datetime datetime() Return the current datetime based on the current time. The date(), time(), and datetime() functions accept three kind of parameters, namely empty, string, and map.","title":"Built-in date and time functions"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/","text":"Built-in schema functions \u00b6 Nebula Graph supports the following built-in schema functions: Function Description id() Return the id of a vertex. tags() Return the tags of a vertex. labels() Return the tags of a vertex. map properties() Return the properties of a vertex or an edge. type() Return the edge types of an edge. string src() Return the source vertex ID of an edge. string dst() Return the destination vertex ID of an edge. int rank() Return the rank value of an edge.","title":"Schema"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#built-in_schema_functions","text":"Nebula Graph supports the following built-in schema functions: Function Description id() Return the id of a vertex. tags() Return the tags of a vertex. labels() Return the tags of a vertex. map properties() Return the properties of a vertex or an edge. type() Return the edge types of an edge. string src() Return the source vertex ID of an edge. string dst() Return the destination vertex ID of an edge. int rank() Return the rank value of an edge.","title":"Built-in schema functions"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/","text":"CASE expressions \u00b6 The CASE expression uses conditions to filter the result of an nGQL query statement. It is usually used in the YIELD or RETURN clause. nGQL provides two forms of CASE expressions just like openCypher: the simple form and the generic form. The CASE expression goes through conditions and returns a result when the first condition is met. Then the CASE expression stops reading the conditions and returns the result. If no conditions are met, it returns the result in the ELSE clause. If there is no ELSE clause and no conditions are met, it returns NULL . The following graph is used for the examples in this topic. The simple form of CASE expressions \u00b6 Syntax \u00b6 CASE <comparer> WHEN <value> THEN <result> [WHEN ...] [ELSE <default>] END CAUTION: Always remember to end a CASE expression with END . Parameters Description comparer A value or a valid expression that outputs a value. This value is used to compare with value . value It will be compared with comparer . If they match, then this condition is met. result It is returned by the CASE expression if value matches comparer . default It is returned by the CASE expression if no conditions are met. Examples \u00b6 Example 1: nebula> YIELD \\ -> CASE 2+3 \\ -> WHEN 4 THEN 0 \\ -> WHEN 5 THEN 1 \\ -> ELSE -1 \\ -> END \\ -> AS result; +--------+ | result | +--------+ | 1 | +--------+ Got 1 rows (time spent 188/583 us) Example 2: nebula> GO FROM \"player100\" OVER follow \\ -> YIELD $$.player.name AS Name, \\ -> CASE $$.player.age > 35 \\ -> WHEN true THEN \"Yes\" \\ -> WHEN false THEN \"No\" \\ -> ELSE \"Nah\" \\ -> END \\ -> AS Age_above_35; +---------------------+--------------+ | Name | Age_above_35 | +---------------------+--------------+ | \"Tony Parker\" | \"Yes\" | +---------------------+--------------+ | \"LaMarcus Aldridge\" | \"No\" | +---------------------+--------------+ Got 2 rows (time spent 3910/4348 us) The generic form of CASE expressions \u00b6 Syntax \u00b6 CASE WHEN <condition> THEN <result> [WHEN ...] [ELSE <default>] END Parameters Description condition If condition is evaluated as true, result is returned by the CASE expression. result It is returned by the CASE expression if condition is evaluated as true. default It is returned by the CASE expression if no conditions are met. Examples \u00b6 Example 1: nebula> YIELD \\ -> CASE WHEN 4 > 5 THEN 0 \\ -> WHEN 3+4==7 THEN 1 \\ -> ELSE 2 \\ -> END \\ -> AS result; +--------+ | result | +--------+ | 1 | +--------+ Got 1 rows (time spent 233/693 us) Example 2: nebula> MATCH (v:player) WHERE v.age > 30 \\ -> RETURN v.name AS Name, \\ -> CASE \\ -> WHEN v.name STARTS WITH \"T\" THEN \"Yes\" \\ -> ELSE \"No\" \\ -> END \\ -> AS Starts_with_T; +---------------------+---------------+ | Name | Starts_with_T | +---------------------+---------------+ | \"Tim\" | \"Yes\" | +---------------------+---------------+ | \"LaMarcus Aldridge\" | \"No\" | +---------------------+---------------+ | \"Tony Parker\" | \"Yes\" | +---------------------+---------------+ Got 3 rows (time spent 3859/4326 us) Differences between the simple form and the generic form \u00b6 To avoid the misuse of the simple form and the generic form, it is important to understand their differences. The following example can help explain them. nebula> GO FROM \"player100\" OVER follow \\ -> YIELD $$.player.name AS Name, $$.player.age AS Age, \\ -> CASE $$.player.age \\ -> WHEN $$.player.age > 35 THEN \"Yes\" \\ -> ELSE \"No\" \\ -> END \\ -> AS Age_above_35; +---------------------+-----+--------------+ | Name | Age | Age_above_35 | +---------------------+-----+--------------+ | \"Tony Parker\" | 36 | \"No\" | +---------------------+-----+--------------+ | \"LaMarcus Aldridge\" | 33 | \"No\" | +---------------------+-----+--------------+ Got 2 rows (time spent 2170/2642 us) The preceding GO query is intended to output \"Yes\" when the player age is above 35. However, in this example, when the player age is 36, the actual output is not as expected: It is \"No\" instead of \"Yes\". This is because the query uses the CASE expression in the simple form, and a comparison between the values of $$.player.age and $$.player.age > 35 is made. When the player age is 36: The value of $$.player.age is 36 . It is an integer. $$.player.age > 35 is evaluated to true . It is a boolean. The values of $$.player.age and $$.player.age > 35 do not match. This condition is not met and \"No\" is returned.","title":"Case expressions"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#case_expressions","text":"The CASE expression uses conditions to filter the result of an nGQL query statement. It is usually used in the YIELD or RETURN clause. nGQL provides two forms of CASE expressions just like openCypher: the simple form and the generic form. The CASE expression goes through conditions and returns a result when the first condition is met. Then the CASE expression stops reading the conditions and returns the result. If no conditions are met, it returns the result in the ELSE clause. If there is no ELSE clause and no conditions are met, it returns NULL . The following graph is used for the examples in this topic.","title":"CASE expressions"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#the_simple_form_of_case_expressions","text":"","title":"The simple form of CASE expressions"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#syntax","text":"CASE <comparer> WHEN <value> THEN <result> [WHEN ...] [ELSE <default>] END CAUTION: Always remember to end a CASE expression with END . Parameters Description comparer A value or a valid expression that outputs a value. This value is used to compare with value . value It will be compared with comparer . If they match, then this condition is met. result It is returned by the CASE expression if value matches comparer . default It is returned by the CASE expression if no conditions are met.","title":"Syntax"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#examples","text":"Example 1: nebula> YIELD \\ -> CASE 2+3 \\ -> WHEN 4 THEN 0 \\ -> WHEN 5 THEN 1 \\ -> ELSE -1 \\ -> END \\ -> AS result; +--------+ | result | +--------+ | 1 | +--------+ Got 1 rows (time spent 188/583 us) Example 2: nebula> GO FROM \"player100\" OVER follow \\ -> YIELD $$.player.name AS Name, \\ -> CASE $$.player.age > 35 \\ -> WHEN true THEN \"Yes\" \\ -> WHEN false THEN \"No\" \\ -> ELSE \"Nah\" \\ -> END \\ -> AS Age_above_35; +---------------------+--------------+ | Name | Age_above_35 | +---------------------+--------------+ | \"Tony Parker\" | \"Yes\" | +---------------------+--------------+ | \"LaMarcus Aldridge\" | \"No\" | +---------------------+--------------+ Got 2 rows (time spent 3910/4348 us)","title":"Examples"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#the_generic_form_of_case_expressions","text":"","title":"The generic form of CASE expressions"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#syntax_1","text":"CASE WHEN <condition> THEN <result> [WHEN ...] [ELSE <default>] END Parameters Description condition If condition is evaluated as true, result is returned by the CASE expression. result It is returned by the CASE expression if condition is evaluated as true. default It is returned by the CASE expression if no conditions are met.","title":"Syntax"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#examples_1","text":"Example 1: nebula> YIELD \\ -> CASE WHEN 4 > 5 THEN 0 \\ -> WHEN 3+4==7 THEN 1 \\ -> ELSE 2 \\ -> END \\ -> AS result; +--------+ | result | +--------+ | 1 | +--------+ Got 1 rows (time spent 233/693 us) Example 2: nebula> MATCH (v:player) WHERE v.age > 30 \\ -> RETURN v.name AS Name, \\ -> CASE \\ -> WHEN v.name STARTS WITH \"T\" THEN \"Yes\" \\ -> ELSE \"No\" \\ -> END \\ -> AS Starts_with_T; +---------------------+---------------+ | Name | Starts_with_T | +---------------------+---------------+ | \"Tim\" | \"Yes\" | +---------------------+---------------+ | \"LaMarcus Aldridge\" | \"No\" | +---------------------+---------------+ | \"Tony Parker\" | \"Yes\" | +---------------------+---------------+ Got 3 rows (time spent 3859/4326 us)","title":"Examples"},{"location":"3.ngql-guide/6.functions-and-expressions/5.case-expressions/#differences_between_the_simple_form_and_the_generic_form","text":"To avoid the misuse of the simple form and the generic form, it is important to understand their differences. The following example can help explain them. nebula> GO FROM \"player100\" OVER follow \\ -> YIELD $$.player.name AS Name, $$.player.age AS Age, \\ -> CASE $$.player.age \\ -> WHEN $$.player.age > 35 THEN \"Yes\" \\ -> ELSE \"No\" \\ -> END \\ -> AS Age_above_35; +---------------------+-----+--------------+ | Name | Age | Age_above_35 | +---------------------+-----+--------------+ | \"Tony Parker\" | 36 | \"No\" | +---------------------+-----+--------------+ | \"LaMarcus Aldridge\" | 33 | \"No\" | +---------------------+-----+--------------+ Got 2 rows (time spent 2170/2642 us) The preceding GO query is intended to output \"Yes\" when the player age is above 35. However, in this example, when the player age is 36, the actual output is not as expected: It is \"No\" instead of \"Yes\". This is because the query uses the CASE expression in the simple form, and a comparison between the values of $$.player.age and $$.player.age > 35 is made. When the player age is 36: The value of $$.player.age is 36 . It is an integer. $$.player.age > 35 is evaluated to true . It is a boolean. The values of $$.player.age and $$.player.age > 35 do not match. This condition is not met and \"No\" is returned.","title":"Differences between the simple form and the generic form"},{"location":"3.ngql-guide/7.general-query-statements/2.match/","text":"MATCH \u00b6 The MATCH statement provides the searching ability based on pattern matching. A MATCH statement defines a search pattern and uses it to match data stored in the Nebula Graph database and to retrieve the data in the form defined in the RETURN clause. A WHERE clause is often used together with the pattern as a filter to the search result. Syntax \u00b6 The syntax of MATCH is relatively more flexible compared with that of other query statements such as GO or LOOKUP . But generally, it can be summarized as follows. MATCH <pattern> [<WHERE clause>] RETURN <output> Patterns and WHERE clauses \u00b6 The MATCH patterns, with the help of curly brackets (\"{}\"), can do the same thing with WHERE clauses when making equality comparisons. You may find an example as follows. NOTE : In nGQL, == is the equality operator and = is the assignment operator (as in C++ or Java). In openCypher 9, = is the equality operator. nebula> MATCH (v:player) WHERE v.name == \"Tim\" RETURN v.age AS Age; +-----+ | Age | +-----+ | 42 | +-----+ Got 1 rows (time spent 2849/3256 us) nebula> MATCH (v:player {name: \"Tim\"}) RETURN v.age AS Age; +-----+ | Age | +-----+ | 42 | +-----+ Got 1 rows (time spent 1924/2673 us) But besides equality comparisons, WHERE clauses can do a lot more than patterns in curly brackets. For more information, see WHERE [TODO]. Match modes \u00b6 Currently, MATCH supports the following modes. Match mode Description Match on property Uses specific properties to match the start vertices, then expand the pattern to match related edges or vertices if needed, and fetch data according to the RETURN statement at last. Match on ID Uses specific vertex IDs to match the start vertices, then expand the pattern to match related edges or vertices if needed, and fetch data according to the RETURN statement at last. Must-read for matching on property \u00b6 The MATCH statement is based on indexes. While parsing a MATCH statement, the Graph Service scans for properties with indexes in the curly brackets and the WHERE clause. Make sure there is at least one property with an Index, otherwise the parsing fails. No such attention is needed when matching on ID because the index for vertex IDs is created by default. Examples for matching on property \u00b6 Example 1: Search for a specific age and return the names of players of that age. The v is a user-defined variable that represents a vertex. nebula> MATCH (v:player {age: 36}) RETURN v.name AS Name; +-------------+ | Name | +-------------+ | Tony Parker | +-------------+ Got 1 rows (time spent 2849/3256 us) Example 2: Search for the players whose ages are above 30 and names start with \"T\", and return their names and ages. Use STARTS WITH or ENDS WITH to filter strings. nebula> MATCH (v:player) WHERE v.age > 30 AND v.name STARTS WITH \"T\" \\ ->RETURN v.name AS Name, v.age AS Age; +-------------+-----+ | Name | Age | +-------------+-----+ | Tony Parker | 36 | +-------------+-----+ | Tim | 42 | +-------------+-----+ Got 2 rows (time spent 2407/3244 us) Example 3: Search for the player whose name is \"Tim\", and return the player's relationships (edges) with others and the names of these people. The r is a user-defined variable that represents an edge. The type(e) function returns to the edge type. nebula> MATCH (v1:player{name: \"Tim\"}) -[e]-> (v2) \\ -> RETURN type(e) AS Relationship, v2.name AS Name; +--------------+-------------------+ | Relationship | Name | +--------------+-------------------+ | follow | Tony Parker | +--------------+-------------------+ | follow | LaMarcus Aldridge | +--------------+-------------------+ | serve | Warriors | +--------------+-------------------+ Got 3 rows (time spent 4844/6660 us) Example 3: Search for the team that \"Tim\" serves, and return the team name, the start year, and the end year. e:serve represents edges with the serve type. nebula> MATCH (v1:player{name: \"Tim\"}) -[e:serve]-> (v2) \\ -> RETURN v2.name AS Team_Name, e.start_year AS Start_Year, e.end_year AS End_Year; +-----------+------------+----------+ | Team_Name | Start_Year | End_Year | +-----------+------------+----------+ | Warriors | 1997 | 2016 | +-----------+------------+----------+ Got 1 rows (time spent 2768/3412 us) Example 4: Search for the player whose name is \"Tim\", find the people that \"Tim\" follows with age above 35 and the teams they serve, and return the names of the people and teams. nebula> MATCH (v1:player) -[:follow]-> (v2) -[:serve]-> (v3) \\ -> WHERE v1.name == \"Tim\" AND v2.age > 35 \\ -> RETURN v1.name AS Player, v2.name AS Friend, v3.name AS Friends_Team; +--------+-------------+--------------+ | Player | Friend | Friends_Team | +--------+-------------+--------------+ | Tim | Tony Parker | Nuggets | +--------+-------------+--------------+ Got 1 rows (time spent 3623/4220 us) Examples for matching on ID \u00b6 Example 1: Search for the vertex with VID \"player100\" and return all its information. NOTE : In nGQL, id() returns a vertex ID that is a string. In openCypher 9, id() returns an integer. ```nGQL nebula> MATCH (v) WHERE id(v) == 'player101' RETURN v; +---------------------------------------------------+ | v | +---------------------------------------------------+ | (player101) player.name:Tony Parker,player.age:36 | +---------------------------------------------------+ Got 1 rows (time spent 1710/2406 us) ``` Example 2: Search for the vertices with VIDs in a specific list and return all their information. A non-existing VID returns nothing. nebula> MATCH (v) WHERE id(v) IN ['player100', 'player101', 'no_one'] RETURN v; +---------------------------------------------------+ | v | +---------------------------------------------------+ | (player101) player.name:Tony Parker,player.age:36 | +---------------------------------------------------+ | (player100) player.name:Tim,player.age:42 | +---------------------------------------------------+ Got 2 rows (time spent 1307/2079 us)","title":"Match"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match","text":"The MATCH statement provides the searching ability based on pattern matching. A MATCH statement defines a search pattern and uses it to match data stored in the Nebula Graph database and to retrieve the data in the form defined in the RETURN clause. A WHERE clause is often used together with the pattern as a filter to the search result.","title":"MATCH"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#syntax","text":"The syntax of MATCH is relatively more flexible compared with that of other query statements such as GO or LOOKUP . But generally, it can be summarized as follows. MATCH <pattern> [<WHERE clause>] RETURN <output>","title":"Syntax"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#patterns_and_where_clauses","text":"The MATCH patterns, with the help of curly brackets (\"{}\"), can do the same thing with WHERE clauses when making equality comparisons. You may find an example as follows. NOTE : In nGQL, == is the equality operator and = is the assignment operator (as in C++ or Java). In openCypher 9, = is the equality operator. nebula> MATCH (v:player) WHERE v.name == \"Tim\" RETURN v.age AS Age; +-----+ | Age | +-----+ | 42 | +-----+ Got 1 rows (time spent 2849/3256 us) nebula> MATCH (v:player {name: \"Tim\"}) RETURN v.age AS Age; +-----+ | Age | +-----+ | 42 | +-----+ Got 1 rows (time spent 1924/2673 us) But besides equality comparisons, WHERE clauses can do a lot more than patterns in curly brackets. For more information, see WHERE [TODO].","title":"Patterns and WHERE clauses"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_modes","text":"Currently, MATCH supports the following modes. Match mode Description Match on property Uses specific properties to match the start vertices, then expand the pattern to match related edges or vertices if needed, and fetch data according to the RETURN statement at last. Match on ID Uses specific vertex IDs to match the start vertices, then expand the pattern to match related edges or vertices if needed, and fetch data according to the RETURN statement at last.","title":"Match modes"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#must-read_for_matching_on_property","text":"The MATCH statement is based on indexes. While parsing a MATCH statement, the Graph Service scans for properties with indexes in the curly brackets and the WHERE clause. Make sure there is at least one property with an Index, otherwise the parsing fails. No such attention is needed when matching on ID because the index for vertex IDs is created by default.","title":"Must-read for matching on property"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#examples_for_matching_on_property","text":"Example 1: Search for a specific age and return the names of players of that age. The v is a user-defined variable that represents a vertex. nebula> MATCH (v:player {age: 36}) RETURN v.name AS Name; +-------------+ | Name | +-------------+ | Tony Parker | +-------------+ Got 1 rows (time spent 2849/3256 us) Example 2: Search for the players whose ages are above 30 and names start with \"T\", and return their names and ages. Use STARTS WITH or ENDS WITH to filter strings. nebula> MATCH (v:player) WHERE v.age > 30 AND v.name STARTS WITH \"T\" \\ ->RETURN v.name AS Name, v.age AS Age; +-------------+-----+ | Name | Age | +-------------+-----+ | Tony Parker | 36 | +-------------+-----+ | Tim | 42 | +-------------+-----+ Got 2 rows (time spent 2407/3244 us) Example 3: Search for the player whose name is \"Tim\", and return the player's relationships (edges) with others and the names of these people. The r is a user-defined variable that represents an edge. The type(e) function returns to the edge type. nebula> MATCH (v1:player{name: \"Tim\"}) -[e]-> (v2) \\ -> RETURN type(e) AS Relationship, v2.name AS Name; +--------------+-------------------+ | Relationship | Name | +--------------+-------------------+ | follow | Tony Parker | +--------------+-------------------+ | follow | LaMarcus Aldridge | +--------------+-------------------+ | serve | Warriors | +--------------+-------------------+ Got 3 rows (time spent 4844/6660 us) Example 3: Search for the team that \"Tim\" serves, and return the team name, the start year, and the end year. e:serve represents edges with the serve type. nebula> MATCH (v1:player{name: \"Tim\"}) -[e:serve]-> (v2) \\ -> RETURN v2.name AS Team_Name, e.start_year AS Start_Year, e.end_year AS End_Year; +-----------+------------+----------+ | Team_Name | Start_Year | End_Year | +-----------+------------+----------+ | Warriors | 1997 | 2016 | +-----------+------------+----------+ Got 1 rows (time spent 2768/3412 us) Example 4: Search for the player whose name is \"Tim\", find the people that \"Tim\" follows with age above 35 and the teams they serve, and return the names of the people and teams. nebula> MATCH (v1:player) -[:follow]-> (v2) -[:serve]-> (v3) \\ -> WHERE v1.name == \"Tim\" AND v2.age > 35 \\ -> RETURN v1.name AS Player, v2.name AS Friend, v3.name AS Friends_Team; +--------+-------------+--------------+ | Player | Friend | Friends_Team | +--------+-------------+--------------+ | Tim | Tony Parker | Nuggets | +--------+-------------+--------------+ Got 1 rows (time spent 3623/4220 us)","title":"Examples for matching on property"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#examples_for_matching_on_id","text":"Example 1: Search for the vertex with VID \"player100\" and return all its information. NOTE : In nGQL, id() returns a vertex ID that is a string. In openCypher 9, id() returns an integer. ```nGQL nebula> MATCH (v) WHERE id(v) == 'player101' RETURN v; +---------------------------------------------------+ | v | +---------------------------------------------------+ | (player101) player.name:Tony Parker,player.age:36 | +---------------------------------------------------+ Got 1 rows (time spent 1710/2406 us) ``` Example 2: Search for the vertices with VIDs in a specific list and return all their information. A non-existing VID returns nothing. nebula> MATCH (v) WHERE id(v) IN ['player100', 'player101', 'no_one'] RETURN v; +---------------------------------------------------+ | v | +---------------------------------------------------+ | (player101) player.name:Tony Parker,player.age:36 | +---------------------------------------------------+ | (player100) player.name:Tim,player.age:42 | +---------------------------------------------------+ Got 2 rows (time spent 1307/2079 us)","title":"Examples for matching on ID"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/","text":"CREATE SPACE \u00b6 CREATE SPACE [IF NOT EXISTS] <graph_space_name> [(partition_num = <partition_number>, replica_factor = <replica_number>, charset = <charset>, collate = <collate>, vid_type = FIXED_STRING(<max_string_length>))] The CREATE SPACE statement creates a new graph space with the given name. A SPACE is a region that provides physically isolated graphs in Nebula Graph. An error occurs if a graph space with the same name exists if you did not specify IF NOT EXISTS . IF NOT EXISTS \u00b6 You can use the IF NOT EXISTS keywords when creating graph spaces. These keywords automatically detects if the related graph space exists. If it does not exist, a new one is created. Otherwise, no graph space is created. NOTE : The graph space existence detection here only compares the graph space name (excluding properties). Graph space name \u00b6 The graph_space_name uniquely identifies a graph space in a Nebula Graph instance. Customized graph space options \u00b6 You can set four optional options for a new graph space: partition_num Specifies the number of partitions in each replica. The suggested number is five times the number of the hard disks in the cluster. For example, if you have 3 hard disks in the cluster, we recommend that you set 15 partitions. replica_factor Specifies the number of replicas in the cluster. The default replica factor is 1. The suggested number is 3 in a production environment and 1 in a test environment. Always set the replica to an odd number for the need of quorum-based voting. charset Short for character set. A character set is a set of symbols and encodings. The default value is utf8 . collate A set of rules for comparing characters in a character set. The default value is utf8_bin . vid_type Specifies the data type of vertex IDs (VIDs) in a graph space. In Nebula Graph 2.0.0-alpha, only fixed_string(N) is valid, indicating VIDs must be string type. N represents the maximum length of the VIDs. You must set the fixed_string to a positive integer. The default value is 8. If your VID length is greater than the maximum VID length, Nebula Graph throws an error. If no option is given, Nebula Graph creates the graph space with the default options. Example \u00b6 nebula> CREATE SPACE my_space_1; -- create a graph space with default options nebula> CREATE SPACE my_space_2(partition_num=10); -- create a graph space with customized partition number nebula> CREATE SPACE my_space_3(replica_factor=1); -- create a graph space with customized replica factor nebula> CREATE SPACE my_space_4(vid_type = FIXED_STRING(30)); -- create a graph space with customized VID maximum length Check partition distribution \u00b6 On some large clusters, the partition distribution is possibly unbalanced because of the different startup time. You can run the command to do a check of the machine distribution. nebula> SHOW HOSTS; +-----------+-------+--------+--------------+---------------------+------------------------+ | Host | Port | Status | Leader count | Leader distribution | Partition distribution | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged0 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged1 | 44500 | ONLINE | 2 | test:1, nba:5 | nba:5, test:1 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged2 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ To balance the request loads, use the following command. nebula> BALANCE LEADER;","title":"CREATE SPACE"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/#create_space","text":"CREATE SPACE [IF NOT EXISTS] <graph_space_name> [(partition_num = <partition_number>, replica_factor = <replica_number>, charset = <charset>, collate = <collate>, vid_type = FIXED_STRING(<max_string_length>))] The CREATE SPACE statement creates a new graph space with the given name. A SPACE is a region that provides physically isolated graphs in Nebula Graph. An error occurs if a graph space with the same name exists if you did not specify IF NOT EXISTS .","title":"CREATE SPACE"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/#if_not_exists","text":"You can use the IF NOT EXISTS keywords when creating graph spaces. These keywords automatically detects if the related graph space exists. If it does not exist, a new one is created. Otherwise, no graph space is created. NOTE : The graph space existence detection here only compares the graph space name (excluding properties).","title":"IF NOT EXISTS"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/#graph_space_name","text":"The graph_space_name uniquely identifies a graph space in a Nebula Graph instance.","title":"Graph space name"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/#customized_graph_space_options","text":"You can set four optional options for a new graph space: partition_num Specifies the number of partitions in each replica. The suggested number is five times the number of the hard disks in the cluster. For example, if you have 3 hard disks in the cluster, we recommend that you set 15 partitions. replica_factor Specifies the number of replicas in the cluster. The default replica factor is 1. The suggested number is 3 in a production environment and 1 in a test environment. Always set the replica to an odd number for the need of quorum-based voting. charset Short for character set. A character set is a set of symbols and encodings. The default value is utf8 . collate A set of rules for comparing characters in a character set. The default value is utf8_bin . vid_type Specifies the data type of vertex IDs (VIDs) in a graph space. In Nebula Graph 2.0.0-alpha, only fixed_string(N) is valid, indicating VIDs must be string type. N represents the maximum length of the VIDs. You must set the fixed_string to a positive integer. The default value is 8. If your VID length is greater than the maximum VID length, Nebula Graph throws an error. If no option is given, Nebula Graph creates the graph space with the default options.","title":"Customized graph space options"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/#example","text":"nebula> CREATE SPACE my_space_1; -- create a graph space with default options nebula> CREATE SPACE my_space_2(partition_num=10); -- create a graph space with customized partition number nebula> CREATE SPACE my_space_3(replica_factor=1); -- create a graph space with customized replica factor nebula> CREATE SPACE my_space_4(vid_type = FIXED_STRING(30)); -- create a graph space with customized VID maximum length","title":"Example"},{"location":"3.ngql-guide/9.space-statements.md/1.create-space/#check_partition_distribution","text":"On some large clusters, the partition distribution is possibly unbalanced because of the different startup time. You can run the command to do a check of the machine distribution. nebula> SHOW HOSTS; +-----------+-------+--------+--------------+---------------------+------------------------+ | Host | Port | Status | Leader count | Leader distribution | Partition distribution | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged0 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged1 | 44500 | ONLINE | 2 | test:1, nba:5 | nba:5, test:1 | +-----------+-------+--------+--------------+---------------------+------------------------+ | storaged2 | 44500 | ONLINE | 1 | nba:5 | nba:5 | +-----------+-------+--------+--------------+---------------------+------------------------+ To balance the request loads, use the following command. nebula> BALANCE LEADER;","title":"Check partition distribution"},{"location":"3.ngql-guide/9.space-statements.md/2.use-space/","text":"USE \u00b6 USE <graph_space_name> The USE statement specifies a graph space as the current working space for subsequent queries. To manage multiple graph spaces, use the USE statement. The USE statement requires some privileges. (TODO: authentication doc) The graph space remains the same unless another USE statement is executed. nebula> USE space1; -- Traverse in graph space1. nebula> GO FROM 1 OVER edge1; nebula> USE space2; -- Traverse in graph space2. These vertices and edges have no relevance with space1. nebula> GO FROM 2 OVER edge2; -- Now you are back to space1. Hereafter, you can not read any data from space2. nebula> USE space1; Different from SQL, making a graph space as the working graph space prevents you from accessing other spaces. The only way to traverse in a new graph space is to switch by the USE statement. Graph spaces are FULLY ISOLATED from each other. Unlike MySQL, you can only use one graph space at a time in Nebula Graph. But in MySQL, you can select two tables from different databases in one statement.","title":"USE SPACE"},{"location":"3.ngql-guide/9.space-statements.md/2.use-space/#use","text":"USE <graph_space_name> The USE statement specifies a graph space as the current working space for subsequent queries. To manage multiple graph spaces, use the USE statement. The USE statement requires some privileges. (TODO: authentication doc) The graph space remains the same unless another USE statement is executed. nebula> USE space1; -- Traverse in graph space1. nebula> GO FROM 1 OVER edge1; nebula> USE space2; -- Traverse in graph space2. These vertices and edges have no relevance with space1. nebula> GO FROM 2 OVER edge2; -- Now you are back to space1. Hereafter, you can not read any data from space2. nebula> USE space1; Different from SQL, making a graph space as the working graph space prevents you from accessing other spaces. The only way to traverse in a new graph space is to switch by the USE statement. Graph spaces are FULLY ISOLATED from each other. Unlike MySQL, you can only use one graph space at a time in Nebula Graph. But in MySQL, you can select two tables from different databases in one statement.","title":"USE"},{"location":"3.ngql-guide/9.space-statements.md/3.show-spaces/","text":"SHOW SPACES \u00b6 SHOW SPACES The SHOW SPACES statement lists the all the graph spaces in a Nebula Graph instance. For example: nebula> SHOW SPACES; +--------+ | Name | +--------+ | \"nba\" | +--------+ To create graph spaces, see Create Space document .","title":"SHOW SPACES"},{"location":"3.ngql-guide/9.space-statements.md/3.show-spaces/#show_spaces","text":"SHOW SPACES The SHOW SPACES statement lists the all the graph spaces in a Nebula Graph instance. For example: nebula> SHOW SPACES; +--------+ | Name | +--------+ | \"nba\" | +--------+ To create graph spaces, see Create Space document .","title":"SHOW SPACES"},{"location":"3.ngql-guide/9.space-statements.md/4.describe-space/","text":"DESCRIBE SPACE \u00b6 DESC[RIBE] SPACE <graph_space_name> The DESCRIBE SPACE statement returns information about a graph space. The DESCRIBE SPACE statement is different from the SHOW SPACES statement. For details about SHOW SPACES , see SHOW SPACES document . You can use DESC instead of DESCRIBE for short. Example \u00b6 Get information about a graph space. nebula> DESCRIBE SPACE nba; +----+-------+------------------+----------------+---------+------------+--------------------+ | ID | Name | Partition Number | Replica Factor | Charset | Collate | Vid Type | +----+-------+------------------+----------------+---------+------------+--------------------+ | 8 | \"nba\" | 15 | 1 | \"utf8\" | \"utf8_bin\" | \"FIXED_STRING(30)\" | +----+-------+------------------+----------------+---------+------------+--------------------+","title":"DESCRIBE SPACE"},{"location":"3.ngql-guide/9.space-statements.md/4.describe-space/#describe_space","text":"DESC[RIBE] SPACE <graph_space_name> The DESCRIBE SPACE statement returns information about a graph space. The DESCRIBE SPACE statement is different from the SHOW SPACES statement. For details about SHOW SPACES , see SHOW SPACES document . You can use DESC instead of DESCRIBE for short.","title":"DESCRIBE SPACE"},{"location":"3.ngql-guide/9.space-statements.md/4.describe-space/#example","text":"Get information about a graph space. nebula> DESCRIBE SPACE nba; +----+-------+------------------+----------------+---------+------------+--------------------+ | ID | Name | Partition Number | Replica Factor | Charset | Collate | Vid Type | +----+-------+------------------+----------------+---------+------------+--------------------+ | 8 | \"nba\" | 15 | 1 | \"utf8\" | \"utf8_bin\" | \"FIXED_STRING(30)\" | +----+-------+------------------+----------------+---------+------------+--------------------+","title":"Example"},{"location":"3.ngql-guide/9.space-statements.md/5.drop-space/","text":"DROP SPACE \u00b6 DROP SPACE [IF EXISTS] <graph_space_name> The DROP SPACE statement deletes everything in the related graph space. You must have the DROP privilege for the related graph space.(TODO: authentication doc) You can use the IF EXISTS keywords when dropping spaces. These keywords automatically detects if the related graph space exists. If it exists, it is deleted. Otherwise, no graph space is deleted. Other graph spaces stay unchanged. The DROP SPACE statement does not immediately remove all the files and directories in the storage engine (and release disk space). The deletion depends on the implementation of different storage engines. NOTE: Be very careful with this statement.","title":"DROP SPACE"},{"location":"3.ngql-guide/9.space-statements.md/5.drop-space/#drop_space","text":"DROP SPACE [IF EXISTS] <graph_space_name> The DROP SPACE statement deletes everything in the related graph space. You must have the DROP privilege for the related graph space.(TODO: authentication doc) You can use the IF EXISTS keywords when dropping spaces. These keywords automatically detects if the related graph space exists. If it exists, it is deleted. Otherwise, no graph space is deleted. Other graph spaces stay unchanged. The DROP SPACE statement does not immediately remove all the files and directories in the storage engine (and release disk space). The deletion depends on the implementation of different storage engines. NOTE: Be very careful with this statement.","title":"DROP SPACE"},{"location":"4.deployment-and-installation/1.resource-preparations/","text":"Prepare resources for compiling, installing, and running Nebula Graph \u00b6 This topic describes the requirements and suggestions for compiling and installing Nebula Graph, as well as how to estimate the resource you need to reserve for running a Nebula Graph cluster. Reading guide \u00b6 If you are reading this topic with the questions listed below, click them to jump to their answers. What do I need to compile Nebula Graph? What do I need to run Nebula Graph in a test environment? What do I need to run Nebula Graph in a production environment? How much memory and disk space do I need to reserve for my Nebula Graph cluster? How to optimize the configuration for HDD and Gigabit Networks? Requirements for compiling the Nebula Graph source code \u00b6 Hardware requirements for compiling Nebula Graph \u00b6 Item Requirement CPU architecture x86_64 Memory 4 GB Disk 10 GB, SSD Supported operating systems for compiling Nebula Graph \u00b6 For now, we can only compile Nebula Graph in the Linux system. We recommend that you use any Linux system with kernel version 2.6.32 or above. Software requirements for compiling Nebula Graph \u00b6 You must have the correct version of the software listed below to compile Nebula Graph. If they are not as required or you are not sure, follow the steps in Prepare software for compiling Nebula Graph to get them ready. Software Version Note glibc 2.12 or above You can run ldd --version to check the glibc version. make Any stable version - m4 Any stable version - git Any stable version - wget Any stable version - unzip Any stable version - xz Any stable version - readline-devel Any stable version - ncurses-devel Any stable version - zlid-devel Any stable version - gcc 7.1.0 or above You can run gcc -v to check the gcc version. gcc-c++ Any stable version - cmake 3.5.0 or above You can run cmake --version to check the cmake version. gettext Any stable version - curl Any stable version - redhat-lsb-core Any stable version - libstdc++-static Any stable version Only needed in CentOS 8+, RedHat 8+, and Fedora systems. libasan Any stable version Only needed in CentOS 8+, RedHat 8+, and Fedora systems. Other third-party software will be automatically downloaded and installed to the build directory at the configure (cmake) stage. Prepare software for compiling Nebula Graph \u00b6 This section guides you through the downloading and installation of software required for compiling Nebula Graph. Install dependencies. For CentOS, RedHat, and Fedora users, run the following commands. ```bash $ yum update $ yum install -y make \\ m4 \\ git \\ wget \\ unzip \\ xz \\ readline-devel \\ ncurses-devel \\ zlib-devel \\ gcc \\ gcc-c++ \\ cmake \\ gettext \\ curl \\ redhat-lsb-core # For CentOS 8+, RedHat 8+, and Fedora, install libstdc++-static, libasan as well $ yum install -y libstdc++-static libasan ``` For Debian and Ubuntu users, run the following commands. ```bash $ apt-get update $ apt-get install -y make \\ m4 \\ git \\ wget \\ unzip \\ xz-utils \\ curl \\ lsb-core \\ build-essential \\ libreadline-dev \\ ncurses-dev \\ cmake \\ gettext ``` Check if the GCC and cmake on your host are in the right version. See Software requirements for compiling Nebula Graph for the required versions. $ g++ --version $ cmake --version If your GCC and cmake are in the right version, then you are all set. If they are not, follow the sub-steps as follows. 1. Clone the nebula-common repository to your host. ```bash $ git clone https://github.com/vesoft-inc/nebula-common.git ``` The source code of Nebula Graph versions like 2.0 alpha or 2.0 beta is stored in particular branches. You can use the `--branch` or `-b` option to specify the branch to be cloned. For example, for 2.0 alpha, run the following command. ```bash $ git clone --branch v2.0.0-alpha https://github.com/vesoft-inc/nebula-common.git ``` 2. Make nebula-common the current working directory. ```bash $ cd nebula-common ``` 3. Run the following commands to install and enable CMake and GCC. ```bash # Install CMake. $ ./third-party/install-cmake.sh cmake-install CMake has been installed to prefix=cmake-install Run 'source cmake-install/bin/enable-cmake.sh' to make it ready to use. Run 'source cmake-install/bin/disable-cmake.sh' to disable it. # Enable CMake $ source cmake-install/bin/enable-cmake.sh # Install GCC. Installing GCC to /opt requires root privilege, you can change it to other locations. $ ./third-party/install-gcc.sh --prefix=/opt GCC-7.5.0 has been installed to /opt/vesoft/toolset/gcc/7.5.0 Performing usability tests Performing regular C++14 tests...OK Performing LeakSanitizer tests...OK Run 'source /opt/vesoft/toolset/gcc/7.5.0/enable' to start using. Run 'source /opt/vesoft/toolset/gcc/7.5.0/disable' to stop using. #Enable GCC. Please note that the path and specific version might be different from your environment. $ source /opt/vesoft/toolset/gcc/7.5.0/enable ``` Requirements and suggestions for installing Nebula Graph in test environments \u00b6 Hardware requirements for test environments \u00b6 Item Requirement CPU architecture x86_64 Number of CPU core 4 Memory 8 GB Disk 100 GB, SSD Supported operating systems for test environments \u00b6 For now, we can only install Nebula Graph in the Linux system. To install Nebula Graph in a test environment, we recommend that you use any Linux system with kernel version 3.9 or above. You can adjust some of the kernel parameters to better accommodate the need for running Nebula Graph. For more information, see Optimize Linux kernel configuration [TODO]. Suggested service architecture for test environments \u00b6 Process Suggested number metad (the metadata service process) 1 storaged (the storage service process) 1 or more graphd (the query engine service process) 1 or more For example, for a single-machine environment, you can deploy 1 metad, 1 storaged, and 1 graphd processes in the machine. For a more common environment, such as a cluster of 3 machines (named as A, B, and C), you can deploy Nebula Graph as follows: Machine name Number of metad Number of storaged Number of graphd A 1 1 1 B None 1 1 C None 1 1 Requirements and suggestions for installing Nebula Graph in production environments \u00b6 Hardware requirements for production environments \u00b6 Item Requirement CPU architecture x86_64 Number of CPU core 48 Memory 96 GB Disk 2 * 900 GB, NVMe SSD Supported operating systems for production environments \u00b6 For now, we can only install Nebula Graph in the Linux system. To install Nebula Graph in a production environment, we recommend that you use any Linux system with kernel version 3.9 or above. You can adjust some of the kernel parameters to better accommodate the need for running Nebula Graph. For more information, see Optimize Linux kernel configuration [TODO]. Suggested service architecture for production environments \u00b6 Process Suggested number metad (the metadata service process) 3 storaged (the storage service process) 3 or more graphd (the query engine service process) 3 or more Each metad process automatically creates and maintains a copy of the metadata. Usually, you only need 3 metad processes. The number of storaged processes does not affect the number of graph space copies. You can deploy multiple processes on a single machine. For example, on a cluster of 5 machines (named as A, B, C, D, and E), you can deploy Nebula Graph as follows: WARNING : Do not deploy a cluster across IDCs. Machine name Number of metad Number of storaged Number of graphd A 1 1 1 B 1 1 1 C 1 1 1 D None 1 1 E None 1 1 Capacity requirements for running a Nebula Graph cluster \u00b6 You can estimate the memory, disk space, and partition number needed for a Nebula Graph cluster of 3 replicas as follows. Resource Unit How to estimate Disk space for a cluster Bytes * * 6 * 120% Memory for a cluster Bytes [ * 15 + * ( * ) + ] * 120% Number of partitions for a graph space - * Question 1: Why do we multiply the disk space and memory by 120%? Answer: The extra 20% is for buffer. Question 2: How to get the number of RocksDB instances? Answer: Each directory in the --data_path item in the etc/nebula-storaged.conf file corresponds to a RocksDB instance. Count the number of directories to get the RocksDB instance number. NOTE : You can decrease the memory size occupied by the bloom filter by adding --enable_partitioned_index_filter=true in etc/nebula-storaged.conf . But it may decrease the read performance in some random-seek cases. Question 3: What is the disk_partition_num_multiplier ? Answer: disk_partition_num_multiplier is a value between 2 to 10, the better performance of the hard disk, the larger the value. Use 2 for HDD. Optimize the configuration for HDD \u00b6 [This part might be moved to the configuration doc map later.] Nebula Graph is intended for NVMe SSD, but if you don't have a choice, optimizing the configuration as follows may better accommodate HDD. etc/nebula-storage.conf: --raft_rpc_timeout_ms = 5000 ~ 10000 --rocksdb_batch_size = 4096 ~ 16384 --heartbeat_interval_secs = 30 ~ 60 --raft_heartbeat_interval_secs = 30 ~ 60 etc/nebula-meta.conf: --heartbeat_interval_secs is the same as etc/nebula-storage.conf Spark Writer: rate: { timeout: 5000 to 10000 } go-importer: batchSize : 10 to 50 concurrency : 1 to 10 channelBufferSize : 100 to 500","title":"Resource preparations"},{"location":"4.deployment-and-installation/1.resource-preparations/#prepare_resources_for_compiling_installing_and_running_nebula_graph","text":"This topic describes the requirements and suggestions for compiling and installing Nebula Graph, as well as how to estimate the resource you need to reserve for running a Nebula Graph cluster.","title":"Prepare resources for compiling, installing, and running Nebula Graph"},{"location":"4.deployment-and-installation/1.resource-preparations/#reading_guide","text":"If you are reading this topic with the questions listed below, click them to jump to their answers. What do I need to compile Nebula Graph? What do I need to run Nebula Graph in a test environment? What do I need to run Nebula Graph in a production environment? How much memory and disk space do I need to reserve for my Nebula Graph cluster? How to optimize the configuration for HDD and Gigabit Networks?","title":"Reading guide"},{"location":"4.deployment-and-installation/1.resource-preparations/#requirements_for_compiling_the_nebula_graph_source_code","text":"","title":"Requirements for compiling the Nebula Graph source code"},{"location":"4.deployment-and-installation/1.resource-preparations/#hardware_requirements_for_compiling_nebula_graph","text":"Item Requirement CPU architecture x86_64 Memory 4 GB Disk 10 GB, SSD","title":"Hardware requirements for compiling Nebula Graph"},{"location":"4.deployment-and-installation/1.resource-preparations/#supported_operating_systems_for_compiling_nebula_graph","text":"For now, we can only compile Nebula Graph in the Linux system. We recommend that you use any Linux system with kernel version 2.6.32 or above.","title":"Supported operating systems for compiling Nebula Graph"},{"location":"4.deployment-and-installation/1.resource-preparations/#software_requirements_for_compiling_nebula_graph","text":"You must have the correct version of the software listed below to compile Nebula Graph. If they are not as required or you are not sure, follow the steps in Prepare software for compiling Nebula Graph to get them ready. Software Version Note glibc 2.12 or above You can run ldd --version to check the glibc version. make Any stable version - m4 Any stable version - git Any stable version - wget Any stable version - unzip Any stable version - xz Any stable version - readline-devel Any stable version - ncurses-devel Any stable version - zlid-devel Any stable version - gcc 7.1.0 or above You can run gcc -v to check the gcc version. gcc-c++ Any stable version - cmake 3.5.0 or above You can run cmake --version to check the cmake version. gettext Any stable version - curl Any stable version - redhat-lsb-core Any stable version - libstdc++-static Any stable version Only needed in CentOS 8+, RedHat 8+, and Fedora systems. libasan Any stable version Only needed in CentOS 8+, RedHat 8+, and Fedora systems. Other third-party software will be automatically downloaded and installed to the build directory at the configure (cmake) stage.","title":"Software requirements for compiling Nebula Graph"},{"location":"4.deployment-and-installation/1.resource-preparations/#prepare_software_for_compiling_nebula_graph","text":"This section guides you through the downloading and installation of software required for compiling Nebula Graph. Install dependencies. For CentOS, RedHat, and Fedora users, run the following commands. ```bash $ yum update $ yum install -y make \\ m4 \\ git \\ wget \\ unzip \\ xz \\ readline-devel \\ ncurses-devel \\ zlib-devel \\ gcc \\ gcc-c++ \\ cmake \\ gettext \\ curl \\ redhat-lsb-core # For CentOS 8+, RedHat 8+, and Fedora, install libstdc++-static, libasan as well $ yum install -y libstdc++-static libasan ``` For Debian and Ubuntu users, run the following commands. ```bash $ apt-get update $ apt-get install -y make \\ m4 \\ git \\ wget \\ unzip \\ xz-utils \\ curl \\ lsb-core \\ build-essential \\ libreadline-dev \\ ncurses-dev \\ cmake \\ gettext ``` Check if the GCC and cmake on your host are in the right version. See Software requirements for compiling Nebula Graph for the required versions. $ g++ --version $ cmake --version If your GCC and cmake are in the right version, then you are all set. If they are not, follow the sub-steps as follows. 1. Clone the nebula-common repository to your host. ```bash $ git clone https://github.com/vesoft-inc/nebula-common.git ``` The source code of Nebula Graph versions like 2.0 alpha or 2.0 beta is stored in particular branches. You can use the `--branch` or `-b` option to specify the branch to be cloned. For example, for 2.0 alpha, run the following command. ```bash $ git clone --branch v2.0.0-alpha https://github.com/vesoft-inc/nebula-common.git ``` 2. Make nebula-common the current working directory. ```bash $ cd nebula-common ``` 3. Run the following commands to install and enable CMake and GCC. ```bash # Install CMake. $ ./third-party/install-cmake.sh cmake-install CMake has been installed to prefix=cmake-install Run 'source cmake-install/bin/enable-cmake.sh' to make it ready to use. Run 'source cmake-install/bin/disable-cmake.sh' to disable it. # Enable CMake $ source cmake-install/bin/enable-cmake.sh # Install GCC. Installing GCC to /opt requires root privilege, you can change it to other locations. $ ./third-party/install-gcc.sh --prefix=/opt GCC-7.5.0 has been installed to /opt/vesoft/toolset/gcc/7.5.0 Performing usability tests Performing regular C++14 tests...OK Performing LeakSanitizer tests...OK Run 'source /opt/vesoft/toolset/gcc/7.5.0/enable' to start using. Run 'source /opt/vesoft/toolset/gcc/7.5.0/disable' to stop using. #Enable GCC. Please note that the path and specific version might be different from your environment. $ source /opt/vesoft/toolset/gcc/7.5.0/enable ```","title":"Prepare software for compiling Nebula Graph"},{"location":"4.deployment-and-installation/1.resource-preparations/#requirements_and_suggestions_for_installing_nebula_graph_in_test_environments","text":"","title":"Requirements and suggestions for installing Nebula Graph in test environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#hardware_requirements_for_test_environments","text":"Item Requirement CPU architecture x86_64 Number of CPU core 4 Memory 8 GB Disk 100 GB, SSD","title":"Hardware requirements for test environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#supported_operating_systems_for_test_environments","text":"For now, we can only install Nebula Graph in the Linux system. To install Nebula Graph in a test environment, we recommend that you use any Linux system with kernel version 3.9 or above. You can adjust some of the kernel parameters to better accommodate the need for running Nebula Graph. For more information, see Optimize Linux kernel configuration [TODO].","title":"Supported operating systems for test environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#suggested_service_architecture_for_test_environments","text":"Process Suggested number metad (the metadata service process) 1 storaged (the storage service process) 1 or more graphd (the query engine service process) 1 or more For example, for a single-machine environment, you can deploy 1 metad, 1 storaged, and 1 graphd processes in the machine. For a more common environment, such as a cluster of 3 machines (named as A, B, and C), you can deploy Nebula Graph as follows: Machine name Number of metad Number of storaged Number of graphd A 1 1 1 B None 1 1 C None 1 1","title":"Suggested service architecture for test environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#requirements_and_suggestions_for_installing_nebula_graph_in_production_environments","text":"","title":"Requirements and suggestions for installing Nebula Graph in production environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#hardware_requirements_for_production_environments","text":"Item Requirement CPU architecture x86_64 Number of CPU core 48 Memory 96 GB Disk 2 * 900 GB, NVMe SSD","title":"Hardware requirements for production environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#supported_operating_systems_for_production_environments","text":"For now, we can only install Nebula Graph in the Linux system. To install Nebula Graph in a production environment, we recommend that you use any Linux system with kernel version 3.9 or above. You can adjust some of the kernel parameters to better accommodate the need for running Nebula Graph. For more information, see Optimize Linux kernel configuration [TODO].","title":"Supported operating systems for production environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#suggested_service_architecture_for_production_environments","text":"Process Suggested number metad (the metadata service process) 3 storaged (the storage service process) 3 or more graphd (the query engine service process) 3 or more Each metad process automatically creates and maintains a copy of the metadata. Usually, you only need 3 metad processes. The number of storaged processes does not affect the number of graph space copies. You can deploy multiple processes on a single machine. For example, on a cluster of 5 machines (named as A, B, C, D, and E), you can deploy Nebula Graph as follows: WARNING : Do not deploy a cluster across IDCs. Machine name Number of metad Number of storaged Number of graphd A 1 1 1 B 1 1 1 C 1 1 1 D None 1 1 E None 1 1","title":"Suggested service architecture for production environments"},{"location":"4.deployment-and-installation/1.resource-preparations/#capacity_requirements_for_running_a_nebula_graph_cluster","text":"You can estimate the memory, disk space, and partition number needed for a Nebula Graph cluster of 3 replicas as follows. Resource Unit How to estimate Disk space for a cluster Bytes * * 6 * 120% Memory for a cluster Bytes [ * 15 + * ( * ) + ] * 120% Number of partitions for a graph space - * Question 1: Why do we multiply the disk space and memory by 120%? Answer: The extra 20% is for buffer. Question 2: How to get the number of RocksDB instances? Answer: Each directory in the --data_path item in the etc/nebula-storaged.conf file corresponds to a RocksDB instance. Count the number of directories to get the RocksDB instance number. NOTE : You can decrease the memory size occupied by the bloom filter by adding --enable_partitioned_index_filter=true in etc/nebula-storaged.conf . But it may decrease the read performance in some random-seek cases. Question 3: What is the disk_partition_num_multiplier ? Answer: disk_partition_num_multiplier is a value between 2 to 10, the better performance of the hard disk, the larger the value. Use 2 for HDD.","title":"Capacity requirements for running a Nebula Graph cluster"},{"location":"4.deployment-and-installation/1.resource-preparations/#optimize_the_configuration_for_hdd","text":"[This part might be moved to the configuration doc map later.] Nebula Graph is intended for NVMe SSD, but if you don't have a choice, optimizing the configuration as follows may better accommodate HDD. etc/nebula-storage.conf: --raft_rpc_timeout_ms = 5000 ~ 10000 --rocksdb_batch_size = 4096 ~ 16384 --heartbeat_interval_secs = 30 ~ 60 --raft_heartbeat_interval_secs = 30 ~ 60 etc/nebula-meta.conf: --heartbeat_interval_secs is the same as etc/nebula-storage.conf Spark Writer: rate: { timeout: 5000 to 10000 } go-importer: batchSize : 10 to 50 concurrency : 1 to 10 channelBufferSize : 100 to 500","title":"Optimize the configuration for HDD"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/","text":"Install Nebula Graph by compiling the source code \u00b6 Installing Nebula Graph from the source code allows you to customize the compiling and installation settings and test the latest features. Prerequisites \u00b6 You have prepared the necessary resources described in Prepare resources for compiling, installing, and running Nebula Graph . You can access the Internet from the host you plan to install Nebula Graph. How to install \u00b6 Use Git to clone the source code of Nebula Graph to your host. * To install the latest version of Nebula Graph 2.x, run the following command to download the source code from the master branch. ```bash $ git clone https://github.com/vesoft-inc/nebula-graph.git ``` * To install a specific version of Nebula Graph 2.x, use the --branch <branch_name> option to specify the correct branch. For example, to install 2.0.0 beta, run the following command. ```bash $ git clone --branch v2.0.0-beta https://github.com/vesoft-inc/nebula-graph.git ``` Make the nebula-graph directory the current working directory. $ cd nebula-graph Create a build directory and make it the current working directory. $ mkdir build && cd build Generate the Makefile with CMake. NOTE : The installation path is /user/local/nebula by default. To customize it, add the -DCMAKE_INSTALL_PREFIX=/your/install/path/ CMake variable in the following command. For more information about CMake variables, see CMake variables . If you are installing the latest version of Nebula Graph 2.x and has cloned the master branch in step 1, run the following command. ```bash $ cmake -DENABLE_BUILD_STORAGE=on -DENABLE_TESTING=OFF -DCMAKE_BUILD_TYPE=Release .. ``` If you are installing a specific version of Nebula Graph 2.x and has cloned the corresponding branch in step 1, use the -DNEBULA_COMMON_REPO_TAG and -DNEBULA_STORAGE_REPO_TAG options to specify the correct branches of the nebula-common and nebula-storage repositories. For example, to install 2.0.0 beta, run the following command. ```bash $ cmake -DENABLE_BUILD_STORAGE=on -DENABLE_TESTING=OFF -DCMAKE_BUILD_TYPE=Release \\ --DNEBULA_COMMON_REPO_TAG=v2.0.0-beta -DNEBULA_STORAGE_REPO_TAG=v2.0.0-beta .. ``` Compile Nebula Graph. Assuming cores is the number of CPU cores and mem_gb is the memory size (in GB), to appropriately speed up the compiling, you can use the value of the smaller one between cores and mem_gb/2 as the value of N in the following command. $ make -j { N } Install Nebula Graph. $ make install-all CMake variables \u00b6 Usage of CMake variables: $ cmake -DVariable = <value> ... The following CMake variables can be used at the configure (cmake) stage to adjust the compiling settings. ENABLE_BUILD_STORAGE \u00b6 Starting from the 2.0 pre-release, Nebula Graph supports separated compute and storage. The ENABLE_BUILD_STORAGE variable is set to OFF by default so that the storage service is not installed together with the graph service. If you are deploying Nebula Graph on a single host for testing, you can set ENABLE_BUILD_STORAGE to ON to download and install the storage service automatically. CMAKE_INSTALL_PREFIX \u00b6 CMAKE_INSTALL_PREFIX specifies the path where the service modules, scripts, configuration files are installed. The default path is /usr/local/nebula . ENABLE_WERROR \u00b6 ENABLE_WERROR is ON by default and it makes all warnings into errors. You can set it to OFF if needed. ENABLE_TESTING \u00b6 ENABLE_TESTING is ON by default and unit tests are built with the Nebula Graph services. If you just need the service modules, set it to OFF . ENABLE_ASAN \u00b6 ENABLE_ASAN is OFF by default and the building of ASan (AddressSanitizer), a memory error detector, is disabled. To enable it, set ENABLE_ASAN to ON . This variable is intended for Nebula Graph developers. CMAKE_BUILD_TYPE \u00b6 Nebula Graph supports the following building types: Debug , the default value of CMAKE_BUILD_TYPE , indicates building Nebula Graph with the debug info but not the optimization options. Release , indicates building Nebula Graph with the optimization options but not the debug info. RelWithDebInfo , indicates building Nebula Graph with the optimization options and the debug info. MinSizeRel , indicates building Nebula Graph with the optimization options for controlling the code size but not the debug info. CMAKE_C_COMPILER/CMAKE_CXX_COMPILER \u00b6 Usually, CMake locates and uses a C/C++ compiler installed in the host automatically. But if your compiler is not installed at the standard path, or if you want to use a different one, run the command as follows to specify the installation path of the target compiler: $ cmake -DCMAKE_C_COMPILER = /path/to/gcc/bin/gcc -DCMAKE_CXX_COMPILER = /path/to/gcc/bin/g++ .. $ cmake -DCMAKE_C_COMPILER = /path/to/clang/bin/clang -DCMAKE_CXX_COMPILER = /path/to/clang/bin/clang++ .. ENABLE_CCACHE \u00b6 ENABLE_CCACHE is ON by default and ccache is used to speed up the compiling of Nebula Graph. To disable ccache , set ENABLE_CCACHE to OFF . On some platforms, the ccache installation hooks up or precedes the compiler. In such a case, you have to set an environment variable export CCACHE_DISABLE=true or add a line disable=true in ~/.ccache/ccache.conf as well. For more information, see the ccache official documentation . NEBULA_THIRDPARTY_ROOT \u00b6 NEBULA_THIRDPARTY_ROOT specifies the path where the third party software is installed. By default it is /opt/vesoft/third-party . What to do next \u00b6 Start and stop Nebula Graph [TODO] Connect to Nebula Graph Try Nebula Graph CRUD","title":"Install Nebula\u00a0Graph by compiling the source code"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#install_nebula_graph_by_compiling_the_source_code","text":"Installing Nebula Graph from the source code allows you to customize the compiling and installation settings and test the latest features.","title":"Install Nebula Graph by compiling the source code"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#prerequisites","text":"You have prepared the necessary resources described in Prepare resources for compiling, installing, and running Nebula Graph . You can access the Internet from the host you plan to install Nebula Graph.","title":"Prerequisites"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#how_to_install","text":"Use Git to clone the source code of Nebula Graph to your host. * To install the latest version of Nebula Graph 2.x, run the following command to download the source code from the master branch. ```bash $ git clone https://github.com/vesoft-inc/nebula-graph.git ``` * To install a specific version of Nebula Graph 2.x, use the --branch <branch_name> option to specify the correct branch. For example, to install 2.0.0 beta, run the following command. ```bash $ git clone --branch v2.0.0-beta https://github.com/vesoft-inc/nebula-graph.git ``` Make the nebula-graph directory the current working directory. $ cd nebula-graph Create a build directory and make it the current working directory. $ mkdir build && cd build Generate the Makefile with CMake. NOTE : The installation path is /user/local/nebula by default. To customize it, add the -DCMAKE_INSTALL_PREFIX=/your/install/path/ CMake variable in the following command. For more information about CMake variables, see CMake variables . If you are installing the latest version of Nebula Graph 2.x and has cloned the master branch in step 1, run the following command. ```bash $ cmake -DENABLE_BUILD_STORAGE=on -DENABLE_TESTING=OFF -DCMAKE_BUILD_TYPE=Release .. ``` If you are installing a specific version of Nebula Graph 2.x and has cloned the corresponding branch in step 1, use the -DNEBULA_COMMON_REPO_TAG and -DNEBULA_STORAGE_REPO_TAG options to specify the correct branches of the nebula-common and nebula-storage repositories. For example, to install 2.0.0 beta, run the following command. ```bash $ cmake -DENABLE_BUILD_STORAGE=on -DENABLE_TESTING=OFF -DCMAKE_BUILD_TYPE=Release \\ --DNEBULA_COMMON_REPO_TAG=v2.0.0-beta -DNEBULA_STORAGE_REPO_TAG=v2.0.0-beta .. ``` Compile Nebula Graph. Assuming cores is the number of CPU cores and mem_gb is the memory size (in GB), to appropriately speed up the compiling, you can use the value of the smaller one between cores and mem_gb/2 as the value of N in the following command. $ make -j { N } Install Nebula Graph. $ make install-all","title":"How to install"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#cmake_variables","text":"Usage of CMake variables: $ cmake -DVariable = <value> ... The following CMake variables can be used at the configure (cmake) stage to adjust the compiling settings.","title":"CMake variables"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_build_storage","text":"Starting from the 2.0 pre-release, Nebula Graph supports separated compute and storage. The ENABLE_BUILD_STORAGE variable is set to OFF by default so that the storage service is not installed together with the graph service. If you are deploying Nebula Graph on a single host for testing, you can set ENABLE_BUILD_STORAGE to ON to download and install the storage service automatically.","title":"ENABLE_BUILD_STORAGE"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#cmake_install_prefix","text":"CMAKE_INSTALL_PREFIX specifies the path where the service modules, scripts, configuration files are installed. The default path is /usr/local/nebula .","title":"CMAKE_INSTALL_PREFIX"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_werror","text":"ENABLE_WERROR is ON by default and it makes all warnings into errors. You can set it to OFF if needed.","title":"ENABLE_WERROR"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_testing","text":"ENABLE_TESTING is ON by default and unit tests are built with the Nebula Graph services. If you just need the service modules, set it to OFF .","title":"ENABLE_TESTING"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_asan","text":"ENABLE_ASAN is OFF by default and the building of ASan (AddressSanitizer), a memory error detector, is disabled. To enable it, set ENABLE_ASAN to ON . This variable is intended for Nebula Graph developers.","title":"ENABLE_ASAN"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#cmake_build_type","text":"Nebula Graph supports the following building types: Debug , the default value of CMAKE_BUILD_TYPE , indicates building Nebula Graph with the debug info but not the optimization options. Release , indicates building Nebula Graph with the optimization options but not the debug info. RelWithDebInfo , indicates building Nebula Graph with the optimization options and the debug info. MinSizeRel , indicates building Nebula Graph with the optimization options for controlling the code size but not the debug info.","title":"CMAKE_BUILD_TYPE"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#cmake_c_compilercmake_cxx_compiler","text":"Usually, CMake locates and uses a C/C++ compiler installed in the host automatically. But if your compiler is not installed at the standard path, or if you want to use a different one, run the command as follows to specify the installation path of the target compiler: $ cmake -DCMAKE_C_COMPILER = /path/to/gcc/bin/gcc -DCMAKE_CXX_COMPILER = /path/to/gcc/bin/g++ .. $ cmake -DCMAKE_C_COMPILER = /path/to/clang/bin/clang -DCMAKE_CXX_COMPILER = /path/to/clang/bin/clang++ ..","title":"CMAKE_C_COMPILER/CMAKE_CXX_COMPILER"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_ccache","text":"ENABLE_CCACHE is ON by default and ccache is used to speed up the compiling of Nebula Graph. To disable ccache , set ENABLE_CCACHE to OFF . On some platforms, the ccache installation hooks up or precedes the compiler. In such a case, you have to set an environment variable export CCACHE_DISABLE=true or add a line disable=true in ~/.ccache/ccache.conf as well. For more information, see the ccache official documentation .","title":"ENABLE_CCACHE"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#nebula_thirdparty_root","text":"NEBULA_THIRDPARTY_ROOT specifies the path where the third party software is installed. By default it is /opt/vesoft/third-party .","title":"NEBULA_THIRDPARTY_ROOT"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#what_to_do_next","text":"Start and stop Nebula Graph [TODO] Connect to Nebula Graph Try Nebula Graph CRUD","title":"What to do next"}]}